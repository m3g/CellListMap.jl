<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples ¬∑ CellListMap.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Mean-difference-of-coordinates"><span>Mean difference of coordinates</span></a></li><li><a class="tocitem" href="#Histogram-of-distances"><span>Histogram of distances</span></a></li><li><a class="tocitem" href="#Gravitational-potential"><span>Gravitational potential</span></a></li><li><a class="tocitem" href="#Gravitational-force"><span>Gravitational force</span></a></li><li><a class="tocitem" href="#Nearest-neighbour"><span>Nearest neighbour</span></a></li><li><a class="tocitem" href="#Neighbour-list"><span>Neighbour list</span></a></li><li><a class="tocitem" href="#Units,-automatic-differentiation,-etc."><span>Units, automatic differentiation, etc.</span></a></li></ul></li><li><a class="tocitem" href="../pbc/">Periodic conditions</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../options/">Options</a></li><li><a class="tocitem" href="../help/">Help entries</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/m3g/CellListMap.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>The full code of the examples described here is available at the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/">examples</a> directory. </p><h2 id="Mean-difference-of-coordinates"><a class="docs-heading-anchor" href="#Mean-difference-of-coordinates">Mean difference of coordinates</a><a id="Mean-difference-of-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-difference-of-coordinates" title="Permalink"></a></h2><p>Computing the mean difference in <code>x</code> position between random particles. The closure is used to remove the indexes and the distance of the particles from the parameters of the input function, as they are not needed in this case.</p><pre><code class="language-julia hljs">using CellListMap

# System properties
N = 100_000
sides = [250,250,250]
cutoff = 10

# Particle positions
x = [ sides .* rand(3) for i in 1:N ]

# Initialize linked lists and box structures
box = Box(sides,cutoff)
cl = CellList(x,box)

# Function to be evaluated from positions 
f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])
normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

# Run calculation (0.0 is the initial value)
avg_dx = normalization * map_pairwise!(
    (x,y,i,j,d2,sum_dx) -&gt; f(x,y,sum_dx), 0.0, box, cl 
)</code></pre><p>The example above can be run with <code>CellListMap.Examples.average_displacement()</code> and is available in the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/average_displacement.jl">average_displacement.jl</a> file.</p><h2 id="Histogram-of-distances"><a class="docs-heading-anchor" href="#Histogram-of-distances">Histogram of distances</a><a id="Histogram-of-distances-1"></a><a class="docs-heading-anchor-permalink" href="#Histogram-of-distances" title="Permalink"></a></h2><p>Computing the histogram of the distances between particles (considering the same particles as in the above example). Again, we use a closure to remove the positions and indexes of the particles from the function arguments, because they are not needed. The distance, on the other side, is needed in this example:</p><pre><code class="language-julia hljs"># Function that accumulates the histogram of distances
function build_histogram!(d2,hist)
    d = sqrt(d2)
    ibin = floor(Int,d) + 1
    hist[ibin] += 1
    return hist
end;

# Initialize (and preallocate) the histogram
hist = zeros(Int,10);
normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

# Run calculation
hist = normalization * map_pairwise!(
    (x,y,i,j,d2,hist) -&gt; build_histogram!(d2,hist),
    hist,box,cl
)
</code></pre><p>The example above can be run with <code>CellListMap.Examples.distance_histogram()</code> and is available in the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/distance_histogram.jl">distance_histogram.jl</a> file.</p><h2 id="Gravitational-potential"><a class="docs-heading-anchor" href="#Gravitational-potential">Gravitational potential</a><a id="Gravitational-potential-1"></a><a class="docs-heading-anchor-permalink" href="#Gravitational-potential" title="Permalink"></a></h2><p>In this test we compute the &quot;gravitational potential&quot;, assigning to each particle a different mass. In this case, the closure is used to pass the masses to the function that computes the potential.</p><pre><code class="language-julia hljs"># masses
const mass = rand(N)

# Function to be evaluated for each pair 
function potential(i,j,d2,mass,u)
    d = sqrt(d2)
    u = u - 9.8*mass[i]*mass[j]/d
    return u
end

# Run pairwise computation
u = map_pairwise!((x,y,i,j,d2,u) -&gt; potential(i,j,d2,mass,u),0.0,box,cl)</code></pre><p>The example above can be run with <code>CellListMap.Examples.gravitational_potential()</code> and is available in the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/gravitational_potential.jl">gravitational_potential.jl</a> file.</p><h2 id="Gravitational-force"><a class="docs-heading-anchor" href="#Gravitational-force">Gravitational force</a><a id="Gravitational-force-1"></a><a class="docs-heading-anchor-permalink" href="#Gravitational-force" title="Permalink"></a></h2><p>In the following example, we update a force vector of for all particles.</p><pre><code class="language-julia hljs"># masses
const mass = rand(N)

# Function to be evaluated for each pair: update force vector
function calc_forces!(x,y,i,j,d2,mass,forces)
    G = 9.8*mass[i]*mass[j]/d2
    d = sqrt(d2)
    df = (G/d)*(x - y)
    forces[i] = forces[i] - df
    forces[j] = forces[j] + df
    return forces
end

# Initialize and preallocate forces
forces = [ zeros(SVector{3,Float64}) for i in 1:N ]

# Run pairwise computation
forces = map_pairwise!(
    (x,y,i,j,d2,forces) -&gt; calc_forces!(x,y,i,j,d2,mass,forces),
    forces,box,cl
)
</code></pre><p>The example above can be run with <code>CellListMap.Examples.gravitational_force()</code> and is available in the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/gravitational_force.jl">gravitational_force.jl</a> file.</p><h2 id="Nearest-neighbour"><a class="docs-heading-anchor" href="#Nearest-neighbour">Nearest neighbour</a><a id="Nearest-neighbour-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-neighbour" title="Permalink"></a></h2><p>Here we compute the indexes of the particles that satisfy the minimum distance between two sets of points, using the linked lists. The distance and the indexes are stored in a tuple, and a reducing method has to be defined for that tuple to run the calculation.  The function does not need the coordinates of the points, only their distance and indexes.</p><pre><code class="language-julia hljs"># Number of particles, sides and cutoff
N1=1_500
N2=1_500_000
sides = [250,250,250]
cutoff = 10.
box = Box(sides,cutoff)

# Particle positions
x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N1 ]
y = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N2 ]

# Initialize auxiliary linked lists
cl = CellList(x,y,box)

# Function that keeps the minimum distance
f(i,j,d2,mind) = d2 &lt; mind[3] ? (i,j,d2) : mind

# We have to define our own reduce function here
function reduce_mind(output,output_threaded)
    mind = output_threaded[1]
    for i in 2:Threads.nthreads()
        if output_threaded[i][3] &lt; mind[3]
            mind = output_threaded[i]
        end
    end
    return mind
end

# Initial value
mind = ( 0, 0, +Inf )

# Run pairwise computation
mind = map_pairwise!( 
    (x,y,i,j,d2,mind) -&gt; f(i,j,d2,mind),
    mind,box,cl;reduce=reduce_mind
)</code></pre><p>The example above can be run with <code>CellListMap.Examples.nearest_neighbour()</code> and is available in the <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/nearest_neighbour.jl">nearest_neighbour.jl</a> file.</p><p>The example <code>CellListMap.Examples.nearest_neighbour_nopbc()</code> of <a href="https://github.com/m3g/CellListMap.jl/blob/main/src/examples/nearest_neighbour_nopbc.jl">nearest_neighbour_nopbc.jl</a> describes a similar problem but <em>without</em> periodic boundary conditions. Depending on the distribution of points and size it is a faster method than usual ball-tree methods. </p><h2 id="Neighbour-list"><a class="docs-heading-anchor" href="#Neighbour-list">Neighbour list</a><a id="Neighbour-list-1"></a><a class="docs-heading-anchor-permalink" href="#Neighbour-list" title="Permalink"></a></h2><p>Obs: The package provides a <code>neighbourlist</code> function that implements this calculation, and can be used with:</p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; CellListMap.neighbourlist(x,0.05)
24778-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 62, 0.028481068525796384)
 ‚ãÆ
 (9954, 1749, 0.04887502372299809)
 (9974, 124, 0.040110356034451795)</code></pre><p>or <code>CellListMap.neighbourlist(x,y,r)</code> for computing the lists of pairs of two sets closer than <code>r</code>.</p><p>The returning array contains tuples with the index of the particle in the first vector, the index of the particle in the second vector, and their distance.</p><p>The implementation of this function follows the principles below.   The empty <code>pairs</code> output array will be split in one vector for each thread, and reduced with a custom reduction function. </p><pre><code class="language-julia hljs"># Function to be evaluated for each pair: push pair
function push_pair!(i,j,d2,pairs)
    d = sqrt(d2)
    push!(pairs,(i,j,d))
    return pairs
end

# Reduction function
function reduce_pairs(pairs,pairs_threaded)
    pairs = pairs_threaded[1]
    for i in 2:Threads.nthreads()
        append!(pairs,pairs_threaded[i])
    end
    return pairs
end

# Initialize output
pairs = Tuple{Int,Int,Float64}[]

# Run pairwise computation
pairs = map_pairwise!(
    (x,y,i,j,d2,pairs) -&gt; push_pair!(i,j,d2,pairs),
    pairs,box,cl,
    reduce=reduce_pairs
)</code></pre><p>The full example can be run with <code>CellListMap.Examples.neighbourlist()</code>, available in the file  <a href="https://github.com/m3g/CellListMap.jl/blob/src/examples/neighbourlist.jl">neighbourlist.jl</a>.</p><h2 id="Units,-automatic-differentiation,-etc."><a class="docs-heading-anchor" href="#Units,-automatic-differentiation,-etc.">Units, automatic differentiation, etc.</a><a id="Units,-automatic-differentiation,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Units,-automatic-differentiation,-etc." title="Permalink"></a></h2><p>The functions of CellListMap.jl support the propagation of generic (isbits) types, and thus units and thus automatic differentiation and the use of <code>Unitful</code>. A set of working examples can be found in the <a href="https://github.com/m3g/CellListMap.jl/blob/src/examples/generic_types.jl">generic_types.jl</a> file.</p><h3 id="Unitful-and-units"><a class="docs-heading-anchor" href="#Unitful-and-units"><code>Unitful</code> and units</a><a id="Unitful-and-units-1"></a><a class="docs-heading-anchor-permalink" href="#Unitful-and-units" title="Permalink"></a></h3><p>We start illustrating the support for unit propagation. We need to define all involved quantities in the same units:</p><pre><code class="language-julia-repl hljs">julia&gt; using Unitful, StaticArrays

julia&gt; cutoff = 0.1u&quot;nm&quot; 
0.1 nm

julia&gt; box = Box([1.0, 1.0, 1.0]u&quot;nm&quot;,cutoff)
Box{OrthorhombicCell, 3, Quantity{Float64, ùêã, Unitful.FreeUnits{(nm,), ùêã, nothing}}, Quantity{Float64, ùêã^2, Unitful.FreeUnits{(nm^2,), ùêã^2, nothing}}, 9}
  unit cell matrix = [ 1.0 nm, 0.0 nm, 0.0 nm; 0.0 nm, 1.0 nm, 0.0 nm; 0.0 nm, 0.0 nm, 1.0 nm ]
  cutoff = 0.1 nm
  number of computing cells on each dimension = [12, 12, 12]
  computing cell sizes = [0.1 nm, 0.1 nm, 0.1 nm] (lcell: 1)
  Total number of cells = 1728

julia&gt; x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];

julia&gt; cl = CellList(x,box)
CellList{3, Quantity{Float64, ùêã, Unitful.FreeUnits{(nm,), ùêã, nothing}}}
  1000 real particles.
  626 cells with real particles.
  1694 particles in computing box, including images.</code></pre><p>The corresponding mapping must take care of defining the result in the correct units associated to the expected output. For example, here we will compute just the sum of the squared distances between the particles within the cutoff. Thus, the expected output has the same units as the square of the dimensions: </p><pre><code class="language-julia-repl hljs">julia&gt; sum_sqr = zero(typeof(cutoff^2))
0.0 nm^2

julia&gt; sum_sqr = map_pairwise!(
           (x,y,i,j,d2,sum_sqr) -&gt; sum_sqr += d2,
           sum_sqr, box, cl
       )
12.983283925249138 nm^2</code></pre><p>The performance penalty associated to propagating units is small. With units, we get:</p><pre><code class="nohighlight hljs">julia&gt; using BenchmarkTools

julia&gt; @btime let x = $x
           cutoff = 0.1u&quot;nm&quot; 
           box = Box([1.0,1.0,1.0]u&quot;nm&quot;,cutoff)
           cl = CellList(x,box)
           sum_sqr = zero(typeof(cutoff^2))
           map_pairwise!(
               (x,y,i,j,d2,sum_sqr) -&gt; sum_sqr += d2,
               sum_sqr, box, cl
           )
       end
  1.828 ms (6547 allocations: 1.22 MiB)
12.983283925249138 nm^2</code></pre><p>and the same problem without units runs in:</p><pre><code class="language-julia-repl hljs">julia&gt; @btime let x = $([ SVector{3,Float64}(ustrip.(v)) for v in x ])
           cutoff = 0.1 
           box = Box([1.0,1.0,1.0],cutoff)
           cl = CellList(x,box)
           sum_sqr = 0.
           map_pairwise!(
               (x,y,i,j,d2,sum_sqr) -&gt; sum_sqr += d2,
               sum_sqr, box, cl
           )
       end
  1.783 ms (6547 allocations: 1.22 MiB)
12.983283925249138</code></pre><p>Auxiliary functions, like <code>CellListMap.neighbourlist</code>, propagate units correctly:</p><pre><code class="language-julia-repl hljs">julia&gt; cutoff = 0.1u&quot;nm&quot;
0.1 nm

julia&gt; box = Box([1.0, 1.0, 1.0]u&quot;nm&quot;,cutoff);

julia&gt; x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];

julia&gt; CellListMap.neighbourlist(x,cutoff)
1796-element Vector{Tuple{Int64, Int64, Quantity{Float64, ùêã, Unitful.FreeUnits{(nm,), ùêã, nothing}}}}:
 (1, 583, 0.06456224519583421 nm)
 (10, 216, 0.04958058924623024 nm)
 ‚ãÆ
 (934, 615, 0.08834318454969409 nm)
 (934, 692, 0.05002019032986014 nm)</code></pre><h3 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h3><p>Allowing automatic differentiation follows the same principles, meaning that we only need to allow the propagation of dual types through the computation by proper initialization of the input data.</p><p>The variables are each component of each vector, thus the easiest way to represent the points such that automatic differentiation packages understand is by creating a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(3,1000)
3√ó1000 Matrix{Float64}:
 0.186744  0.328719  0.874102  0.503535   ‚Ä¶  0.328161  0.0895699  0.917338
 0.176157  0.972954  0.80729   0.624724      0.655268  0.470754   0.327578
 0.648482  0.537362  0.599624  0.0688776     0.92333   0.497984   0.208924</code></pre><p>The key here is allow all the types of the parameters to follow the type propagation of the elements of <code>x</code> inside the differentiation routine. The function we define to compute the derivative is, then:</p><pre><code class="language-julia-repl hljs">julia&gt; function sum_sqr(x,sides,cutoff)
           cutoff = eltype(x)(cutoff)
           sides = eltype(x).(sides)
           box = Box(sides,cutoff)
           cl = CellList(x,box)
           sum_sqr = zero(eltype(x))
           sum_sqr = map_pairwise!(
               (x,y,i,j,d2,sum_sqr) -&gt; sum_sqr += d2,
               sum_sqr, box, cl
           )
           return sum_sqr
       end
sum_sqr (generic function with 1 method)</code></pre><p>Note that we allow <code>cutoff</code>  and <code>sides</code>  to be converted to the same type of the input <code>x</code>  of the function. For a simple call to the function this is inconsequential:</p><pre><code class="language-julia-repl hljs">julia&gt; cutoff = 0.1; sides = [1,1,1];

julia&gt; sum_sqr(x,sides,cutoff)
12.897650398753228</code></pre><p>but the conversion is required to allow the differentiation to take place:</p><pre><code class="language-julia-repl hljs">julia&gt; ForwardDiff.gradient(x -&gt; sum_sqr(x,sides,cutoff),x)
3√ó1000 Matrix{Float64}:
 -0.132567   0.029865  -0.101301  ‚Ä¶   0.249267    0.0486424  -0.0400487
  0.122421   0.207495  -0.184366     -0.201648   -0.105031    0.218342
  0.0856502  0.288924   0.122445     -0.0147022  -0.103314   -0.0862264</code></pre><h3 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h3><p>Propagating uncertainties through the <code>Measurements</code>  and other similar packages requires a different strategy, because within <code>CellListMap</code> only <code>isbits</code> types can be used, which is not the case of the type <code>Measurement</code> type. </p><p>In cases like this, it is better to bypass all the internals of <code>CellListMap</code>  and provide the data to the function that computes pairwise properties directly as a closure. For example:</p><p>A vector of particles with uncertainties in their coordinates can be created with: </p><pre><code class="language-julia-repl hljs">julia&gt; using StaticArrays 

julia&gt; x_input = [ SVector{3}(measurement(rand(),0.01*rand()) for i in 1:3) for j in 1:1000 ]
1000-element Vector{SVector{3, Measurement{Float64}}}:
 [0.1658 ¬± 0.003, 0.9951 ¬± 0.0054, 0.5067 ¬± 0.0035]
 [0.2295 ¬± 0.0074, 0.2987 ¬± 0.0021, 0.42828 ¬± 0.00099]
 ‚ãÆ
 [0.1362 ¬± 0.0034, 0.2219 ¬± 0.0048, 0.2119 ¬± 0.0072]
 [0.2521 ¬± 0.0038, 0.4988 ¬± 0.00013, 0.856046 ¬± 4.3e-5]</code></pre><p>The variables within the <code>CellListMap</code> functions will be stripped from the uncertainties. We do:</p><pre><code class="language-julia-repl hljs">julia&gt; cutoff = 0.1; box = Box([1,1,1],cutoff);

julia&gt; x_strip = [ getproperty.(v,:val) for v in x_input ]
1000-element Vector{SVector{3, Float64}}:
 [0.08441931492362276, 0.9911530546181084, 0.07408559584648788]
 [0.12084764467339837, 0.8284551316333133, 0.9021906852432111]
 ‚ãÆ
 [0.2418752113326077, 0.4429225751775432, 0.13576355747772784]
 [0.24440380524702654, 0.07148275176890073, 0.26722687487212315]
 ```

The cell list is built with the stripped values:
</code></pre><p>julia-repl julia&gt; cl = CellList(x_strip,box) CellList{3, Float64}   1000 real particles.   637 cells with real particles.   1695 particles in computing box, including images.</p><pre><code class="nohighlight hljs">
The result is initialized with the proper type,
</code></pre><p>julia&gt; sum_sqr = measurement(0.,0.) 0.0 ¬± 0.0</p><pre><code class="nohighlight hljs">
and the mapping is performed with the stripped coordinates, but passing the values with uncertainties to the mapped function, which will perform the computation on the pairs with those values:
</code></pre><p>julia&gt; using LinearAlgebra: norm_sqr</p><p>julia&gt; sum<em>sqr = map</em>pairwise!(            (x·µ¢,x‚±º,i,j,d2,sum<em>sqr) -&gt; begin                x1 = x</em>input[i]                x2 = CellListMap.wrap<em>relative</em>to(x<em>input[j],x1,box)                sum</em>sqr += norm<em>sqr(x2-x1)                return sum</em>sqr            end,             sum_sqr, box, cl        ) 13.14 ¬± 0.061 ```</p><p>In the function above, the <code>x·µ¢</code> and <code>x‚±º</code> coordinates, which correspond to the coordinates in <code>x_input[i]</code> and <code>x_input[j]</code>, but already wrapped relative to each other, are ignored, because they don&#39;t carry the uncertainties. We use only the indexes <code>i</code> and <code>j</code> to recompute the relative position of the particles according to the periodic boundary conditions (using the <code>CellListMap.wrap_relative_to</code> function) and their (squared) distance. Since the <code>x_input</code>  array carries the uncertainties, the computation of <code>sum_sqr</code> will propagate them.   </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All these computations should be performed inside the scope of a function for optimal performance. The examples here can be followed by copying and pasting the code into the REPL, but this is not the recommended practice for critical code. The strategy of bypassing the internal computations of <code>CellListMap</code> may be useful for improving performance even if the previous and simpler method is possible. </p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Overview</a><a class="docs-footer-nextpage" href="../pbc/">Periodic conditions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 9 November 2021 19:43">Tuesday 9 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
