var documenterSearchIndex = {"docs":
[{"location":"PeriodicSystems/#PeriodicSystems-interface","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The PeriodicSystems interface facilitates the use of CellListMap for the majority of cases. To use it, load the PeriodicSystems module directly, with:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThis interface requires CellListMap.jl version 0.7.22 or greater.\nThe complete codes of the examples are at the end of this page, with examples of:\nSimple energy computation\nForce computation\nEnergy and forces\nTwo sets of particles\nParticle simulation","category":"page"},{"location":"PeriodicSystems/#The-mapped-function","page":"PeriodicSystems interface","title":"The mapped function","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The function to be mapped for every pair of particles within the cutoff follows the same interface as the standard interface. It must be of the form","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function f(x, y, i, j, d2, output)\n    # update output variable\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"where x and y are the positions of the particles, already wrapped relative to each other according to the periodic boundary conditions (a minimum-image set of positions), i and j are the indexes of the particles in the arrays of coordinates, d2 is the squared distance between the particles, and output is the variable to be computed. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, computing the energy, as the sum of the inverse of the distance between particles, can be done with a function like:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy(d2,u)\n    u += 1 / sqrt(d2)\n    return u\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"and the additional parameters required by the interface can be eliminated by the use of an anonymous function, directly on the call to the `map_pairwise!  function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"u = map_pairwise((x,y,i,j,d2,u) -> energy(d2,u), system)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"(what system is will be explained in the examples below).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Alternatively, the function might require additional parameters, such as the masses of the particles. In this case, we can use a closure to provide such data:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy(i,j,d2,u,masses)\n    u += masses[i]*masses[j] / sqrt(d2)\n    return u\nend\nconst masses = # ... some masses\nu = map_pairwise((x,y,i,j,d2,u) -> energy(d2,u,masses), system)","category":"page"},{"location":"PeriodicSystems/#Potential-energy-example","page":"PeriodicSystems interface","title":"Potential energy example","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThe output of the CellListMap computation may be of any kind. Most commonly, it is an energy, a set of forces, or other data type that can be represented either as a number, an array of numbers, or an array of vectors (SVectors in particular), such as arrays of forces.  Additionally, the properties are frequently additive (the energy is the sum of the energy of the particles, or the forces are added by summation). For these types of output data the usage of CellListMap.PeriodicSystems is the simplest, and does not require the implementation of any data-type dependent function. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, let us build a system of random particles in a cubic box, and compute an \"energy\", which in this case is simply the sum of 1/d over all pair of particles, within a cutoff.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The PeriodicSystem constructor receives the properties of the system and sets up automatically the most commonly used data structures necessary. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> using CellListMap.PeriodicSystems, StaticArrays\n\njulia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1.0,1.0,1.0], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now, directly, let us compute a putative energy of the particles, assuming a simple formula which depends on the inverse of the distance between pairs:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise!((x,y,i,j,d2,energy) -> energy += 1 / sqrt(d2), system)\n30679.386366872823","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The system.energy field accesses the resulting value of the computation:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.energy\n30679.386366872823","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"because the output_name field was provided. If it is not provided, you can access the output value from the system.output field.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nSystems can be 2 or 3-dimensional. \nThe unitcell parameter may be either a vector, as in the example, or a unit cell matrix, for general boundary conditions.\nUnitful quantities can be provided, given appropriate types for all input parameters. ","category":"page"},{"location":"PeriodicSystems/#Computing-forces","page":"PeriodicSystems interface","title":"Computing forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Following the example above, let us compute the forces between the particles. We have to define the function that computes the force between a pair of particles and updates the array of forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function update_forces!(x,y,i,j,d2,forces)\n    d = sqrt(d2)\n    df = (1/d2)*(1/d)*(y - x)\n    forces[i] += df\n    forces[j] -= df\n    return forces\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Importantly, the function must return the forces array to follow the API. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now, let us setup the system with the new type of output variable, which will be now an array of forces with the same type as the positions:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> positions = rand(SVector{3,Float64},1000);\n\njulia> system = PeriodicSystem(\n           xpositions = positions,\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = similar(positions),\n           output_name = :forces\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Let us note that the forces where reset upon the construction of the system:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.forces\n1000-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n ⋮\n [0.0, 0.0, 0.0]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"A call to map_pairwise! with the appropriate function definition will update the forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1000-element Vector{SVector{3, Float64}}:\n [-151.19529230407284, 159.33819000196905, -261.3055111242796]\n [-173.02442398784672, -178.782819965489, 4.570607952876692]\n ⋮\n [-722.5400961501635, 182.65287417718935, 380.0394926753039]","category":"page"},{"location":"PeriodicSystems/#Computing-both-energy-and-forces","page":"PeriodicSystems interface","title":"Computing both energy and forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example we define a general type of output variable, for which custom copy, reset, and reduction functions must be defined. It can be followed for the computation of other general properties from the particle positions.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nInterface to be implemented:Method Return What it does\ncopy_output(x::T) new instance of type T Copies an element of the output type T.\nreset_output!(x::T) mutated x Resets (usually zero) the value of x to the initial value it must assume before mapping.  If x is immutable, the function can return a new instance of T.\nreducer(x::T,y::T) mutated x Reduces x and y into x (for example x = x + y). If x is immutable, returns a new instance of type T.Remark: if the output is an array of an immutable type T, the methods above can be defined for single instances of T, which is simpler than for the arrays.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems, StaticArrays","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The computation of energies and forces in a single call is an interesting example for the definition of a custom output type and the required interface functions.  Let us first define an output variable containing both quantities:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"mutable struct EnergyAndForces\n    energy::Float64\n    forces::Vector{SVector{3,Float64}}\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now we need to define what it means to copy, reset, and reduce this new type of output. We overload the default corresponding functions, for our new output type:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The copy method creates a new instance of the EnergyAndForces type, with copied data:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: copy_output\ncopy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The reset method will zero both the energy and all forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: reset_output!\nfunction reset_output!(output::EnergyAndForces)\n    output.energy = 0.0\n    for i in eachindex(output.forces)\n        output.forces[i] = SVector(0.0, 0.0, 0.0)\n    end\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The reduction function defines what it means to combine two output variables obtained on independent threads. In this case, we sum the energies and forces. Different reduction functions might be necessary for other custom types (for example if computing minimum distances).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: reducer\nfunction reducer(x::EnergyAndForces, y::EnergyAndForces)\n    e_tot = x.energy + y.energy\n    x.forces .+= y.forces\n    return EnergyAndForces(e_tot, x.forces)\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Note that in the above example, we reuse the x.forces array in the return instance of EnergyAndForces. You must always reduce from right to left, and reuse the possible buffers of the first argument of the reducer (in this case, x).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"warning: Warning\nAll these functions must return the modified output variable, to adhere to the interface.\nThe proper definition of a reduction function is crucial for correctness. Please verify your results if using the default reducer function, which sums the elements.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now we can proceed as before, defining a function that updates the output variable appropriately:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)\n    d = sqrt(d2)\n    output.energy += 1/d\n    df = (1/d2)*(1/d)*(y - x)\n    output.forces[i] += df\n    output.forces[j] -= df\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"To finally define the system and compute the properties:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"positions = rand(SVector{3,Float64},1000);\n\nsystem = PeriodicSystem(\n    xpositions = positions,\n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = EnergyAndForces(0.0, similar(positions)),\n    output_name = :energy_and_forces\n);\n\nmap_pairwise((x,y,i,j,d2,output) -> energy_and_forces!(x,y,i,j,d2,output), system);","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The output can be seen with the aliases of the system.output variable:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.energy_and_forces.energy\n31696.94766439311\n\njulia> system.energy_and_forces.forces\n1000-element Vector{SVector{3, Float64}}:\n [-338.1909601911842, 7.7663690656924445, 202.25889647151405]\n [33.67299655756128, 282.7581453168999, -79.09639223837306]\n ⋮\n [38.83014327604529, -204.45236278342745, 249.307871211616]","category":"page"},{"location":"PeriodicSystems/#Updating-coordinates,-unit-cell,-and-cutoff","page":"PeriodicSystems interface","title":"Updating coordinates, unit cell, and cutoff","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the map_pairwise! function will compute energy and/or forces in a iterative procedure (a simulation, for instance), we need to update the coordinates, and perhaps the unit cell and the cutoff.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Updating coordinates\nUpdating the unit cell\nUpdating the cutoff","category":"page"},{"location":"PeriodicSystems/#Updating-coordinates","page":"PeriodicSystems interface","title":"Updating coordinates","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The coordinates can be updated (mutated, or the array of coordinates can change in size by pushing or deleting particles), simply by directly acessing the xpositions field of the system. Let us exemplify the interface with the computation of forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> using CellListMap.PeriodicSystems, StaticArrays\n\njulia> positions = rand(SVector{3,Float64}, 1000);\n\njulia> system = PeriodicSystem(\n           xpositions = positions,\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = similar(positions),\n           output_name = :forces\n       );\n\njulia> system.xpositions[1]\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.6391290709055079\n 0.43679325975360894\n 0.8231829019768698\n\njulia> system.xpositions[1] = zeros(SVector{3,Float64})\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.0\n 0.0\n\njulia> push!(system.xpositions, SVector(0.5, 0.5, 0.5))\n1001-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, 0.0]\n [0.5491373098208292, 0.23899915605319244, 0.49058287555218516]\n ⋮\n [0.4700394061063937, 0.5440026379397457, 0.7411235688716618]\n [0.5, 0.5, 0.5]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"warning: Warning\nThe output variable may have to be resized accordingly, depending on the calculation being performed. Use the resize_output! function  (do not use Base.resize! on your output array directly).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the output array has to be resized, that has to be done with the  resize_output! function, which will keep the consistency of the auxiliary multi-threading buffers. This is, for instance, the case  in the example of computation of forces, as the forces array must be of the same length as the array of positions:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> resize_output!(system, length(system.xpositions));\n\njulia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1001-element Vector{SVector{3, Float64}}:\n [756.2076075886971, -335.1637545330828, 541.8627090466914]\n [-173.02442398784672, -178.782819965489, 4.570607952876692]\n ⋮\n [-722.5400961501635, 182.65287417718935, 380.0394926753039]\n [20.27985502389337, -193.77607810950286, -155.28968519541544]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this case, if the output is not resized, a BoundsError: is be obtained, because updates of forces at unavailable positions will be attempted. ","category":"page"},{"location":"PeriodicSystems/#Updating-the-unit-cell","page":"PeriodicSystems interface","title":"Updating the unit cell","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The unit cell can be updated to new dimensions at any moment, with the update_unitcell! function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> update_unitcell!(system, SVector(1.2, 1.2, 1.2))\nPeriodicSystem1 of dimension 3, composed of:\n    Box{CellListMap.OrthorhombicCell, 3}\n      unit cell matrix = [ 1.2, 0.0, 0.0; 0.0, 1.2, 0.0; 0.0, 0.0, 1.2 ]\n      cutoff = 0.1\n      number of computing cells on each dimension = [13, 13, 13]\n      computing cell sizes = [0.11, 0.11, 0.11] (lcell: 1)\n      Total number of cells = 2197\n    CellListMap.CellList{3, Float64}\n      1000 real particles.\n      623 cells with real particles.\n      1719 particles in computing box, including images.\n    Parallelization auxiliary data set for: \n      Number of batches for cell list construction: 8\n      Number of batches for function mapping: 12\n    Type of output variable (forces): Vector{SVector{3, Float64}}","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThe unit cell can be set initially using a vector or a unit cell matrix. If a vector is provided the system is considered Orthorhombic, if a matrix is provided, a Triclinic system is built.  Unit cells updates must preserve the system type. \nIt is recommended (but not mandatory) to use static arrays (or Tuples) to update the unitcell,  as in this case the update will be non-allocating. ","category":"page"},{"location":"PeriodicSystems/#Updating-the-cutoff","page":"PeriodicSystems interface","title":"Updating the cutoff","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The cutoff can also be updated, using the update_cutoff! function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> update_cutoff!(system, 0.2)\nPeriodicSystem1 of dimension 3, composed of:\n    Box{CellListMap.OrthorhombicCell, 3}\n      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]\n      cutoff = 0.2\n      number of computing cells on each dimension = [7, 7, 7]\n      computing cell sizes = [0.2, 0.2, 0.2] (lcell: 1)\n      Total number of cells = 343\n    CellListMap.CellList{3, Float64}\n      1000 real particles.\n      125 cells with real particles.\n      2792 particles in computing box, including images.\n    Parallelization auxiliary data set for: \n      Number of batches for cell list construction: 8\n      Number of batches for function mapping: 8\n    Type of output variable (forces): Vector{SVector{3, Float64}}\n\njulia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1000-element Vector{SVector{3, Float64}}:\n [306.9612911344924, -618.7375562535321, -607.1449767066479]\n [224.0803003775478, -241.05319348787023, 67.53780411933884]\n ⋮\n [2114.4873184508524, -3186.265279868732, -6777.748445712408]\n [-25.306486853608945, 119.69319481834582, 104.1501577339471]","category":"page"},{"location":"PeriodicSystems/#Computations-for-two-sets-of-particles","page":"PeriodicSystems interface","title":"Computations for two sets of particles","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the computation involves two sets of particle, a similar interface is available.  The only difference is that the coordinates of the two sets must be provided to the PeriodicSystem constructor as the xpositions and ypositions arrays.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"We will illustrate this interface by computing the minimum distance between two sets of particles, which allows us to showcase further the definition of custom type interfaces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"First, we define a variable type that will carry the indexes and  the distance of the closest pair of particles:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> struct MinimumDistance\n           i::Int\n           j::Int\n           d::Float64\n       end","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The function that, given two particles, retains the minimum distance, is:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> function minimum_distance(i, j, d2, md)\n           d = sqrt(d2)\n           if d < md.d\n               md = MinimumDistance(i, j, d)\n           end\n           return md\n       end\nminimum_distance (generic function with 1 method)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"We overload copy, reset, and reduce functions, accordingly:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> import CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!\n\njulia> copy_output(md::MinimumDistance) = md\ncopy_output (generic function with 5 methods)\n\njulia> reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)\nreset_output! (generic function with 5 methods)\n\njulia> reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d < md2.d ? md1 : md2\nreducer! (generic function with 2 methods)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Note that since MinimumDistance is immutable, copying it is the same as returning the value.  Also, resetting the minimum distance consists of setting its d field to +Inf. And, finally, reducing the threaded distances consists of keeping the pair with the shortest distance. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Next, we build the system","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> xpositions = rand(SVector{3,Float64},1000);\n\njulia> ypositions = rand(SVector{3,Float64},1000);\n\njulia> system = PeriodicSystem(\n           xpositions = xpositions,\n           ypositions = ypositions, \n           unitcell=[1.0,1.0,1.0], \n           cutoff = 0.1, \n           output = MinimumDistance(0,0,+Inf),\n           output_name = :minimum_distance,\n        )","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"And finally we can obtain the minimum distance between the sets: ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)\nMinimumDistance(276, 617, 0.006009804808785543)","category":"page"},{"location":"PeriodicSystems/#Additional-execution-options","page":"PeriodicSystems interface","title":"Additional execution options","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Turn parallelization on and off\nDisplaying a progress bar\nFine control of the paralellization\nAvoid cell list updating\nControl CellList cell size","category":"page"},{"location":"PeriodicSystems/#Turn-parallelization-on-and-off","page":"PeriodicSystems interface","title":"Turn parallelization on and off","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The use of parallel computations can be tunned on and of by the system.parallel boolean flag. For example, using 6 cores (12 threads) for the calculation of the minimum-distance example: ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> f(system) = map_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)\nf (generic function with 1 method)\n\njulia> Threads.nthreads()\n8\n\njulia> system.parallel = true\ntrue\n\njulia> @btime f($system)\n  268.265 μs (144 allocations: 16.91 KiB)\nMinimumDistance(783, 497, 0.007213710914619913)\n\njulia> system.parallel = false\nfalse\n\njulia> @btime f($system)\n  720.304 μs (0 allocations: 0 bytes)\nMinimumDistance(783, 497, 0.007213710914619913)","category":"page"},{"location":"PeriodicSystems/#Displaying-a-progress-bar","page":"PeriodicSystems interface","title":"Displaying a progress bar","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Displaying a progress bar: for very long runs, the user might want to see the progress of the computation. Use the show_progress keyword parameter of the map_pairwise!  function for that.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, we execute the computation above, but with much more particles:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> xpositions = rand(SVector{3,Float64},10^6);\n\njulia> ypositions = rand(SVector{3,Float64},10^6);\n\njulia> system = PeriodicSystem(\n                  xpositions = xpositions,\n                  ypositions = ypositions, \n                  unitcell=[1.0,1.0,1.0], \n                  cutoff = 0.1, \n                  output = MinimumDistance(0,0,+Inf),\n                  output_name = :minimum_distance,\n               );\n\njulia> map_pairwise(\n           (x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system; \n           show_progress = true\n       )\nProgress:  24%|██████████▏                               |  ETA: 0:00:29","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"By activating the show_progress flag, a nice progress bar is shown. ","category":"page"},{"location":"PeriodicSystems/#Fine-control-of-the-paralellization","page":"PeriodicSystems interface","title":"Fine control of the paralellization","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The number of batches launched in parallel runs can be tunned by the  nbatches keyword parameter of the PeriodicSystem constructor.  By default, the number of batches is defined as heuristic function  dependent on the number of particles, and possibly returns optimal values in most cases. For a detailed dicussion about this parameter,  see Number of batches.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, to set the number of batches for cell list calculation to 4 and the number of batches for mapping to 8, we can do:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy,\n           nbatches=(4,8), # use this keyword \n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Most times it is expected that the default parameters are optimal. But particularly for  inhomogeneous systems increasing the number of batches of the mapping phase (second parameter of the tuple) may improve the performance by reducing the idle time of  threads.","category":"page"},{"location":"PeriodicSystems/#Avoid-cell-list-updating","page":"PeriodicSystems interface","title":"Avoid cell list updating","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"To compute different properties without recomputing cell lists, use update_lists=false in  the call of map_pairwise methods, for example,","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems, StaticArrays\nsystem = PeriodicSystem(xpositions=rand(SVector{3,Float64},1000), output=0.0, cutoff=0.1, unitcell=[1,1,1])\n# First call, will compute the cell lists\nmap_pairwise((x,y,i,j,d2,u) -> u += d2, system)\n# Second run: do not update the cell lists but compute a different property\nmap_pairwise((x,y,i,j,d2,u) -> u += sqrt(d2), system; update_lists = false)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"in which case we are computing the sum of distances from the same cell lists used to compute the energy in the previous example (requires version 0.8.9). Specifically, this will skip the updating of the cell lists, thus be careful to not use this option if the cutoff, unitcell, or any other property of the system changed. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For systems with two sets of particles, the  coordinates of the xpositions set can be updated, preserving the cell lists computed for the ypositions, but this requires setting autoswap=false in the construction of the PeriodicSystem: ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems, StaticArrays\nsystem = PeriodicSystem(\n    xpositions=rand(SVector{3,Float64},1000), \n    ypositions=rand(SVector{3,Float64},2000),\n    output=0.0, cutoff=0.1, unitcell=[1,1,1],\n    autoswap=false # Cell lists are constructred for ypositions\n)\nmap_pairwise((x,y,i,j,d2,u) -> u += d2, system)\n# Second run: preserve the cell lists but compute a different property\nmap_pairwise((x,y,i,j,d2,u) -> u += sqrt(d2), system; update_lists = false)","category":"page"},{"location":"PeriodicSystems/#Control-CellList-cell-size","page":"PeriodicSystems interface","title":"Control CellList cell size","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The cell sizes of the construction of the cell lists can be controled with the keyword lcell of the PeriodicSystem constructor. For example:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy,\n           lcell=2,\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Most times using lcell=1 (default) or lcell=2 will provide the optimal performance. For very dense systems, or systems for which the number of particles within the cutoff is very large, larger values of lcell may improve the performance. To be tested by the user.","category":"page"},{"location":"PeriodicSystems/#Complete-example-codes","page":"PeriodicSystems interface","title":"Complete example codes","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Simple energy computation\nForce computation\nEnergy and forces\nTwo sets of particles\nParticle simulation","category":"page"},{"location":"PeriodicSystems/#Simple-energy-computation","page":"PeriodicSystems interface","title":"Simple energy computation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, a simple potential energy defined as the sum of the  inverse of the distance between the particles is computed.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\nsystem = PeriodicSystem(\n    xpositions = rand(SVector{3,Float64},1000), \n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = 0.0,\n    output_name = :energy\n)\nmap_pairwise!((x,y,i,j,d2,energy) -> energy += 1 / sqrt(d2), system)","category":"page"},{"location":"PeriodicSystems/#Force-computation","page":"PeriodicSystems interface","title":"Force computation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Here we compute the force vector associated to the potential energy function of the previous example.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\npositions = rand(SVector{3,Float64},1000) \nsystem = PeriodicSystem(\n    xpositions = positions, \n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = similar(positions),\n    output_name = :forces\n)\nfunction update_forces!(x,y,i,j,d2,forces)\n    d = sqrt(d2)\n    df = (1/d2)*(1/d)*(y - x)\n    forces[i] += df\n    forces[j] -= df\n    return forces\nend\nmap_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)","category":"page"},{"location":"PeriodicSystems/#Energy-and-forces","page":"PeriodicSystems interface","title":"Energy and forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, the potential energy and the forces are computed in a single run, and a custom data structure is defined to store both values.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\n# Define custom type\nmutable struct EnergyAndForces\n    energy::Float64\n    forces::Vector{SVector{3,Float64}}\nend\n# Custom copy, reset and reducer functions\nimport CellListMap.PeriodicSystems: copy_output, reset_output!, reducer\ncopy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))\nfunction reset_output!(output::EnergyAndForces)\n    output.energy = 0.0\n    for i in eachindex(output.forces)\n        output.forces[i] = SVector(0.0, 0.0, 0.0)\n    end\n    return output\nend\nfunction reducer(x::EnergyAndForces, y::EnergyAndForces)\n    e_tot = x.energy + y.energy\n    x.forces .+= y.forces\n    return EnergyAndForces(e_tot, x.forces)\nend\n# Function that updates energy and forces for each pair\nfunction energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)\n    d = sqrt(d2)\n    output.energy += 1/d\n    df = (1/d2)*(1/d)*(y - x)\n    output.forces[i] += df\n    output.forces[j] -= df\n    return output\nend\n# Initialize system\npositions = rand(SVector{3,Float64},1000);\nsystem = PeriodicSystem(\n    xpositions = positions,\n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = EnergyAndForces(0.0, similar(positions)),\n    output_name = :energy_and_forces\n)\n# Compute energy and forces\nmap_pairwise((x,y,i,j,d2,output) -> energy_and_forces!(x,y,i,j,d2,output), system)","category":"page"},{"location":"PeriodicSystems/#Two-sets-of-particles","page":"PeriodicSystems interface","title":"Two sets of particles","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example we illustrate the interface for the computation of properties of two sets of particles, by computing the minimum distance between the two sets.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\n# Custom structure to store the minimum distance pair\nstruct MinimumDistance\n    i::Int\n    j::Int\n    d::Float64\nend\n# Function that updates the minimum distance found\nfunction minimum_distance(i, j, d2, md)\n    d = sqrt(d2)\n    if d < md.d\n        md = MinimumDistance(i, j, d)\n    end\n    return md\nend\n# Define appropriate methods for copy, reset and reduce \nimport CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!\ncopy_output(md::MinimumDistance) = md\nreset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)\nreducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d < md2.d ? md1 : md2\n# Build system \nxpositions = rand(SVector{3,Float64},1000);\nypositions = rand(SVector{3,Float64},1000);\nsystem = PeriodicSystem(\n       xpositions = xpositions,\n       ypositions = ypositions, \n       unitcell=[1.0,1.0,1.0], \n       cutoff = 0.1, \n       output = MinimumDistance(0,0,+Inf),\n       output_name = :minimum_distance,\n)\n# Compute the minimum distance\nmap_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)","category":"page"},{"location":"PeriodicSystems/#Particle-simulation","page":"PeriodicSystems interface","title":"Particle simulation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, a complete particle simulation is illustrated, with a simple potential.  This example can illustrate how particle positions and forces can be updated. Run this simulation with:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = init_system(N=200); # number of particles\n\njulia> trajectory = simulate(system);\n\njulia> animate(trajectory)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"One important characteristic of this example is that the system is built outside the function that performs the simulation. This is done because the construction of the system is type-unstable (it is dimension, geometry and output-type dependent). Adding a function barrier avoids type-instabilities to propagate to the simulation causing possible performance problems. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using StaticArrays\nusing CellListMap.PeriodicSystems\nimport CellListMap.wrap_relative_to\n# Function that updates the forces, for potential of the form:\n# if d < cutoff k*(d^2-cutoff^2)^2 else 0.0 with k = 10^6\nfunction update_forces!(x, y, i, j, d2, forces, cutoff)\n    r = y - x\n    dudr = 10^6 * 4 * r * (d2 - cutoff^2)\n    forces[i] += dudr\n    forces[j] -= dudr\n    return forces\nend\n# Function that initializes the system: it is preferrable to initialize\n# the system outside the function that performs the simulation, because\n# the system (data)type is defined on initialization. Initializing it outside\n# the simulation function avoids possible type-instabilities. \nfunction init_system(;N::Int=200)\n    Vec2D = SVector{2,Float64}\n    positions = rand(Vec2D, N)\n    unitcell = [1.0, 1.0]\n    cutoff = 0.1\n    system = PeriodicSystem(\n        positions=positions,\n        cutoff=cutoff,\n        unitcell=unitcell,\n        output=similar(positions),\n        output_name=:forces,\n    )\n    return system\nend\nfunction simulate(system=init_system(); nsteps::Int=100, isave=1)\n    # initial velocities\n    velocities = [ randn(eltype(system.positions)) for _ in 1:length(system.positions) ]\n    dt = 1e-3\n    trajectory = typeof(system.positions)[]\n    for step in 1:nsteps\n        # compute forces at this step\n        map_pairwise!(\n            (x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces,system.cutoff),\n            system\n        )\n        # Update positions and velocities\n        for i in eachindex(system.positions, system.forces)\n            f = system.forces[i]\n            x = system.positions[i]\n            v = velocities[i]\n            x = x + v * dt + (f / 2) * dt^2\n            v = v + f * dt\n            # wrapping to origin for obtaining a pretty animation\n            x = wrap_relative_to(x, SVector(0.0, 0.0), system.unitcell)\n            # !!! IMPORTANT: Update arrays of positions and velocities\n            system.positions[i] = x\n            velocities[i] = v\n        end\n        # Save step for printing\n        if step % isave == 0\n            push!(trajectory, copy(system.positions))\n        end\n    end\n    return trajectory\nend\n\nusing Plots\nfunction animate(trajectory)\n    anim = @animate for step in trajectory\n        scatter(\n            Tuple.(step),\n            label=nothing,\n            lims=(-0.5, 0.5),\n            aspect_ratio=1,\n            framestyle=:box,\n        )\n    end\n    gif(anim, \"simulation.gif\", fps=10)\nend","category":"page"},{"location":"neighborlists/#Neighbor-lists","page":"Neighbor lists","title":"Neighbor lists","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Neighbor lists can be computed, returning all pairs of particles that are found within the cutoff, and the corresponding distances.  ","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Non-periodic systems\nPeriodic systems\nIn-place computation of neighbor lists\nOptions","category":"page"},{"location":"neighborlists/#Non-periodic-systems","page":"Neighbor lists","title":"Non-periodic systems","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Without periodic boundary conditions, just provide the coordinates and the cutoff:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> using CellListMap\n\njulia> x = [ rand(2) for _ in 1:10_000 ];\n\njulia> neighborlist(x,0.05)\n376457-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 363, 0.04855594810064624)\n (1, 513, 0.03356381123125866)\n (1, 1209, 0.005159666709130686)\n ⋮\n (6575, 7378, 0.03791567990447959)\n (7378, 3450, 0.01748757015908321)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"If the neighbor lists between two sets of points are required, use the following notation:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> x = rand(SVector{3,Float64},10^4);\n\njulia> y = rand(SVector{3,Float64},10^3);\n\njulia> list = neighborlist(x,y,0.1)\n37309-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 971, 0.09867846773727411)\n (1, 567, 0.06630101425431004)\n (1, 3, 0.04103170149300593)\n ⋮\n (10000, 156, 0.08549899843141298)\n (10000, 444, 0.0737386384422871)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"where, similarly, the third parameter is the cutoff. The returning array contains tuples with the index of the particle in the first vector, the index of the particle in the second vector, and their distance.","category":"page"},{"location":"neighborlists/#Periodic-systems","page":"Neighbor lists","title":"Periodic systems","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"If periodic boundary conditions are used, the unitcell can be provided explicitly as keyword parameters:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> x = [ rand(2) for _ in 1:10_000 ]; \n\njulia> neighborlist(x, 0.05; unitcell=[1,1])\n392100-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 5, 0.03445098850037766)\n (1, 393, 0.039448810592487206)\n (1, 1632, 0.02276457565643465)\n ⋮\n (9501, 9781, 0.03351665194098955)\n (9501, 5429, 0.04199258248973222)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"In the example above, an Orthorhombic cell was assumed, and thus a vector of sides was provided. For general periodic boundary conditions, a unit cell matrix can be provided, for example:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> neighborlist(x, 0.05; unitcell=[1.0 0.5; 0.5 1.0])\n580693-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 457, 0.03935441952786555)\n (1, 1467, 0.033407692174569875)\n (1, 1767, 0.04490555313598093)\n ⋮\n (3652, 8475, 0.04721628783510375)\n (6260, 8475, 0.04946130971686825)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"note: Note\nPositions and unit cells can be 2 or 3-dimensional.","category":"page"},{"location":"neighborlists/#In-place-computation-of-neighbor-lists","page":"Neighbor lists","title":"In-place computation of neighbor lists","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"If neighbor lists are computed within a interative scenario, it is interesting preallocate all the necessary data and just update the lists at every iteration. This can be achieved by constructing the InPlaceNeighborList  object in advance. The performance gain of performing the operations in place might vary and may not be  important for single runs, as the allocations do not dominate the computing time. ","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"We will first illustrate the interface for a non-parallel run:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> using CellListMap, StaticArrays\n\njulia> x = rand(SVector{3,Float64}, 10^4);\n\njulia> system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1], parallel=false)\nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 0","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Note that the buffer size has size 0. The first time the neighbor lists are computed, the list will be allocated. We will use the neighborlist! (with the bang) function, because it will effectivelly  mutate the system, by allocating all necessary data:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> @time list = neighborlist!(system)\n  0.017765 seconds (12 allocations: 7.445 MiB)\n209190-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 1375, 0.09425551992016712)\n (1, 3076, 0.045320021406080775)\n (1, 3666, 0.07780146666634076)\n ⋮\n (9962, 6983, 0.07355578793348823)\n (9962, 7457, 0.07597724209140656)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Now, if we modify the coordinates, we can update the system and recompute the neighbor lists:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> @time update!(system, x_new)\n  0.003562 seconds\nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 209190\n\njulia> @time list = neighborlist!(system);\n  0.012338 seconds","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"note: Note\nHere we illustrate the behavior of the functions in their second calls, to remove the  effects of compilation on the allocation results.\nThe cutoff and unitcell  can be modified by providing additional keyword parameters to the update! function (for example update!(system, x; cutoff=0.1)).\nAllocations can occur if the cutoff, unit cell, or number of particles change such that greater buffers are required. The number of allocations tend to disminish as  the buffers become large enough to accomodate the possible variations of the computation.","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"For parallel runs, the allocations are minimal, but some small auxiliary data is required for the launching of multiple threads. We illustrate here the convergence of the allocations to the  minimum required for multi-threaded calculations:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1], parallel=true);\n\njulia> @time list = neighborlist!(system);\n  0.007762 seconds (230 allocations: 18.142 MiB)\n\njulia> x_new = rand(SVector{3,Float64},10^4);\n\njulia> @time update!(system, x_new)\n  0.005283 seconds (20.30 k allocations: 6.200 MiB)\nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 209190\n\njulia> @time neighborlist!(system);\n  0.008190 seconds (166 allocations: 6.461 MiB)\n\njulia> x_new = rand(SVector{3,Float64},10^4);\n\njulia> @time update!(system, x_new);\n  0.002723 seconds (221 allocations: 208.922 KiB)\n\njulia> @time neighborlist!(system);\n  0.006227 seconds (165 allocations: 2.863 MiB)\n\njulia> x_new = rand(SVector{3,Float64},10^4);\n\njulia> @time update!(system, x_new);\n  0.002396 seconds (275 allocations: 144.078 KiB)\n\njulia> @time neighborlist!(system);\n  0.004996 seconds (161 allocations: 15.141 KiB)","category":"page"},{"location":"neighborlists/#Options","page":"Neighbor lists","title":"Options","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Additional optional parameters can be used in a neighborlist call:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"Keyword Values types Default About\nparallel Bool true turns on and off parallelization\nshow_progress Bool false turns on and off progress bar\nnbatches Tuple{Int,Int} (0,0) Number of batches used in parallelization (see here)\nautoswap Bool true (advanced) automatically choose set to construct the cell lists","category":"page"},{"location":"citation/#Citation","page":"Citation","title":"Citation","text":"","category":"section"},{"location":"citation/","page":"Citation","title":"Citation","text":"If you use this software, please be kind to cite the following article in relevant publications, to keep us motivated in developing  new features and enhancements:","category":"page"},{"location":"citation/","page":"Citation","title":"Citation","text":"L. Martínez, CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff. Computer Physics Communications, 279, 108452, (2022). DOI: 10.1016/j.cpc.2022.108452","category":"page"},{"location":"ecosystem/#Ecosystem-integration","page":"Ecosystem integration","title":"Ecosystem integration","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Agents.jl\nUnitful and units\nAutomatic differentiation\nMeasurements","category":"page"},{"location":"ecosystem/#Agents.jl","page":"Ecosystem integration","title":"Agents.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Agents.jl provides a comprehensive framework for simulation, analysis and visualization of agent-based systems. CellListMap can be used to accelerate these simulations, and the integration of the packages is rather simple, particularly using the PeriodicSystems interface. A complete integration example can be obtained in the Agents documentation (currently at the development branch). ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The example will produce the following animation:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"https://juliadynamics.github.io/Agents.jl/dev/examples/celllistmap.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"ecosystem/#Unitful-and-units","page":"Ecosystem integration","title":"Unitful and units","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The functions of CellListMap.jl support the propagation of generic (isbits) types, and thus units and thus automatic differentiation and the use of Unitful. A set of working examples can be found in the generic_types.jl file.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"We start illustrating the support for unit propagation. We need to define all involved quantities in the same units:","category":"page"},{"location":"ecosystem/#Using-the-PeriodicSystems-interface","page":"Ecosystem integration","title":"Using the PeriodicSystems interface","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The only requirement is to attach proper units to all quantities (positions, cutoff, unitcell, and output variables). Here we compute the square of the distances of the particles within the cutoff:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using CellListMap.PeriodicSystems, Unitful, StaticArrays\n\njulia> system = PeriodicSystem(\n           positions = rand(SVector{3,Float64}, 1000)u\"nm\",\n           cutoff = 0.1u\"nm\",\n           unitcell = [1.0,1.0,1.0]u\"nm\",\n           output = 0.0u\"nm^2\",\n           output_name = :sum_sqr\n       );\n\njulia> map_pairwise((x,y,i,j,d2,out) -> out += d2, system)\n12.467455105066907 nm^2","category":"page"},{"location":"ecosystem/#Units-in-neighbor-lists","page":"Ecosystem integration","title":"Units in neighbor lists","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"CellListMap.neighborlist propagates units correctly:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> import CellListMap\n\njulia> positions = rand(SVector{3,Float64}, 1000)u\"nm\";\n\njulia> cutoff = 0.1u\"nm\";\n\njulia> CellListMap.neighborlist(positions, cutoff)\n1842-element Vector{Tuple{Int64, Int64, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}}:\n (1, 89, 0.09181950064928723 nm)\n (1, 820, 0.0862244300739942 nm)\n ⋮\n (998, 782, 0.07772327062692863 nm)","category":"page"},{"location":"ecosystem/#Automatic-differentiation","page":"Ecosystem integration","title":"Automatic differentiation","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Allowing automatic differentiation follows the same principles, meaning that we only need to allow the propagation of dual types through the computation by proper initialization of the input data. However, it is easier to work with the low level interface, which accepts matrices as the input for positions and a more fine control of the types of the variables. Matrices are easier input types for auto diff packages.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The variables are each component of each vector, thus the easiest way to represent the points such that automatic differentiation packages understand is by creating a matrix:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> x = rand(3,1000)\n3×1000 Matrix{Float64}:\n 0.186744  0.328719  0.874102  0.503535   …  0.328161  0.0895699  0.917338\n 0.176157  0.972954  0.80729   0.624724      0.655268  0.470754   0.327578\n 0.648482  0.537362  0.599624  0.0688776     0.92333   0.497984   0.208924","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The key here is allow all the types of the parameters to follow the type propagation of the elements of x inside the differentiation routine. The function we define to compute the derivative is, then:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> function sum_sqr(x,sides,cutoff)\n           cutoff = eltype(x)(cutoff)\n           sides = eltype(x).(sides)\n           box = Box(sides,cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(eltype(x))\n           sum_sqr = map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n           return sum_sqr\n       end\nsum_sqr (generic function with 1 method)","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Note that we allow cutoff  and sides  to be converted to the same type of the input x  of the function. For a simple call to the function this is inconsequential:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cutoff = 0.1; sides = [1,1,1];\n\njulia> sum_sqr(x,sides,cutoff)\n12.897650398753228","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"but the conversion is required to allow the differentiation to take place:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> ForwardDiff.gradient(x -> sum_sqr(x,sides,cutoff),x)\n3×1000 Matrix{Float64}:\n -0.132567   0.029865  -0.101301  …   0.249267    0.0486424  -0.0400487\n  0.122421   0.207495  -0.184366     -0.201648   -0.105031    0.218342\n  0.0856502  0.288924   0.122445     -0.0147022  -0.103314   -0.0862264","category":"page"},{"location":"ecosystem/#Measurements","page":"Ecosystem integration","title":"Measurements","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Propagating uncertainties through the Measurements  and other similar packages requires a different strategy, because within CellListMap only isbits types can be used, which is not the case of the type Measurement type. ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"In cases like this, it is better to bypass all the internals of CellListMap  and provide the data to the function that computes pairwise properties directly as a closure. For example:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"A vector of particles with uncertainties in their coordinates can be created with: ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using StaticArrays \n\njulia> x_input = [ SVector{3}(measurement(rand(),0.01*rand()) for i in 1:3) for j in 1:1000 ]\n1000-element Vector{SVector{3, Measurement{Float64}}}:\n [0.1658 ± 0.003, 0.9951 ± 0.0054, 0.5067 ± 0.0035]\n [0.2295 ± 0.0074, 0.2987 ± 0.0021, 0.42828 ± 0.00099]\n ⋮\n [0.1362 ± 0.0034, 0.2219 ± 0.0048, 0.2119 ± 0.0072]\n [0.2521 ± 0.0038, 0.4988 ± 0.00013, 0.856046 ± 4.3e-5]","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The variables within the CellListMap functions will be stripped from the uncertainties. We do:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cutoff = 0.1; box = Box([1,1,1],cutoff);\n\njulia> x_strip = [ getproperty.(v,:val) for v in x_input ]\n1000-element Vector{SVector{3, Float64}}:\n [0.08441931492362276, 0.9911530546181084, 0.07408559584648788]\n [0.12084764467339837, 0.8284551316333133, 0.9021906852432111]\n ⋮\n [0.2418752113326077, 0.4429225751775432, 0.13576355747772784]\n [0.24440380524702654, 0.07148275176890073, 0.26722687487212315]","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The cell list is built with the stripped values:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cl = CellList(x_strip,box)\nCellList{3, Float64}\n  1000 real particles.\n  637 cells with real particles.\n  1695 particles in computing box, including images.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The result is initialized with the proper type,","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> sum_sqr = measurement(0.,0.)\n0.0 ± 0.0","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"and the mapping is performed with the stripped coordinates, but passing the values with uncertainties to the mapped function, which will perform the computation on the pairs with those values:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using LinearAlgebra: norm_sqr\n\njulia> sum_sqr = map_pairwise!(\n           (xᵢ,xⱼ,i,j,d2,sum_sqr) -> begin\n               x1 = x_input[i]\n               x2 = CellListMap.wrap_relative_to(x_input[j],x1,box.input_unit_cell.matrix)\n               sum_sqr += norm_sqr(x2-x1)\n               return sum_sqr\n           end, \n           sum_sqr, box, cl\n       )\n13.14 ± 0.061","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"In the function above, the xᵢ and xⱼ coordinates, which correspond to the coordinates in x_input[i] and x_input[j], but already wrapped relative to each other, are ignored, because they don't carry the uncertainties. We use only the indexes i and j to recompute the relative position of the particles according to the periodic boundary conditions (using the CellListMap.wrap_relative_to function) and their (squared) distance. Since the x_input  array carries the uncertainties, the computation of sum_sqr will propagate them.   ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"note: Note\nAll these computations should be performed inside the scope of a function for optimal performance. The examples here can be followed by copying and pasting the code into the REPL, but this is not the recommended practice for critical code. The strategy of bypassing the internal computations of CellListMap may be useful for improving performance even if the previous and simpler method is possible. ","category":"page"},{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"These entries can be viewed at the Julia REPL Julia using ","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? \nhelp?> function_name","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"Modules=[CellListMap]","category":"page"},{"location":"help/#CellListMap.AuxThreaded","page":"Help entries","title":"CellListMap.AuxThreaded","text":"struct AuxThreaded{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nparticles_per_batch::Int64\nidxs::Vector{UnitRange{Int64}}: Default: Vector{UnitRange{Int}}(undef, 0)\nlists::Array{CellList{N, T}, 1} where {N, T}: Default: Vector{CellList{N, T}}(undef, 0)\n\nAuxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellListPair{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type for lists of disjoint particle sets,  to be passed to UpdateCellList! for in-place update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellList{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type, to be passed to UpdateCellList! for in-place  update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for _ in 1:100_000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box","page":"Help entries","title":"CellListMap.Box","text":"struct Box{UnitCellType, N, T, TSQ, M, TR}\n\nInternal function or structure - interface may change.\n\nExtended help\n\ninput_unit_cell::CellListMap.UnitCell\naligned_unit_cell::CellListMap.UnitCell\nrotation::StaticArraysCore.SMatrix{N, N, TR, M} where {N, M, TR}\ninv_rotation::StaticArraysCore.SMatrix{N, N, TR, M} where {N, M, TR}\nlcell::Int64\nnc::StaticArraysCore.SVector{N, Int64} where N\ncutoff::Any\ncutoff_sqr::Any\ncomputing_box::Tuple{StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}} where {N, T}\ncell_size::StaticArraysCore.SVector\n\nStructure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. \n\nExamples\n\njulia> using CellListMap\n\njulia> sides = [250,250,250];\n\njulia> cutoff = 10;\n\njulia> box = Box(sides,cutoff)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [27, 27, 27]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 19683\n\n\njulia> box = Box([ 10  0  0 \n                    0 10  5\n                    0  0 10 ], 1)\nBox{TriclinicCell, 3, Float64, 9}\nunit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]\ncutoff: 1.0\nnumber of computing cells on each dimension: [12, 17, 12]\ncomputing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)\nTotal number of cells: 2448\n\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T","page":"Help entries","title":"CellListMap.Box","text":"Box(unitcell::Limits, cutoff; lcell::Int=1)\n\nThis constructor receives the output of limits(x) or limits(x,y) where x and y are the coordinates of the particles involved, and constructs a Box with size larger than the maximum coordinates ranges of all particles plus twice the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is an NonPeriodicCell box type, which internally is treated as Orthorhombic with boundaries that guarantee that particles do not see images of each other. \n\nExamples\n\njulia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),10)\nBox{NonPeriodicCell, 3}\n  unit cell matrix = [ 110.0, 0.0, 0.0; 0.0, 110.0, 0.0; 0.0, 0.0, 110.0 ]\n  cutoff = 10.0\n  number of computing cells on each dimension = [12, 12, 12]\n  computing cell sizes = [11.0, 11.0, 11.0] (lcell: 1)\n  Total number of cells = 1728\n\njulia> y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),10)\nBox{NonPeriodicCell, 3}\n  unit cell matrix = [ 160.0, 0.0, 0.0; 0.0, 160.0, 0.0; 0.0, 0.0, 110.0 ]\n  cutoff = 10.0\n  number of computing cells on each dimension = [17, 17, 12]\n  computing cell sizes = [10.67, 10.67, 11.0] (lcell: 1)\n  Total number of cells = 3468\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(unit_cell_matrix::AbstractMatrix, cutoff, lcell::Int=1, UnitCellType=TriclinicCell)\n\nConstruct box structure given the cell matrix of lattice vectors. This  constructor will always return a TriclinicCell box type, unless the UnitCellType parameter is set manually to OrthorhombicCell\n\nExample\n\njulia> unit_cell = [ 100   50    0 \n                       0  120    0\n                       0    0  130 ];\n\njulia> box = Box(unit_cell,10)\nBox{TriclinicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [17, 14, 15]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 3570\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(sides::AbstractVector, cutoff, lcell::Int=1, UnitCellType=OrthorhombicCell)\n\nFor orthorhombic unit cells, Box can be initialized with a vector of the length of each side. \n\nExample\n\njulia> box = Box([120,150,100],10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [14, 17, 12]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 2856\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Cell","page":"Help entries","title":"CellListMap.Cell","text":"struct Cell{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlinear_index::Int64\ncartesian_index::CartesianIndex\ncenter::StaticArraysCore.SVector\ncontains_real::Bool\nn_particles::Int64\nparticles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}\n\nThis structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighboring cells need to be wrapped) \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList","page":"Help entries","title":"CellListMap.CellList","text":"struct CellList{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nn_real_particles::Int64:  Number of real particles.\nnumber_of_cells::Int64:  Number of cells.\nn_particles::Int64:  mutable number of particles in the computing box.\nn_cells_with_real_particles::Int64:  mutable number of cells with real particles.\nn_cells_with_particles::Int64:  mutable number of cells with particles, real or images.\ncell_indices::Vector{Int64}:  Auxiliary array that contains the indexes in list of the cells with particles, real or images.\ncell_indices_real::Vector{Int64}:  Auxiliary array that contains the indexes in the cells with real particles.\ncells::Array{CellListMap.Cell{N, T}, 1} where {N, T}:  Vector containing cell lists of cells with particles.\nnbatches::CellListMap.NumberOfBatches:  Number of batches for the parallel calculations.\nprojected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}:  Auxiliar array to store projected particles.\n\nStructure that contains the cell lists information.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0),\n    autoswap::Bool=true\n) where {UnitCellType,N,T}\n\nFunction that will initialize a CellListPair structure from scracth, given two vectors of particle coordinates and a Box, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using autoswap=false the cell list is constructed for the second (y)\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   10000 particles in the reference vector.\n   961 cells with real particles of target vector.\n\njulia> cl = CellList(x,y,box,autoswap=false)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   7389 cells with real particles of target vector.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0)\n) where {UnitCellType,N,T}\n\nFunction that will initialize a CellList structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a Box, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100000 real particles.\n  15600 cells with real particles.\n  126276 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellListPair","page":"Help entries","title":"CellListMap.CellListPair","text":"struct CellListPair{V, N, T, Swap}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nref::Any\ntarget::CellList\n\nStructure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.InPlaceNeighborList","page":"Help entries","title":"CellListMap.InPlaceNeighborList","text":"mutable struct InPlaceNeighborList{B, C, A, NB<:CellListMap.NeighborList}\n\nInternal function or structure - interface may change.\n\nStructure that containst the system information for neighborlist computations. All fields are internal.\n\nExtended help\n\nbox::Any\ncl::Any\naux::Any\nnb::CellListMap.NeighborList\nnb_threaded::Vector{NB} where NB<:CellListMap.NeighborList\nparallel::Bool\nshow_progress::Bool\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.InPlaceNeighborList-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Help entries","title":"CellListMap.InPlaceNeighborList","text":"InPlaceNeighborList(;\n    x::AbstractVecOrMat,\n    y::Union{AbstractVecOrMat,Nothing}=nothing,\n    cutoff::T,\n    unitcell::Union{AbstractVecOrMat,Nothing}=nothing,\n    parallel::Bool=true,\n    show_progress::Bool=false,\n) where {T<:Real}\n\nFunction that initializes the InPlaceNeighborList structure, to be used for in-place computation of neighbor lists.\n\nIf only x is provided, the neighbor list of the set is computed. \nIf x and y are provided, the neighbor list between the sets is computed.\nIf unitcell is provided, periodic boundary conditions will be used. The unitcell can be a vector of Orthorhombic box sides, or an actual unitcell matrix for general cells. \nIf unicell is not provide (value nothing), no periodic boundary conditions will be considered. \n\nExamples\n\nHere the neighborlist structure is constructed for the first time, and used to compute the neighbor lists with the mutating neighborlist! function:\n\njulia> using CellListMap, StaticArrays\n\njulia> x = rand(SVector{3,Float64}, 10^4);\n\njulia> system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]) \nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 0\n\njulia> neighborlist!(system)\n210034-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 357, 0.09922225615002134)\n (1, 488, 0.043487074695938925)\n (1, 2209, 0.017779967072139684)\n ⋮\n (9596, 1653, 0.0897570322108541)\n (9596, 7927, 0.0898266280344037)\n\nThe coordinates of the system, its unitcell, or the cutoff can be changed with the update! function. If the number of pairs of the list does not change  significantly, the new calculation is minimally allocating, or non-allocating  at all, in particular if the computation is run without parallelization:\n\nIf the structure is used repeatedly for similar systems, the allocations will vanish, except for minor allocations used in the threading computation (if a  non-parallel computation is executed, the allocations will vanish completely):\n\njulia> x = rand(SVector{3,Float64}, 10^4);\n\njulia> system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]);\n\njulia> @time neighborlist!(system);\n  0.008004 seconds (228 allocations: 16.728 MiB)\n\njulia> update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);\n\njulia> @time neighborlist!(system);\n  0.024811 seconds (167 allocations: 7.887 MiB)\n\njulia> update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);\n\njulia> @time neighborlist!(system);\n  0.005213 seconds (164 allocations: 1.439 MiB)\n\njulia> update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);\n\njulia> @time neighborlist!(system);\n  0.005276 seconds (162 allocations: 15.359 KiB)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Limits","page":"Help entries","title":"CellListMap.Limits","text":"struct Limits{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlimits::StaticArraysCore.SVector\n\nStructure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.NumberOfBatches","page":"Help entries","title":"CellListMap.NumberOfBatches","text":"struct NumberOfBatches\n\nInternal function or structure - interface may change.\n\nExtended help\n\nbuild_cell_lists::Int64\nmap_computation::Int64\n\nStructure to define the number of batches used in the parallel splitting of the calculations of the cell list construction and of the map_pairwise computation. It is initialized with a standard heuristic that returns at most the number of threads, but may return a smaller number if the system is small. The two parameters can be tunned for optimal performance of each step of the calculation (cell list construction and mapping of interactions). The construction of the cell lists require a larger number of particles for threading to be effective, Thus by default the system size that allows multi-threading is greater for this part of the calculation.  \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ParticleWithIndex","page":"Help entries","title":"CellListMap.ParticleWithIndex","text":"struct ParticleWithIndex{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nreal::Bool\ncoordinates::StaticArraysCore.SVector\n\nCopies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ProjectedParticle","page":"Help entries","title":"CellListMap.ProjectedParticle","text":"struct ProjectedParticle{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nxproj::Any\ncoordinates::StaticArraysCore.SVector\n\nAuxiliary structure to contain projected particles. Types of  scalars are chosen such that with a SVector{3,Float64} the complete struct has 32bytes.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Swapped","page":"Help entries","title":"CellListMap.Swapped","text":"Internal function or structure - interface may change.\n\nStructures to control dispatch on swapped vs. not swapped cell list pairs.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl:CellListPair,\n    parallel=true\n)\n\nFunction that will update a previously allocated CellListPair structure, given  new updated particle positions, for example. This method will allocate new  aux threaded auxiliary arrays. For a non-allocating version, see the  UpdateCellList!(x,y,box,cl,aux) method.\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> cl = UpdateCellList!(x,y,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, Box, CellList}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl:CellList,\n    parallel=true\n)\n\nFunction that will update a previously allocated CellList structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the UpdateCellList!(x,box,cl,aux) method instead. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> box = Box([260,260,260],10);\n\njulia> x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = UpdateCellList!(x,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair, Union{Nothing, CellListMap.AuxThreaded}}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box,\n    cl_pair::CellListPair,\n    aux::Union{Nothing,AuxThreaded};\n    parallel::Bool=true\n) where {UnitCellType,N}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N},\n    cl_pair::CellListPair;\n    parallel::Bool=true\n) where {UnitCellType,N}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap<:CellListMap.NotSwapped}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl_pair::CellListPair,\n    aux::Union{Nothing,AuxThreaded};\n    parallel::Bool=true\n)\n\nThis function will update the cl_pair structure that contains the cell lists for disjoint sets of particles. It receives the preallocated aux structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7381 cells with real particles of target vector.\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = UpdateCellList!(x,y,box,cl,aux)\nCellList{3, Float64}\n  10000 real particles.\n  7358 cells with real particles.\n  12591 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux)\n  715.661 μs (41 allocations: 3.88 KiB)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7414 cells with real particles of target vector.\n   \njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)\n   13.042 ms (0 allocations: 0 bytes)\n CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n    50000 particles in the reference vector.\n    15031 cells with real particles of target vector.\n \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T},\n    aux::Union{Nothing,AuxThreaded{N,T}};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{<:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl::CellList{N,T},\n    aux::Union{Nothing,AuxThreaded{N,T}};\n    parallel::Bool=true\n) where {N,T}\n\nFunction that updates the cell list cl new coordinates x and possibly a new box box, and receives a preallocated aux structure of auxiliary vectors for threaded cell list construction. Given a preallocated aux vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux)\n  16.384 ms (41 allocations: 3.88 KiB)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)\n  20.882 ms (0 allocations: 0 bytes)\nCellList{3, Float64}\n  100000 real particles.\n  15603 cells with real particles.\n  125896 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap._promote_types-Tuple{Any, Any}","page":"Help entries","title":"CellListMap._promote_types","text":"_promote_types(cell,cutoff)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nPromotes the types of the unit cell matrix (or sides) and cutoff to floats if one or both were input as integers. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particle_to_celllist!","text":"add_particle_to_celllist!(\n    ip,\n    x::SVector{N,T},\n    box,\n    cl::CellList{N,T};\n    real_particle::Bool=true\n) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdds one particle to the cell lists, updating all necessary arrays.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particles!","text":"add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd all particles in vector x to the cell list cl. ishift is the shift in particle index, meaning that particle i of vector x corresponds to the particle with original index i+ishift. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.align_cell","page":"Help entries","title":"CellListMap.align_cell","text":"align_cell(m::StaticMatrix)\nalign_cell!(m::AbstractMatrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nThese functions rotate the unit cell matrix such that the largest lattice vector is oriented along the x-axis and, for 3D cells, also that the the plane formed by the largest and  second largest lattice vectors is oriented perpendicular to the z-axis. \n\n\n\n\n\n","category":"function"},{"location":"help/#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.append_particles!","text":"append_particles!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd the particles of cell2 to cell1, updating the cell data and, if necessary, resizing (increasing) the particles array of cell1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_cartesian_indices","text":"cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nGiven the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.cell_center","text":"cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nComputes the geometric center of a computing cell, to be used in the projection of points. Returns a SVector{N,T}\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_limits-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.cell_limits","text":"cell_limits(m::AbstractMatrix)\n\nInternal function or structure - interface may change.\n\nFor 2D and 3D matrices, returns the maximum and minimum coordinates of all vertices. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_linear_index","text":"cell_linear_index(nc::SVector{N,Int}, indices) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the index of the cell, in the 1D representation, from its cartesian coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}","page":"Help entries","title":"CellListMap.cell_matrix_from_sides","text":"cell_matrix_from_sides(sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the Orthorhombic unit cell matrix given a sides vector. This function is type-unstable if the input is not static.\n\nExample\n\njulia> CellListMap.cell_matrix_from_sides([1,1,1])\n3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_vertices-Tuple{AbstractMatrix}","page":"Help entries","title":"CellListMap.cell_vertices","text":"cell_vertices(m::AbstractMatrix)\n\nInternal function or structure - interface may change.\n\nFunction that returns the vertices of a unit cell in 2D or 3D, given the unit cell matrix.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.check_unit_cell-Tuple{Box}","page":"Help entries","title":"CellListMap.check_unit_cell","text":"check_unit_cell(box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nChecks if the unit cell satisfies the conditions for using the minimum-image convention. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.copydata!","text":"copydata!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nCopies the data from cell2 to cell1, meaning that particles are copied element-wise from cell2 to cell1, with the particles array of cell1 being resized (increased) if necessary.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.current_and_neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.current_and_neighbor_cells","text":"current_and_neighbor_cells(box::Box{UnitCellType,N}) where {UnitCellType,N}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns an iterator over all neighbor cells, including the center one.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Help entries","title":"CellListMap.dot","text":"dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nLinearAlgebra.dot is slower than this for standard arrays (likely more accurate, but that is not relevant here).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_cell-Tuple{AbstractMatrix}","page":"Help entries","title":"CellListMap.draw_cell","text":"draw_cell(m::AbstractMatrix; aspect_ratio=:auto)\n\nInternal function or structure - interface may change.\n\nDraw the unit cell in a 2D or 3D plot. Requires using Plots.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_cell_vertices-Tuple{AbstractMatrix}","page":"Help entries","title":"CellListMap.draw_cell_vertices","text":"draw_cell_vertices(m::AbstractMatrix)\n\nInternal function or structure - interface may change.\n\nFunction that returns the vertices of a unit cell matrix in 2D or 3D, as a vector of static vectors, in a proper order for ploting the cell (the first vertex, in the origin, is repeated at the end of the list, to close the figure)\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType\ndraw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType\n\nInternal function or structure - interface may change.\n\nThis function creates a plot of the computing cell, in two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType\n\nInternal function or structure - interface may change.\n\nThis function creates a plot of the computing cell, in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.fastmod1-Tuple{Any}","page":"Help entries","title":"CellListMap.fastmod1","text":"fastmod1(x)\n\nInternal function or structure - interface may change.\n\nComputes mod(x,1), quickly, using x - floor(x). Maybe irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.in_computing_box-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.in_computing_box","text":"in_computing_box(x::SVector{N},box::Box) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that evaluates if a particle is inside the computing bounding box, defined by the maximum and minimum unit aligned cell coordinates.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Tuple{AbstractVector{<:AbstractVector}}","page":"Help entries","title":"CellListMap.limits","text":"limits(x)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x,  to be used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector{<:AbstractVector})","page":"Help entries","title":"CellListMap.limits","text":"limits(x,y)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x and y, to used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_naive!-Tuple{Function, Any, AbstractVector, Box}","page":"Help entries","title":"CellListMap.map_naive!","text":"map_naive!(f::Function, output, x::AbstractVector, box::Box)\nmap_naive!(f::Function, output, x::AbstractVector, y::AbstractVector, box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that uses the naive pairwise mapping algorithm, for testing.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise","page":"Help entries","title":"CellListMap.map_pairwise","text":"map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)\n\nis an alias for map_pairwise! which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through juliacall does not accept the  bang as a valid character. \n\n\n\n\n\n","category":"function"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(\nf::Function,\noutput,\nbox::Box,\ncl::CellList\n;parallel::Bool=true,\nshow_progress::Bool=false\n)\n\nThis function will run over every pair of particles which are closer than  box.cutoff and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the Box structure.  If the distance is smaller than the cutoff, a function f of the  coordinates of the two particles will be computed. \n\nThe function f receives six arguments as input: \n\nf(x,y,i,j,d2,output)\n\nWhich are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the output variable.  It has also to return the same output variable. Thus, f may or not  mutate output, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance d2 is computed  internally for comparison with the  cutoff, and is passed to the f because many times it is used for the  desired computation. \n\nExample\n\nComputing the mean absolute difference in x position between random particles,  remembering the number of pairs of n particles is n(n-1)/2. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.\n\njulia> n = 100_000;\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];\n\njulia> cl = CellList(x,box);\n\njulia> f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\n\njulia> normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\njulia> avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)\n\nThe same but to evaluate some function between pairs of the particles of the vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}","page":"Help entries","title":"CellListMap.merge_cell_lists!","text":"merge_cell_lists!(cl::CellList,aux::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nMerges an auxiliary aux cell list to cl, and returns the modified cl. Used to merge cell lists computed in parallel threads.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.nbatches-Tuple{CellList}","page":"Help entries","title":"CellListMap.nbatches","text":"nbatches(cl)\n\nReturns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list cl.  It returns the cl.nbatches.map_computation value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.\n\nA second argument can be provided, which may be :map or :build, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. \n\nExample\n\njulia> x = rand(3,1000); box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box,nbatches=(2,16));\n\njulia> nbatches(cl)\n16\n\njulia> nbatches(cl,:map)\n16\n\njulia> nbatches(cl,:build)\n2\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.neighbor_cells","text":"neighbor_cells(box::Box{UnitCellType,N}) where {UnitCellType,N}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of all neighboring cells of a cell where the computing cell index is box.lcell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbor_cells_forward","text":"neighbor_cells_forward(box::Box{UnitCellType,N}) where UnitCellType\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(\n    x, y, cutoff; \n    unitcell=nothing, \n    parallel=true, \n    show_progress=false, \n    autoswap=true,\n    nbatches=(0,0)\n)\n\nComputes the list of pairs of particles of x which are closer than r to the particles of y. The autoswap option will swap x and y to try to optimize the cost of the construction of the cell list. \n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> y = [ rand(3) for i in 1:1_000 ];\n\njulia> CellListMap.neighborlist(x,y,0.05)\n5006-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 269, 0.04770884036497686)\n (25, 892, 0.03850515231540869)\n ⋮\n (9952, 749, 0.048875643578313456)\n (9984, 620, 0.04101242499363183)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(x, cutoff; unitcell=nothing, parallel=true, show_progress=false)\n\nComputes the list of pairs of particles in x which are closer to each other than cutoff. If the keyword parameter unitcell is provided (as a vector of sides or a general unit cell matrix, periodic boundary conditions are considered). \n\nExample\n\njulia> using CellListMap\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> neighborlist(x,0.05)\n24848-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 1055, 0.022977369806392412)\n (1, 5086, 0.026650609138167428)\n ⋮\n (9989, 3379, 0.0467653507446483)\n (9989, 5935, 0.02432728985151653)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm-Tuple{Any}","page":"Help entries","title":"CellListMap.norm","text":"norm(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own norm(x) = norm_sqr(x).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.norm_sqr","text":"norm_sqr(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.normalize-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.normalize","text":"normalize(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own normalize(v)\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.particle_cell","text":"particle_cell(x::SVector{N,T}, box::Box) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the coordinates of the computing cell to which a particle belongs, given its coordinates and the cell_size vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes Box.lcell + 1.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particles_per_cell-Tuple{CellList}","page":"Help entries","title":"CellListMap.particles_per_cell","text":"particles_per_cell(cl)\n\nInternal function or structure - interface may change.\n\nReturns the average number of real particles per computing cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.partition!-Tuple{Any, AbstractVector}","page":"Help entries","title":"CellListMap.partition!","text":"partition!(by, x::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that reorders x vector by putting in the first positions the elements with values satisfying by(el). Returns the number of elements that satisfy the condition.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.pathological_coordinates-Tuple{Any}","page":"Help entries","title":"CellListMap.pathological_coordinates","text":"pathological_coordinates(N)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction to generate some coordinates with pathological properties, for testing. Returns x, y, sides and cutoff.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.project_particles!","text":"project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nProjects all particles of the cell cellⱼ into unnitary vector Δc with direction  connecting the centers of cellⱼ and cellᵢ. Modifies projected_particles, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T","page":"Help entries","title":"CellListMap.reduce","text":"reduce(output, output_threaded)\n\nMost common reduction function, which sums the elements of the output.  Here, output_threaded is a vector containing nbatches(cl) copies of the output variable (a scalar or an array). Custom reduction functions  must replace this one if the reduction operation is not a simple sum.  The output_threaded array is, by default, created automatically by copying the given output variable nbatches(cl) times. \n\nExamples\n\nScalar reduction: \n\njulia> output = 0.; output_threaded = [ 1, 2 ];\n\njulia> CellListMap.reduce(output,output_threaded)\n3\n\nArray reduction:\n\njulia> output = [0,0]; output_threaded = [ [1,1], [2,2] ];\n\njulia> CellListMap.reduce(output,output_threaded)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> output\n2-element Vector{Int64}:\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N}, Any, Any}} where N","page":"Help entries","title":"CellListMap.replicate_particle!","text":"replicate_particle!(ip,p::SVector{N},box,cl) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicates the particle as many times as necessary to fill the computing box.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArraysCore.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}","page":"Help entries","title":"CellListMap.replicate_system!","text":"replicate_system!(\n    x::AbstractVector{SVector{N,T}},\n    unit_cell_matrix::AbstractMatrix,\n    ranges::Tuple\n) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicate the system (modifying the original array of coordinates) in all directions defined by the periodic system and by the range of unitary cells  of interest. x can be a (N,M) matrix, and the unit cell matrix can be provided instead of the box.\n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.replicate_system!(x,box,(0:0,-1:1))\n300-element Vector{SVector{2, Float64}}:\n [0.7119987163255118, 0.6788616154460262]\n [0.6188407316804118, 0.8497116428720384]\n [0.21328895963244354, 0.48932085643862977]\n ⋮\n [0.4114499470191678, 1.1034376619603892]\n [0.6094126258851252, 1.2328989485215263]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.reset!","text":"reset!(cl::CellList{N,T},box,n_real_particles) where{N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nResets a cell list, by setting everything to zero, but retaining the allocated particles and projected_particles vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_idxs!-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.set_idxs!","text":"set_idxs!(idxs, n_particles, nbatches)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nSets the indexes of the particles that will be considered for each batch in parallel runs. Modifies the idxs array of ranges, which is usually the aux.idxs array of the the  corresponding AuxThreaded structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}","page":"Help entries","title":"CellListMap.set_number_of_batches!","text":"set_number_of_batches!(cl,nbatches::Tuple{Int,Int}=(0,0);parallel=true)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunctions that set the default number of batches for the construction of the cell lists,  and mapping computations. This is of course heuristic, and may not be the best choice for every problem. See the parameter nbatches of the construction of the cell lists for  tunning this.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Tuple{AbstractVector{<:AbstractVector}, Any, Any}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::AbstractVector{<:AbstractVector},unit_cell_matrix,indices)\n\nTranslates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. \n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))\n100-element Vector{SVector{2, Float64}}:\n [1.847791110439223, 1.5989103939725295]\n [1.3493293666090889, 1.4002971843576644]\n [1.4111736701313218, 1.3471780214994182]\n ⋮\n [1.1548437388991908, 1.7034501001177493]\n [1.4066300885242247, 1.2907398318754952]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nTranslate vector x according to the unit_cell_matrix lattice vectors and the indices provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.unitcelltype-Union{Tuple{Box{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.unitcelltype","text":"unitcelltype(::Box{T}) where T = T\n\nReturns the type of a unitcell from the Box structure.\n\nExample\n\njulia> box = Box([1,1,1], 0.1)\n\njulia> unitcelltype(box)\nOrthorhombicCell\n\njulia> box = Box([1 0 0; 0 1 0; 0 0 1], 0.1)\n\njulia> unitcelltype(box)\nTriclinicCell\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.update!-Union{Tuple{C}, Tuple{UnitCellType}, Tuple{InPlaceNeighborList{<:Box{UnitCellType}, C}, AbstractVecOrMat}} where {UnitCellType, C<:CellList}","page":"Help entries","title":"CellListMap.update!","text":"update!(system::InPlaceNeighborList, x::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)\nupdate!(system::InPlaceNeighborList, x::AbstractVecOrMat, y::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)\n\nUpdates a InPlaceNeighborList system, by updating the coordinates, cutoff, and unitcell.\n\nExamples\n\nFor self-pairs computations\n\njulia> x = rand(SVector{3,Float64}, 10^3);\n\njulia> system = InPlaceNeighborList(x=x; cutoff=0.1)\nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{NonPeriodicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 0\n\njulia> neighborlist!(system);\n\njulia> new_x = rand(SVector{3,Float64}, 10^3);\n\njulia> update!(system, new_x; cutoff = 0.05)\nInPlaceNeighborList with types: \nCellList{3, Float64}\nBox{NonPeriodicCell, 3, Float64, Float64, 9}\nCurrent list buffer size: 1826\n\njulia> neighborlist!(system)\n224-element Vector{Tuple{Int64, Int64, Float64}}:\n (25, 486, 0.03897345036790646)\n ⋮\n (723, 533, 0.04795768478723409)\n (868, 920, 0.042087156715720137)\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.update_box-Union{Tuple{Box{UnitCellType, N, T, TSQ, M}}, Tuple{M}, Tuple{TSQ}, Tuple{T}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N, T, TSQ, M}","page":"Help entries","title":"CellListMap.update_box","text":"update_box(\n    box::Box{UnitCellType,N,T,TSQ,M};\n    unitcell::Union{Nothing,AbstractVector{T},AbstractMatrix{T},Limits,Tuple}=nothing,\n    cutoff::Union{Nothing,T}=nothing,\n    lcell::Union{Nothing,Int}=nothing\n)\n\nInternal function or structure - interface may change.\n\nFunction that returns an updated system box in a type-stable manner, given possible  variations in the unitcell, cutoff, or lcell parameters. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.view_celllist_particles","text":"view_celllist_particles(cl::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAuxiliary function to view the particles of a computing box, including images created for computing purposes.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_cell_fraction-Tuple{AbstractVector, AbstractMatrix}","page":"Help entries","title":"CellListMap.wrap_cell_fraction","text":"wrap_cell_fraction(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nObtaint the coordinates of x as a fraction of unit cell vectors, first positive cell. x is a vector of dimension N and cell a matrix of  dimension NxN\n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_cell_fraction(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 0.5\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, for an Orthorhombic cell of which only the side lengths are provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SMatrix{N, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. \n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_to_first(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 5.0\n 3.0000000000000004\n\n\n\n\n\n","category":"method"},{"location":"python/#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"Callling CellListMap from python can be useful if lists of neighbors or other properties have to be computed many times, making the overhead of initializing Julia negligible. As the example and benchmark below demonstrates, the current implementation of cell lists in this package is faster than common alternatives available in the python ecosystem. ","category":"page"},{"location":"python/#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"First, install juliacall using the pip package manager, with","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% pip install juliacall","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Using ipython3 (only Python geq 3 is supported), do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: from juliacall import Main as jl","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which, on the first use only, will install the latest stable version of Julia. ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Then, install CellListMap, with:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [2]: jl.Pkg.add(\"CellListMap\")","category":"page"},{"location":"python/#A-Python-module","page":"From Python","title":"A Python module","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The CellListMap.py  provides a complete small python module that interfaces the neighborlist function of CellListMap  with python, returning numpy arrays of indices and distances: ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"By saving the file above in a CellListMap.py file, within python we just need to do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: import CellListMap as cl\n\nIn [2]: import numpy as np\n\nIn [3]: coords = np.random.random((50_000,3))\n\nIn [4]: i_inds, j_inds, d = cl.neighborlist(coords, 0.05)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The output i_inds, j_inds and d variables are numpy arrays with the indexes of the particles and their distances.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"For periodic systems, the unitcell must be provided, as uni-dimensional np.array (for orthorhombic systems) or a np.matrix (for general periodic boundary conditions). For example: ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [5]: i_inds, j_inds, d = cl.neighborlist(coords, 0.05, unitcell=np.array([1, 1, 1]))\n\nIn [6]: i_inds, j_inds, d = cl.neighborlist(coords, 0.05, unitcell=np.matrix('1 0 0; 0 1 0; 0 0 1'))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The neighborlist_cross function provided above has a similar syntax, but to compute the neighboring particles of two independent sets:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [7]: x = np.random.random((50_000,3))\n\nIn [8]: y = np.random.random((50_000,3))\n\nIn [9]: i_inds, j_inds, d = cl.neighborlist_cross(x, y, 0.05, unitcell=np.array([1, 1, 1]))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"To run the code multi-threaded, set the JULIA_NUM_THREADS environment variable before launching python.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"note: Note\nThe details of the above module are explained below, for a more in depth understanding of the interface between Julia and Python through the PythonCall.jl library.","category":"page"},{"location":"python/#Calling-neighborlist","page":"From Python","title":"Calling neighborlist","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The typical input coordinates, in python, are a numpy array with shape (N,dim) where N is the number of particles and dim is the dimension of the space (2 or 3 for CellListMap). Here, we generate a set of 50,000 particles in three dimensions:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: import numpy as np\n\nIn [2]: coords = np.random.random((50_000,3))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Julia is column-major, and python is row-major, thus if we want to use the functions from CellListMap we need to transpose the coordinates:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [3]: coords_t = coords.transpose()","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"These transposed coordinates can be used in the CellListMap.neighborlist function. For example:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [4]: jl.seval(\"using CellListMap\")\n\nIn [6]: neighbor_list = jl.neighborlist(coords_t,0.05)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which will return a list of tuples, containing all pairs of coordinates withing the cutoff (remember that the first call to a Julia function will always take longer than subsequent calls, because the function is JIT compiled):","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [12]: neighbor_list.shape\nOut[12]: (618774,)\n\nIn [13]: neighbor_list[1]\nOut[13]: (1, 37197, 0.047189685889846615)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Note that the third element of the tuple is the distance between the points.","category":"page"},{"location":"python/#Converting-the-list-to-numpy-arrays","page":"From Python","title":"Converting the list to numpy arrays","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The output of CellListMap.neighborlist is a Julia Vector{Tuple{Int,Int,Float64}} array (or Float32, if the coordinates and cutoff were given in 32-bit precision). This Julia list can be accessed from within python normally:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [36]: neighbor_list = jl.neighborlist(x_t, 0.05);\n\nIn [37]: neighbor_list[0:2]\nOut[37]: \n2-element view(::Vector{Tuple{Int64, Int64, Float64}}, 1:1:2) with eltype Tuple{Int64, Int64, Float64}:\n (1, 6717, 0.020052121336342873)\n (1, 7208, 0.03880915662838867)\n\nIn [38]: neighbor_list[0][0]\nOut[38]: 1\n\nIn [40]: neighbor_list[0][2]\nOut[40]: 0.020052121336342873","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Yet, this list may not be interoperable with many other python packages, particularly with numpy standard  operations. Thus, it may be interesting to convert the list to numpy  arrays. This can be done with a simple helper function, which uses a Julia function to copy the list values to the numpy arrays:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"jl.seval(\"\"\"\nfunction copy_to_numpy_arrays(nb_list, i_inds, j_inds, d)\n    for i in eachindex(nb_list)\n        i_inds[i], j_inds[i], d[i] = nb_list[i]\n    end\n    return nothing\nend\n\"\"\")\ndef neighborlist(x, cutoff) :\n    x_t = x.transpose()\n    nb_list = jl.neighborlist(x_t, cutoff)\n    i_inds = np.full((len(nb_list),), 0, dtype=np.int64)\n    j_inds = np.full((len(nb_list),), 0, dtype=np.int64)\n    d = np.full((len(nb_list),), 0.0, dtype=np.float64)\n    jl.copy_to_numpy_arrays(nb_list, i_inds, j_inds, d)\n    return i_inds, j_inds, d","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Now, the output of the python neighborlist contains the numpy arrays for the indexes of the two particles involved in each pair, and their distances:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [61]: neighborlist(coords,0.05)\nOut[61]: \n(array([    1,     1,     1, ..., 49802, 49802, 49885]),\n array([ 6717,  7208,  9303, ..., 11542, 27777, 43853]),\n array([0.02005212, 0.03880916, 0.04543936, ..., 0.04671987, 0.02671908,\n        0.02772025]))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The overhead of these conversions, array creation and copies is not very large, and the benchmarks below are still valid considering this auxiliary python function.","category":"page"},{"location":"python/#Benchmarking-vs.-Scipy","page":"From Python","title":"Benchmarking vs. Scipy","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"To properly benchmark the neighborlist function from CellListMap, let us first define a simple wrapper that will include the transposition of the coordinates in the time:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [14]: def neighborlist_simple(x,cutoff):\n    ...:     y = x.transpose()\n    ...:     nn = jl.CellListMap.neighborlist(y,cutoff)\n    ...:     return nn\n    ...:\n\nIn [15]: %timeit neighborlist(coords,0.05)\n61.7 ms ± 707 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Let us compare this with the performance of a inrange neighborlist algorithm from scipy:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [29]: from scipy.spatial import cKDTree\n\nIn [30]: def neighborlist_scipy(x,cutoff) : \n    ...:     kd_tree = cKDTree(x)  \n    ...:     pairs = kd_tree.query_pairs(r=0.05)  \n    ...:     return pairs \n    ...:\n\nIn [31]: %timeit neighborlist_scipy(coords,0.05)\n312 ms ± 2.85 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Just to confirm, this is the number of pairs that is being output in this test","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [32]: len(neighborlist_scipy(x,cutoff)) # using Scipy\nOut[32]: 618475\n\nIn [20]: len(neighborlist(coords,0.05)) # using CellListMap\nOut[20]: 618475","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"If we use the neighborlist function from Converting the list to numpy arrays, the result is similar, thus copying the output to numpy arrays does not create a large overhead:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [30]: %timeit neighborlist(coords, 0.05)\n67.4 ms ± 4.04 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/#Overhead","page":"From Python","title":"Overhead","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The overhead of calling the function through juliacall  is small. From within Julia, the timings of a similar execution would be:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"julia> using BenchmarkTools\n\njulia> using CellListMap\n\njulia> x = rand(3,50_000);\n\njulia> @btime CellListMap.neighborlist($x,0.05,parallel=false);\n  51.299 ms (17687 allocations: 37.43 MiB)","category":"page"},{"location":"python/#Multi-threading","page":"From Python","title":"Multi-threading","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"These examples were run single-threaded. To run multi-threaded, an environment variable for Julia needs to be set. For example, in bash, do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% export JULIA_NUM_THREADS=12","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"warning: Warning\nThere is a conflict between garbage collectors that may cause segmentation faults in multi-threaded runs  (see this issue). The workaround appears to be to  disable the Julia garbage collector during the execution of multi-threaded code. Here we provide the necessary syntax as an auxiliary Python function.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Consider the following python file, let us call it neighborlist.py, that provides the neighborlist python function with the conversion of the output to numpy arrays:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"from juliacall import Main as jl\njl.seval(\"using CellListMap\")\nimport numpy as np\njl.seval(\"\"\"\nfunction copy_to_numpy_arrays(nb_list, i_inds, j_inds, d)\n    for i in eachindex(nb_list)\n        i_inds[i], j_inds[i], d[i] = nb_list[i]\n    end\n    return nothing\nend\n\"\"\")\ndef neighborlist(x, cutoff) :\n    x_t = x.transpose()\n    jl.GC.enable(False)\n    nb_list = jl.neighborlist(x_t, cutoff)\n    jl.GC.enable(True)\n    i_inds = np.full((len(nb_list),), 0, dtype=np.int64)\n    j_inds = np.full((len(nb_list),), 0, dtype=np.int64)\n    d = np.full((len(nb_list),), 0.0, dtype=np.float64)\n    jl.copy_to_numpy_arrays(nb_list, i_inds, j_inds, d)\n    return i_inds, j_inds, d","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Then, in Python, do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: import neighborlist as nb\n\nIn [2]: import numpy as np\n\nIn [3]: coords = np.random.random((50_000,3))\n\nIn [4]: i_inds, j_inds, d = nb.neighborlist(coords, 0.05)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In a notebook with 6 cores (12 threads) this led to the following performance:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [5]: %timeit i_inds, j_inds, d = nb.neighborlist(coords, 0.05)\n23.7 ms ± 910 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Which, is about 3x faster than the serial execution:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [4]: %timeit i_inds, j_inds, d = nb.neighborlist(coords, 0.05)\n59.2 ms ± 959 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"and thus about 10x faster than scipy.spatial:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [7]: %timeit neighborlist_scipy(coords,0.05)\n204 ms ± 2.86 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"python/#General-mappings","page":"From Python","title":"General mappings","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"A greater flexibility on the use of CellListMap from python can be obtained by defining custom Julia functions. This feature must be used with the low level interface of CellListMap, and is somewhat limited in scope.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [36]: jl.seval(\"using CellListMap\")\n\nIn [37]: x = np.random.random((50_000,3));\n\nIn [38]: x_t = x.transpose()\n\nIn [39]: box = jl.Box(np.array([1,1,1]), 0.05)\n\nIn [40]: box\nOut[41]: \nBox{OrthorhombicCell, 3}\n  unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]\n  cutoff = 0.05\n  number of computing cells on each dimension = [22, 22, 22]\n  computing cell sizes = [0.05, 0.05, 0.05] (lcell: 1)\n  Total number of cells = 10648\n\nIn [41]: cl = jl.CellList(x_t,box)\n\nIn [42]: cl\nOut[42]: \nCellList{3, Float64}\n  50000 real particles.\n  7985 cells with real particles.\n  66594 particles in computing box, including images.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The function to be mapped, however, has to be defined in Julia, using seval. For example, here we define a function that computes the histogram of the distances within the cutoff. ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [43]: jl.seval(\"\"\"  \n    ...: function histogram(x,y,i,j,d2,hist) \n    ...:     cutoff = 0.05 \n    ...:     dc = sqrt(d2)/cutoff # in [0,1] \n    ...:     ibin = floor(Int,dc*10) + 1 # in [0,10] \n    ...:     hist[ibin] += 1 \n    ...:     return hist \n    ...: end \n    ...: \"\"\")\nOut[44]: histogram (generic function with 1 method)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"We can initialize the output variable (the histogram) using a regular numpy array: ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [45]: hist = np.zeros(10)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"and call the map_pairwise function to obtain the histogram of the distances within the cutoff:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [46]: jl.map_pairwise(jl.histogram, hist, box, cl)\nOut[46]: \n10-element PythonCall.PyArray{Float64, 1, true, true, Float64}:\n 153344.0\n      1.151744e6\n      3.066624e6\n      5.787392e6\n      9.220608e6\n      1.3175552e7\n      1.7414912e7\n      2.1817088e7\n      2.6189312e7\n      3.0583808e7","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"With this interface, however, it is not possible to pass additional parameters to the mapped function, and thus the additional parameters have to defined inside the called function (as the cutoff in the current example). This is not ideal, for example, for computing accelerations, which depend on the masses of the particles. In this case, currently, either just use Julia from start and closures, or use the neighborlist  function to obtain the list of neighbors to then compute whatever property is desired from the list of pairs, although this is suboptimal in terms of performance.  ","category":"page"},{"location":"LowLevel/#Low-level-interface","page":"Low level interface","title":"Low level interface","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Since version 0.7.22 we strongly encourage the use of the PeriodicSystems interface. Yet,  the low level interface is still available. To use it, load the package as usual:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"using CellListMap","category":"page"},{"location":"LowLevel/#Examples","page":"Low level interface","title":"Examples","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full code of the examples described here is available at the examples directory. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Mean difference of coordinates\nHistogram of distances\nGravitational potential\nGravitational force\nNearest neighbor\nImplementing Neighbor lists","category":"page"},{"location":"LowLevel/#Mean-difference-of-coordinates","page":"Low level interface","title":"Mean difference of coordinates","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Computing the mean difference in x position between random particles. The closure is used to remove the indexes and the distance of the particles from the parameters of the input function, as they are not needed in this case.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"using CellListMap\n\n# System properties\nN = 100_000\nsides = [250,250,250]\ncutoff = 10\n\n# Particle positions\nx = [ sides .* rand(3) for i in 1:N ]\n\n# Initialize linked lists and box structures\nbox = Box(sides,cutoff)\ncl = CellList(x,box)\n\n# Function to be evaluated from positions \nf(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\nnormalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\n# Run calculation (0.0 is the initial value)\navg_dx = normalization * map_pairwise(\n    (x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl \n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.average_displacement() and is available in the average_displacement.jl file.","category":"page"},{"location":"LowLevel/#Histogram-of-distances","page":"Low level interface","title":"Histogram of distances","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Computing the histogram of the distances between particles (considering the same particles as in the above example). Again, we use a closure to remove the positions and indexes of the particles from the function arguments, because they are not needed. The distance, on the other side, is needed in this example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Function that accumulates the histogram of distances\nfunction build_histogram!(d2,hist)\n    d = sqrt(d2)\n    ibin = floor(Int,d) + 1\n    hist[ibin] += 1\n    return hist\nend;\n\n# Initialize (and preallocate) the histogram\nhist = zeros(Int,10);\n\n# Run calculation\nmap_pairwise!(\n    (x,y,i,j,d2,hist) -> build_histogram!(d2,hist),\n    hist,box,cl\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Note that, since hist is mutable, there is no need to assign the output of map_pairwise! to it. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.distance_histogram() and is available in the distance_histogram.jl file.","category":"page"},{"location":"LowLevel/#Gravitational-potential","page":"Low level interface","title":"Gravitational potential","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In this test we compute the \"gravitational potential\", assigning to each particle a different mass. In this case, the closure is used to pass the masses to the function that computes the potential.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair \nfunction potential(i,j,d2,mass,u)\n    d = sqrt(d2)\n    u = u - 9.8*mass[i]*mass[j]/d\n    return u\nend\n\n# Run pairwise computation\nu = map_pairwise((x,y,i,j,d2,u) -> potential(i,j,d2,mass,u),0.0,box,cl)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.gravitational_potential() and is available in the gravitational_potential.jl file.","category":"page"},{"location":"LowLevel/#Gravitational-force","page":"Low level interface","title":"Gravitational force","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In the following example, we update a force vector of for all particles.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair: update force vector\nfunction calc_forces!(x,y,i,j,d2,mass,forces)\n    G = 9.8*mass[i]*mass[j]/d2\n    d = sqrt(d2)\n    df = (G/d)*(x - y)\n    forces[i] = forces[i] - df\n    forces[j] = forces[j] + df\n    return forces\nend\n\n# Initialize and preallocate forces\nforces = [ zeros(SVector{3,Float64}) for i in 1:N ]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,forces) -> calc_forces!(x,y,i,j,d2,mass,forces),\n    forces,box,cl\n)\n","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.gravitational_force() and is available in the gravitational_force.jl file.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"note: Note\nThe parallelization works by splitting the forces vector in as many tasks as necessary, and each task will update an independent forces array, which will be reduced at the end. Therefore, there is no need to deal with atomic operations or blocks in the calc_forces! function above for the update of forces, which is implemented as if the code was running serially. The same applies to other examples in this section.","category":"page"},{"location":"LowLevel/#Nearest-neighbor","page":"Low level interface","title":"Nearest neighbor","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Here we compute the indexes of the particles that satisfy the minimum distance between two sets of points, using the linked lists. The distance and the indexes are stored in a tuple, and a reducing method has to be defined for that tuple to run the calculation.  The function does not need the coordinates of the points, only their distance and indexes.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Number of particles, sides and cutoff\nN1=1_500\nN2=1_500_000\nsides = [250,250,250]\ncutoff = 10.\nbox = Box(sides,cutoff)\n\n# Particle positions\nx = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N1 ]\ny = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N2 ]\n\n# Initialize auxiliary linked lists\ncl = CellList(x,y,box)\n\n# Function that keeps the minimum distance\nf(i,j,d2,mind) = d2 < mind[3] ? (i,j,d2) : mind\n\n# We have to define our own reduce function here\nfunction reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend\n\n# Initial value\nmind = ( 0, 0, +Inf )\n\n# Run pairwise computation\nmind = map_pairwise( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind),\n    mind,box,cl;reduce=reduce_mind\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.nearest_neighbor() and is available in the nearest_neighbor.jl file.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example CellListMap.Examples.nearest_neighbor_nopbc() of nearest_neighbor_nopbc.jl describes a similar problem but without periodic boundary conditions. Depending on the distribution of points and size it is a faster method than usual ball-tree methods. ","category":"page"},{"location":"LowLevel/#Implementing-Neighbor-lists","page":"Low level interface","title":"Implementing Neighbor lists","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The implementation of the CellLIstMap.neighborlist (see Neighbor lists) is as follows: The empty pairs output array will be split in one vector for each thread, and reduced with a custom reduction function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Function to be evaluated for each pair: push pair\nfunction push_pair!(i,j,d2,pairs)\n    d = sqrt(d2)\n    push!(pairs,(i,j,d))\n    return pairs\nend\n\n# Reduction function\nfunction reduce_pairs(pairs,pairs_threaded)\n    for i in eachindex(pairs_threaded)\n        append!(pairs,pairs_threaded[i])\n    end\n    return pairs\nend\n\n# Initialize output\npairs = Tuple{Int,Int,Float64}[]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,pairs) -> push_pair!(i,j,d2,pairs),\n    pairs,box,cl,\n    reduce=reduce_pairs\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full example can be run with CellListMap.Examples.neighborlist(), available in the file  neighborlist.jl.","category":"page"},{"location":"LowLevel/#Periodic-boundary-conditions","page":"Low level interface","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Orthorhombic periodic boundary conditions\nTriclinic periodic boundary conditions\nWithout periodic boundary conditions","category":"page"},{"location":"LowLevel/#Orthorhombic-periodic-boundary-conditions","page":"Low level interface","title":"Orthorhombic periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Orthorhombic periodic boundary conditions allow some special methods that are faster than those for general cells. To initialize an Orthorhombic cell, just provide the length of the cell on each side, and the cutoff. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([100,70,130],12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 0.0 0.0; 0.0 70.0 0.0; 0.0 0.0 130.0]\n  cutoff: 12.0\n  number of computing cells on each dimension: [10, 7, 12]\n  computing cell sizes: [12.5, 14.0, 13.0] (lcell: 1)\n  Total number of cells: 840","category":"page"},{"location":"LowLevel/#Triclinic-periodic-boundary-conditions","page":"Low level interface","title":"Triclinic periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Triclinic periodic boundary conditions of any kind can be used. However, the input has some limitations for the moment. The lattice vectors must have strictly positive coordinates, and the smallest distance within the cell cannot be smaller than twice the size of the cutoff. An error will be produced if the cell does not satisfy these conditions. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Let us illustrate building a two-dimensional cell, for easier visualization. A matrix of column-wise lattice vectors is provided in the construction of the box, and that is all. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Here, the lattice vectors are [1,0] and [0.5,1] (and we illustrate with cutoff=0.1): ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([ 1.0  0.5\n                     0  1.0 ], 0.1);\n\njulia> x = 10*rand(SVector{2,Float64},1000);","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"We have created random coordinates for 1000 particles, that are not necessarily wrapped according to the periodic boundary conditions. We can see the coordinates in the minimum image cell with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> using Plots\n\njulia> CellListMap.draw_computing_cell(x,box)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/lattice.png>","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell list is, as always, done with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box)\nCellList{2, Float64}\n  109 cells with real particles.\n  2041 particles in computing box, including images.\n","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Upon construction of the cell lists, the particles are replicated to fill a rectangular box (or orthorhombic box, in three-dimensions), with boundaries that exceed the actual system size. This improves the performance of the pairwise computations by avoiding the necessity of wrapping coordinates on the main loop (this is an implementation detail only). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In summary, to use arbitrary periodic boundary conditions, just initialize the box with the matrix of lattice vectors. In three dimensions, for example, one could use:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([ 50.  0. 00. \n                    0. 30. 30.          \n                    0. 00. 50. ],  2.)\n\njulia> x = 100*rand(SVector{3,Float64},10000);\n\njulia> p = [ CellListMap.wrap_to_first(x,box) for x in x ];\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),aspect_ratio=1,framestyle=:box,label=:none)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"to work with an arbitrary 3D lattice, Which in this case looks like:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/3Dlattice.png>","category":"page"},{"location":"LowLevel/#Without-periodic-boundary-conditions","page":"Low level interface","title":"Without periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To avoid the use of periodic boundary conditions it is enough to define an Orthorhombic box with lengths in each direction that are larger than the limits of the coordinates of the particles plus the cutoff. This can be done automatically with the limits function. The box must be constructed with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),12)\nBox{NonPeriodicCell, 3}\n  unit cell matrix = [ 112.0, 0.0, 0.0; 0.0, 112.0, 0.0; 0.0, 0.0, 112.0 ]\n  cutoff = 12.0\n  number of computing cells on each dimension = [11, 11, 11]\n  computing cell sizes = [12.44, 12.44, 12.44] (lcell: 1)\n  Total number of cells = 1331","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"or, for computing the interaction between two disjoint sets of particles, call the limits function with two arguments:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> y = [ [120,180,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),12)\nBox{NonPeriodicCell, 3}\n  unit cell matrix = [ 132.0, 0.0, 0.0; 0.0, 192.0, 0.0; 0.0, 0.0, 112.0 ]\n  cutoff = 12.0\n  number of computing cells on each dimension = [12, 17, 11]\n  computing cell sizes = [13.2, 12.8, 12.44] (lcell: 1)\n  Total number of cells = 2244","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Note that the unit cell length is, on each direction, the maximum coordinates of all particles plus the cutoff. This will avoid the computation of pairs of periodic images. The algorithms used for computing interactions in Orthorhombic cells will then be used.","category":"page"},{"location":"LowLevel/#Parallelization-splitting-and-reduction","page":"Low level interface","title":"Parallelization splitting and reduction","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"How output is updated thread-safely\nCustom reduction functions\nNumber of batches","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The parallel execution requires the splitting of the computation among tasks. ","category":"page"},{"location":"LowLevel/#How-output-is-updated-thread-safely","page":"Low level interface","title":"How output is updated thread-safely","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To allow general output types, the approach of CellListMap is to copy the output variable the number of times necessary for each parallel task to update an independent output variables, which are reduced at the end. This, of course, requires some additional memory, particularly if the output being updated is formed by arrays. These copies can be preallocated, and custom reduction functions can be defined. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To control these steps, set manually the output_threaded and reduce optional input parameters of the map_pairwise! function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By default, we define:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"output_threaded = [ deepcopy(output) for i in 1:nbatches(cl) ]","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"where nbatches(cl) is the number of batches into which the computation will be divided. The number of batches is not necessarily equal to the number of threads available (an heuristic is used to optimize performance, as a function of the workload per batch), but can be manually set, as described in the Number of batches section below. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The default reduction function just assumes the additivity of the results obtained by each batch:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"reduce(output::Number,output_threaded) = sum(output_threaded)\nfunction reduce(output::Vector,output_threaded) \n    @. output = output_threaded[1]\n    for i in 2:length(output_threaded)\n         @. output += output_threaded[i] \n    end\n    return output\nend","category":"page"},{"location":"LowLevel/#Custom-reduction-functions","page":"Low level interface","title":"Custom reduction functions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In some cases, as in the Nearest neighbor example, the output is a tuple and reduction consists in keeping the output from each thread having the minimum value for the distance. Thus, the reduction operation is not a simple sum over the elements of each threaded output. We can, therefore, overwrite the default reduction method, by passing the reduction function as the reduce parameter of map_pairwise!:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"mind = map_pairwise!( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind), mind,box,cl;\n    reduce=reduce_mind\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"where here the reduce function is set to be the custom function that keeps the tuple associated to the minimum distance obtained between threads:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"function reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"This function must return the updated output variable, being it mutable or not, to be compatible with the interface.  ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Using the length of the output_threaded vector as the measure of how many copies of the array is available is convenient because it will be insensitive in changes in the number of batches that may be set.","category":"page"},{"location":"LowLevel/#Number-of-batches","page":"Low level interface","title":"Number of batches","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Every calculation with cell lists has two steps: the construction of the lists, and the mapping of the computation among the pairs of particles that satisfy the cutoff criterion. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell list is harder to parallelize, because assigning each particle to a cell is fast, such that the cost of merging a set of lists generated in parallel can be as costly as building the lists themselves. Therefore, it is frequent that it is not worthwhile (actually it is detrimental for performance) to split the construction of the cell lists in too many threads. This is particularly relevant for smaller systems, for which the cost of constructing the lists can be comparable to the cost of actually computing the mapped function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"At the same time, the homogeneity of the computation of the mapped function may be fast or not, homogeneous or not. These characteristics affect the optimal workload splitting strategy. For very large systems, or systems for which the function to be computed is not homogeneous in time, it may be interesting to split the workload in many tasks as possible, such that slow tasks do not dominate the final computational time.   ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Both the above considerations can be used to tunning the nbatches parameter of the cell list. This parameter is initialized from a tuple of integers, defining the number of batches that will be used for constructing the cell lists and for the mapping of the computations. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By default, the number of batches for the computation of the cell lists is smaller than nthreads() if the number of particles per cell is small. The default value by the internal function CellListMap._nbatches_build_cell_lists(cl::CellList). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The values assumed for each number of batches can bee seen by printing the nbatches parameter of the cell lists:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> Threads.nthreads()\n64\n\njulia> x, box = CellListMap.xatomic(10^4) # random set with atomic density of water\n\njulia> cl = CellList(x,box);\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 8 \n  Number of batches for function mapping: 32 ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell lists is performed by creating copies of the data, and currently does not scale very well. Thus, no more than 8 batches are used by default, to avoid delays associated to data copying and gargabe collection. The number of batches of the mapping function uses an heuristic which currently limits somewhat the number of batches for small systems, when the overhead of spawning tasks is greater than the computation.  Using more batches than threads for the function mapping is effective most times in avoiding uneven workload, but it may be a problem if the output to be reduced is too large, as the threaded version of the output contains nbatches copies of the output. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Using less batches than the number of threads also allows the efficient use of nested multi-threading, as the computations will only use the number of threads required, leaving the other threads available for other tasks.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The number of batches is set on the construction of the cell list, using the nbatches keyword parameter. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(1,4))\nCellList{3, Float64}\n  1000000 real particles.\n  1000 cells with real particles.\n  1727449 particles in computing box, including images.\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 1\n  Number of batches for function mapping: 4","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"fine tunning of the performance for a specific problem can be obtained by adjusting this parameter. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"If the number of batches is set as zero for any of the two options, the default value is retained. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(0,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 8 \n  Number of batches for function mapping: 4\n\njulia> cl = CellList(x,box,nbatches=(4,0));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 4\n  Number of batches for function mapping: 64","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The number of batches can also be retrieved from the cell list using the nbatches function:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(2,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 2\n  Number of batches for function mapping: 4\n\njulia> nbatches(cl) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:map) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:build) # returns cl.nbatches.build_cell_lists\n2","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The call nbatches(cl) is important for defining the number of copies of preallocated threaded output variables, as explained in the previous section.","category":"page"},{"location":"LowLevel/#Performance-tunning-and-additional-options","page":"Low level interface","title":"Performance tunning and additional options","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Preallocating the cell lists and cell list auxiliary arrays\nPreallocating threaded output auxiliary arrays\nOptimizing the cell grid","category":"page"},{"location":"LowLevel/#Preallocating-the-cell-lists-and-cell-list-auxiliary-arrays","page":"Low level interface","title":"Preallocating the cell lists and cell list auxiliary arrays","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The arrays containing the cell lists can be initialized only once, and then updated. This is useful for iterative runs. Note that, since the list size depends on the box size and cutoff, if the box properties changes some arrays might be increased (never shrink) on this update. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Initialize cell lists with initial coordinates\ncl = CellList(x,box)\n# Allocate auxiliary arrays for threaded cell list construction\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,box,cl,aux) \n    map_pairwise!(...)\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The procedure is identical if using two sets of coordinates, in which case, one would do:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"cl = CellList(x,y,box)\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,y,box,cl,aux)\n    map_pairwise(...)\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By passing the aux auxiliary structure, the UpdateCellList! functions will only allocate some minor variables associated to the launching of multiple threads and, possibly, to the expansion of the cell lists if the box or the number of particles became greater. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"warning: Warning\nIf the number of batches of threading is changed, the structure of auxiliary arrays must be reinitialized. Otherwise, incorrect results can be obtained.","category":"page"},{"location":"LowLevel/#Preallocating-threaded-output-auxiliary-arrays","page":"Low level interface","title":"Preallocating threaded output auxiliary arrays","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"On parallel runs, note that output_threaded is, by default, initialized on the call to map_pairwise!. Thus, if the calculation must be run multiple times (for example, for several steps of a trajectory), it is probably a good idea to preallocate the threaded output, particularly if it is a large array. For example, the arrays of forces should be created only once, and reset to zero after each use:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"forces = zeros(SVector{3,Float64},N)\nforces_threaded = [ deepcopy(forces) for i in 1:nbatches(cl) ]\nfor i in 1:nsteps\n    map_pairwise!(f, forces, box, cl, output_threaded=forces_threaded)\n    # work with the final forces vector\n    ...\n    # Reset forces_threaded\n    for i in 1:nbatches(cl)\n        @. forces_threaded[i] = zero(SVector{3,Float64}) \n    end\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In this case, the forces vector will be updated by the default reduction method. nbatches(cl) is the number of batches of the parallel calculation, which is defined on the construction of the cell list (see the Parallelization section).","category":"page"},{"location":"LowLevel/#Optimizing-the-cell-grid","page":"Low level interface","title":"Optimizing the cell grid","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The partition of the space into cells is dependent on a parameter lcell which can be passed to Box. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"box = Box(x,box,lcell=2)\ncl = CellList(x,box)\nmap_pairwise!(...)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"This parameter determines how fine is the mesh of cells. There is a trade-off between the number of cells and the number of particles per cell. For low-density systems, greater meshes are better, because each cell will have only a few particles and the computations loop over a smaller number of cells. For dense systems, it is better to run over more cells with less particles per cell. It is a good idea to test different values of lcell to check which is the optimal choice for your system. Usually the best value is lcell=1, because in CellListMap implements a method to avoid spurious computations of distances on top of the cell lists, but for very dense systems, or for very large cutoffs (meaning, for situations in which the number of particles per cell may be very large), a greater lcell may provide a better performance. It is unlikely that lcell > 3 is useful in any practical situation. For molecular systems with normal densities lcell=1 is likely the optimal choice. The performance can be tested using the progress meter, as explained below.  ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"As a rough guide, lcell > 1 is only worthwhile if the number of particles per cell is greater than  ~200-400.  ","category":"page"},{"location":"LowLevel/#Output-progress","page":"Low level interface","title":"Output progress","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For long-running computations, the user might want to see the progress. A progress meter can be turned on with the show_progress option. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"map_pairwise!(f,output,box,cl,show_progress=true)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"whill print something like:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Progress:  43%|█████████████████                    | ETA: 0:18:25","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Thus, besides being useful for following the progress of a long run, it is useful to test different values of lcell to tune the performance of the code, by looking at the estimated time to finish (ETA) and killing the execution after a sample run. The default and recommended option for production runs is to use show_progress=false, because tracking the progress introduces a small overhead into the computation. ","category":"page"},{"location":"LowLevel/#Some-benchmarks","page":"Low level interface","title":"Some benchmarks","text":"","category":"section"},{"location":"LowLevel/#Computing-a-histogram-of-pairwise-velocities","page":"Low level interface","title":"Computing a histogram of pairwise velocities","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The goal here is to provide a good implementation of cell lists. We compare it with the implementation of the nice cython/python halotools package, in the computation of an histogram of mean pairwise velocities. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<center>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cd_v0.5.3.png>\n<br>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cv_v0.5.3.png>\n</center>","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full test is available at this repository. And we kindly thank Carolina Cuesta for providing the example. These benchmarks were run on an Intel i7 8th gen laptop, with 4 cores (8 threads). ","category":"page"},{"location":"LowLevel/#Additional-options","page":"Low level interface","title":"Additional options","text":"","category":"section"},{"location":"LowLevel/#Input-coordinates-as-matrices","page":"Low level interface","title":"Input coordinates as matrices","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For compatibility with other software, the input coordinates can be provided as matrices. The matrices must have dimensions (2,N) or (3,N), where N is the number of particles (because Julia is column-major, thus this has the same memory layout of an array of length N of static vectors). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = rand(3,100);\n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100 real particles.\n  99 cells with real particles.\n  162 particles in computing box, including images.\n\njulia> map_pairwise!((x,y,i,j,d2,n) -> n += 1, 0, box, cl) # count neighbors\n23","category":"page"},{"location":"#CellListMap.jl","page":"Overview","title":"CellListMap.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package implements an efficient cell list scheme for the computation of interactions, neighbor lists, or any other property dependent on the distances between pairs of two- or three-dimensional particles, within a cutoff. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It maps a generic function to be computed for each pair of particles, using periodic boundary conditions of any type. Parallel and serial implementations can be used. The user defined function will be evaluated only for the pairs closer to each other than the desired cutoff distance.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This is a Julia package. Install Julia first following the instructions in the download page, or using juliaup.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Once Julia is installed, install the CellListMap package from the Julia REPL with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> import Pkg\n\njulia> Pkg.add(\"CellListMap\")","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"#High-level-interface-for-periodic-system","page":"Overview","title":"High level interface for periodic system","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Since version 0.7.22, a new simpler, higher level interface was introduced, that will facilitate the use of CellListMap without any loss in performance. The new interface is flexible enough for the majority of applications. It may become the default interface in the future. See the PeriodicSystems interface menu for details. ","category":"page"},{"location":"#Cutoff-delimited-neighbor-lists","page":"Overview","title":"Cutoff-delimited neighbor lists","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The user might be more confortable in using the package to compute the list of neighboring particles. A custom interface for this application is provided though the Neighbor lists interface. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Note that, in general, neighbor lists are used to compute other pairwise dependent properties, and these can be, in principle, computed directly with CellListMap without the need to compute or store the lists of neighbors. ","category":"page"},{"location":"#Lower-level-interface","page":"Overview","title":"Lower level interface","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Low level interface allows the customization and optimization of very demanding calculations (although the PeriodicSystems interface does not have any performance limitation and is easier to use).","category":"page"}]
}
