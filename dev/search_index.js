var documenterSearchIndex = {"docs":
[{"location":"parallelization/#Parallelization-splitting-and-reduction","page":"Parallelization","title":"Parallelization splitting and reduction","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The parallel execution requires the splitting of the computation among threads, obviously. Thus, the output variable must be split and then reduced to avoid concurrency. To control these steps, set manually the output_threaded and reduce optional input parameters of the map_pairwise! function. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"By default, we define:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"output_threaded = [ deepcopy(output) for i in 1:nbatches(cl) ]","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"where nbatches(cl) is the number of batches into which the computation will be divided, as defined for the cell list cl (this parameter is by default 4*nthreads(), but it can be tunned for performance, as explained in the Number of batches section below),  and, for scalars and vectors, the reduction is just the sum of the output per thread:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"reduce(output::Number,output_threaded) = sum(output_threaded)\nfunction reduce(output::Vector,output_threaded) \n    @. output = output_threaded[1]\n    for i in 2:length(output_threaded)\n         @. output += output_threaded[i] \n    end\n    return output\nend","category":"page"},{"location":"parallelization/#Custom-reduction-functions","page":"Parallelization","title":"Custom reduction functions","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"In some cases, as in the Nearest neighbor example, the output is a tuple and reduction consists in keeping the output from each thread having the minimum value for the distance. Thus, the reduction operation is not a simple sum over the elements of each threaded output. We can, therefore, overwrite the default reduction method, by passing the reduction function as the reduce parameter of map_pairwise!:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"mind = map_pairwise!( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind), mind,box,cl;\n    reduce=reduce_mind\n)","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"where here the reduce function is set to be the custom function that keeps the tuple associated to the minimum distance obtained between threads:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"function reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"This function must return the updated output variable, being it mutable or not, to be compatible with the interface.  ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Using the length of the output_threaded vector as the measure of how many copies of the array is available is convenient because it will be insensitive in changes in the number of batches that may be set.","category":"page"},{"location":"parallelization/#Preallocating-auxiliary-arrays:-threaded-output-and-cell-lists","page":"Parallelization","title":"Preallocating auxiliary arrays: threaded output and cell lists","text":"","category":"section"},{"location":"parallelization/#Preallocating-the-cell-lists-and-cell-list-auxiliary-arrays","page":"Parallelization","title":"Preallocating the cell lists and cell list auxiliary arrays","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The arrays containing the cell lists can be initialized only once, and then updated. This is useful for iterative runs. Note that, since the list size depends on the box size and cutoff, if the box properties changes some arrays might be increased (never shrink) on this update. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"# Initialize cell lists with initial coordinates\ncl = CellList(x,box)\n# Allocate auxiliary arrays for threaded cell list construction\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,box,cl,aux) \nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The procedure is identical if using two sets of coordinates, in which case, one would do:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"cl = CellList(x,y,box)\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,y,box,cl,aux)\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"By passing the aux auxiliary structure, the UpdateCellList! functions will only allocate some minor variables associated to the launching of multiple threads and, possibly, to the expansion of the cell lists if the box or the number of particles became greater. ","category":"page"},{"location":"parallelization/#Preallocating-threaded-output-auxiliary-arrays","page":"Parallelization","title":"Preallocating threaded output auxiliary arrays","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"On parallel runs, note that output_threaded is, by default, initialized on the call to map_pairwise!. Thus, if the calculation must be run multiple times (for example, for several steps of a trajectory), it is probably a good idea to preallocate the threaded output, particularly if it is a large array. For example, the arrays of forces should be created only once, and reset to zero after each use:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"forces = zeros(SVector{3,Float64},N)\nforces_threaded = [ deepcopy(forces) for i in 1:nbatches(cl) ]\nfor i in 1:nsteps\n    map_pairwise!(f, forces, box, cl, output_threaded=forces_threaded)\n    # work with the final forces vector\n    ...\n    # Reset forces_threaded\n    for i in 1:nbatches(cl)\n        @. forces_threaded[i] = zero(SVector{3,Float64}) \n    end\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"In this case, the forces vector will be updated by the default reduction method. nbatches(cl) is the number of batches of the parallel calculation, which is defined on the construction of the cell list (by default it is 4*nthreads(), see the next section).","category":"page"},{"location":"parallelization/#Number-of-batches","page":"Parallelization","title":"Number of batches","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Every calculation with cell lists has two steps: the construction of the lists, and the mapping of the computation among the pairs of particles that satisfy the cutoff criterion. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The construction of the cell list is harder to parallelize, because assigning each particle to a cell is fast, such that the cost of merging a set of lists generated in parallel can be as costly as building the lists themselves. Therefore, it is frequent that it is not worthwhile (actually it is detrimental for performance) to split the construction of the cell lists in too many threads. This is particularly relevant for smaller systems, for which the cost of constructing the lists can be comparable to the cost of actually computing the mapped function. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"At the same time, the homogeneity of the computation of the mapped function may be fast or not, homogeneous or not. These characteristics affect the optimal workload splitting strategy. For very large systems, or systems for which the function to be computed is not homogeneous in time, it may be interesting to split the workload in many tasks as possible, such that slow tasks do not dominate the final computational time.   ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Both the above considerations can be used to tunning the nbatches parameter of the cell list. This parameter is initialized from a tuple of integers, defining the number of batches that will be used for constructing the cell lists and for the mapping of the computations. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"By default, the number of batches for the computation of the cell lists is smaller than nthreads() if the number of particles per cell is small, and cannot be greater than nthreads(). The default value by the internal function CellListMap._nbatches_build_cell_lists(cl::CellList). The default value for the number of batches of the function mapping is 4*nthreads() for computations involving one set of particles, and length(x÷2500) for computations involving two sets of particles, where x is the set with the greater number of particles (over which the calculation will be split into threads). ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The values assumed for each number of batches can bee seen by printing the nbatches parameter of the cell lists:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> Threads.nthreads()\n8\n\njulia> x = [ rand(3) for _ in 1:10_000 ]; box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box);\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 2\n  Number of batches for function mapping: 32 ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"which means that the construction of the cell lists will use 2 batches (thus using less tan nthreads() tasks), and the mapping of the function will be split into 32 batches. Using more batches than threads for the function mapping is effective most times in avoiding uneven workload, but it may be a problem if the output to be reduced is too large, as the threaded version of the output contains nbatches copies of the output. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The effect of the number of batches in the construction of the cell lists can be seen here (in the above example, with 10_000 particles):","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> @btime CellList($x,$box,nbatches=(1,32));\n  2.195 ms (4156 allocations: 2.12 MiB)\n\njulia> @btime CellList($x,$box,nbatches=(2,32)); # default\n  1.674 ms (10317 allocations: 3.26 MiB)\n\njulia> @btime CellList($x,$box,nbatches=(3,32));\n  1.667 ms (13979 allocations: 4.08 MiB)\n\njulia> @btime CellList($x,$box,nbatches=(4,32));\n  2.083 ms (18460 allocations: 4.95 MiB)\n\njulia> @btime CellList($x,$box,nbatches=(8,32));\n  3.537 ms (39645 allocations: 8.40 MiB)","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"and, as shown, the default splitting is close to optimal, even if using less then the number of threads available. The optimal number of batches is, however, problem dependent, and the default heuristic may not always choose the best value.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"For denser systems the optimal number of batches change. For example, for 1_000_000 particles, we have:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> @btime CellList($x,$box,nbatches=(2,32));\n  146.020 ms (8845 allocations: 193.58 MiB)\n\njulia> @btime CellList($x,$box,nbatches=(8,32)); # default\n  103.395 ms (40746 allocations: 352.56 MiB)","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"the default value is again close to optimal and can be trusted.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The number of batches for the mapping of the pairwise computation generally is optimal if greater than the number of threads.  Most times it doesn't really makes sense to start a number of batches that is not a multiple of the number of threads available. For example, if the number of batches is nthreads()+1, most likely nthreads() batches will finish almost simultaneously and then the remaining batch will start running. Let us see the effect  of the number of batches in one specific example. The computer in which these tests are performed has 4 physical cores, which with multi-threading can span 8 independent threads.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> Threads.nthreads()\n8","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The test will be the computation of pairwise velocities of a set of 100_000 particles. We will keep the first parameter fixed (the number of batches of the cell list construction):","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> @btime CellListMap.Examples.pairwise_velocities(N=100_000,nbatches=(2,32)); # default\n  58.025 ms (88651 allocations: 36.10 MiB)\n\njulia> @btime CellListMap.Examples.pairwise_velocities(N=100_000,nbatches=(2,16)); \n  55.913 ms (88423 allocations: 36.06 MiB)\n\njulia> @btime CellListMap.Examples.pairwise_velocities(N=100_000,nbatches=(2,8)); # = nthreads()\n  56.708 ms (88308 allocations: 36.04 MiB)\n\njulia> @btime CellListMap.Examples.pairwise_velocities(N=100_000,nbatches=(2,4)); # < nthreads()\n  82.678 ms (88249 allocations: 36.03 MiB)","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"As shown above, in this example the optimal number o batches is close to the number of threads available, and increasing it further does not improve performance. It may degrade performance for much larger number of batches, depending on the system size. However, if the computations where heterogeneous and the cost of each batch is much larger than the cost of spawning the threads, splitting into more batches than threads may be worthwhile. Gains in performance for very large systems are expected with this strategy, thus it is the default behavior. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Finally, the number of batches is set on the construction of the cell list, using the nbatches keyword parameter. For example:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> cl = CellList(x,box,nbatches=(1,4))\nCellList{3, Float64}\n  1000000 real particles.\n  1000 cells with real particles.\n  1727449 particles in computing box, including images.\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 1\n  Number of batches for function mapping: 4","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"fine tunning of the performance for a specific problem can be obtained by adjusting this parameter. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"If the number of batches is set as zero for any of the two options, the default value is retained. For example:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> cl = CellList(x,box,nbatches=(0,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 8\n  Number of batches for function mapping: 4\n\njulia> cl = CellList(x,box,nbatches=(4,0));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 4\n  Number of batches for function mapping: 64","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The number of batches can also be retrieved from the cell list using the nbatches function:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia> cl = CellList(x,box,nbatches=(2,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 2\n  Number of batches for function mapping: 4\n\njulia> nbatches(cl) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:map) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:build) # returns cl.nbatches.build_cell_lists\n2","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The call nbatches(cl) is important for defining the number of copies of preallocated threaded output variables, as explained in the previous section.","category":"page"},{"location":"performance/#Performance-tunning-and-additional-options","page":"Performance","title":"Performance tunning and additional options","text":"","category":"section"},{"location":"performance/#Optimizing-the-cell-grid","page":"Performance","title":"Optimizing the cell grid","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"The partition of the space into cells is dependent on a parameter lcell which can be passed to Box. For example:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"box = Box(x,box,lcell=2)\ncl = CellList(x,box)\nmap_pairwise!(...)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"This parameter determines how fine is the mesh of cells. There is a trade-off between the number of cells and the number of particles per cell. For low-density systems, greater meshes are better, because each cell will have only a few particles and the computations loop over a smaller number of cells. For dense systems, it is better to run over more cells with less particles per cell. It is a good idea to test different values of lcell to check which is the optimal choice for your system. Usually the best value is lcell=1, because in CellListMap implements a method to avoid spurious computations of distances on top of the cell lists, but for very dense systems, or for very large cutoffs (meaning, for situations in which the number of particles per cell may be very large), a greater lcell may provide a better performance. It is unlikely that lcell > 3 is useful in any practical situation. For molecular systems with normal densities lcell=1 is likely the optimal choice. The performance can be tested using the progress meter, as explained below.  ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"As a rough guide, lcell > 1 is only worthwhile if the number of particles per cell is greater than  ~200-400.  ","category":"page"},{"location":"performance/#Output-progress","page":"Performance","title":"Output progress","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"For long-running computations, the user might want to see the progress. A progress meter can be turned on with the show_progress option. For example:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"map_pairwise!(f,output,box,cl,show_progress=true)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"whill print something like:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Progress:  43%|█████████████████                    | ETA: 0:18:25","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Thus, besides being useful for following the progress of a long run, it is useful to test different values of lcell to tune the performance of the code, by looking at the estimated time to finish (ETA) and killing the execution after a sample run. The default and recommended option for production runs is to use show_progress=false, because tracking the progress introduces a small overhead into the computation. ","category":"page"},{"location":"performance/#Some-benchmarks","page":"Performance","title":"Some benchmarks","text":"","category":"section"},{"location":"performance/#Computing-a-histogram-of-pairwise-velocities","page":"Performance","title":"Computing a histogram of pairwise velocities","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"The goal here is to provide a good implementation of cell lists. We compare it with the implementation of the nice cython/python halotools package, in the computation of an histogram of mean pairwise velocities. ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"<center>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cd_v0.5.3.png>\n<br>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cv_v0.5.3.png>\n</center>","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The full test is available at this repository. And we kindly thank Carolina Cuesta for providing the example. These benchmarks were run on an Intel i7 8th gen laptop, with 4 cores (8 threads). ","category":"page"},{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"These entries can be viewed at the Julia REPL Julia using ","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? \nhelp?> function_name","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"Modules=[CellListMap]","category":"page"},{"location":"help/#CellListMap.AuxThreaded","page":"Help entries","title":"CellListMap.AuxThreaded","text":"struct AuxThreaded{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nn_per_cycle::Int64\nidxs::Vector{UnitRange{Int64}}\nDefault: Vector{UnitRange{Int}}(undef, 0)\nlists::Array{CellList{N, T}, 1} where {N, T}\nDefault: Vector{CellList{N, T}}(undef, 0)\n\nAuxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellListPair{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type for lists of disjoint particle sets,  to be passed to UpdateCellList! for in-place update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellList{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type, to be passed to UpdateCellList! for in-place  update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for _ in 1:100_000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box","page":"Help entries","title":"CellListMap.Box","text":"struct Box{UnitCellType, N, T, TSQ, M}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nunit_cell::CellListMap.UnitCell\nlcell::Int64\nnc::StaticArrays.SVector{N, Int64} where N\ncutoff::Any\ncutoff_sq::Any\nranges::StaticArrays.SVector{N, UnitRange{Int64}} where N\ncell_size::StaticArrays.SVector\nunit_cell_max::StaticArrays.SVector\n\nStructure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. \n\nExamples\n\njulia> using CellListMap\n\njulia> sides = [250,250,250];\n\njulia> cutoff = 10;\n\njulia> box = Box(sides,cutoff)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [27, 27, 27]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 19683\n\n\njulia> box = Box([ 10  0  0 \n                    0 10  5\n                    0  0 10 ], 1)\nBox{TriclinicCell, 3, Float64, 9}\nunit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]\ncutoff: 1.0\nnumber of computing cells on each dimension: [12, 17, 12]\ncomputing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)\nTotal number of cells: 2448\n\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T","page":"Help entries","title":"CellListMap.Box","text":"Box(\n    limits::Limits,\n    cutoff;\n    lcell::Int=1\n)\n\nThis constructor receives the output of limits(x) or limits(x,y) where x and y are the coordinates of the particles involved, and constructs a Box with size larger than the maximum coordinates ranges of all particles plus the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is always an Orthorhombic cell.\n\nExamples\n\njulia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [109.99633932875878 0.0 0.0; 0.0 109.99780283179763 0.0; 0.0 0.0 109.99587254766517]\n  cutoff: 10.0\n  number of computing cells on each dimension: [12, 12, 12]\n  computing cell sizes: [10.999633932875877, 10.999780283179764, 10.999587254766517] (lcell: 1)\n  Total number of cells: 1728\n\njulia> y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [159.99787690924168 0.0 0.0; 0.0 159.98878289444897 0.0; 0.0 0.0 109.99587254766517]\n  cutoff: 10.0\n  number of computing cells on each dimension: [18, 17, 12]\n  computing cell sizes: [10.666525127282778, 10.665918859629931, 10.999587254766517] (lcell: 1)\n  Total number of cells: 3672\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  unit_cell_matrix::AbstractMatrix, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=TriclinicCell\n)\n\nConstruct box structure given the cell matrix of lattice vectors. This  constructor will always return a TriclinicCell box type, unless the UnitCellType parameter is set manually to OrthorhombicCell\n\nExample\n\njulia> unit_cell = [ 100   50    0 \n                       0  120    0\n                       0    0  130 ];\n\njulia> box = Box(unit_cell,10)\nBox{TriclinicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [17, 14, 15]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 3570\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  sides::AbstractVector, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=OrthorhombicCell\n)\n\nFor orthorhombic unit cells, Box can be initialized with a vector of the  length of each side. \n\nExample\n\njulia> box = Box([120,150,100],10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [14, 17, 12]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 2856\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Cell","page":"Help entries","title":"CellListMap.Cell","text":"struct Cell{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlinear_index::Int64\ncartesian_index::CartesianIndex\ncenter::StaticArrays.SVector\ncontains_real::Bool\nn_particles::Int64\nparticles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}\n\nThis structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighboring cells need to be wrapped) \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList","page":"Help entries","title":"CellListMap.CellList","text":"struct CellList{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nn_real_particles::Int64\nNumber of real particles.\nnumber_of_cells::Int64\nNumber of cells.\nn_particles::Int64\nmutable number of particles in the computing box.\nn_cells_with_real_particles::Int64\nmutable number of cells with real particles.\nn_cells_with_particles::Int64\nmutable number of cells with particles, real or images.\ncell_indices::Vector{Int64}\nAuxiliary array that contains the indexes in list of the cells with particles, real or images.\ncell_indices_real::Vector{Int64}\nAuxiliary array that contains the indexes in the cells with real particles.\ncells::Array{CellListMap.Cell{N, T}, 1} where {N, T}\nVector containing cell lists of cells with particles.\nnbatches::CellListMap.NumberOfBatches\nNumber of batches for the parallel calculations.\nprojected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}\nAuxiliar array to store projected particles.\n\nStructure that contains the cell lists information.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} \n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"function CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} \n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0),\n    autoswap::Bool=true\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellListPair structure from scracth, given two vectors of particle coordinates and a Box, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using autoswap=false the cell list is constructed for the second (y)\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   10000 particles in the reference vector.\n   961 cells with real particles of target vector.\n\njulia> cl = CellList(x,y,box,autoswap=false)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   7389 cells with real particles of target vector.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0)\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellList structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a Box, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100000 real particles.\n  15600 cells with real particles.\n  126276 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellListPair","page":"Help entries","title":"CellListMap.CellListPair","text":"struct CellListPair{V, N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nref::Any\ntarget::CellList\nswap::Bool\n\nStructure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Limits","page":"Help entries","title":"CellListMap.Limits","text":"struct Limits{T<:(AbstractVector)}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlimits::AbstractVector\n\nStructure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.NumberOfBatches","page":"Help entries","title":"CellListMap.NumberOfBatches","text":"struct NumberOfBatches\n\nInternal function or structure - interface may change.\n\nExtended help\n\nbuild_cell_lists::Int64\nmap_computation::Int64\n\nStructure to define the number of batches used in the parallel splitting of the calculations of the cell list construction and of the map_pairwise computation. It is initialized with a standard heuristic that returns at most the number of threads, but may return a smaller number if the system is small. The two parameters can be tunned for optimal performance of each step of the calculation (cell list construction and mapping of interactions). The construction of the cell lists require a larger number of particles for threading to be effective, Thus by default the system size that allows multi-threading is greater for this part of the calculation.  \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ParticleWithIndex","page":"Help entries","title":"CellListMap.ParticleWithIndex","text":"struct ParticleWithIndex{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nreal::Bool\ncoordinates::StaticArrays.SVector\n\nCopies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ProjectedParticle","page":"Help entries","title":"CellListMap.ProjectedParticle","text":"struct ProjectedParticle{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nxproj::Any\ncoordinates::StaticArrays.SVector\n\nAuxiliary structure to contain projected particles. Types of  scalars are chosen such that with a SVector{3,Float64} the complete struct has 32bytes.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair, CellListMap.AuxThreaded}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl_pair::CellListPair,\n    aux::AuxThreaded;\n    parallel::Bool=true\n)\n\nThis function will update the cl_pair structure that contains the cell lists for disjoint sets of particles. It receives the preallocated aux structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7381 cells with real particles of target vector.\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = UpdateCellList!(x,y,box,cl,aux)\nCellList{3, Float64}\n  10000 real particles.\n  7358 cells with real particles.\n  12591 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux)\n  715.661 μs (41 allocations: 3.88 KiB)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7414 cells with real particles of target vector.\n   \njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)\n   13.042 ms (0 allocations: 0 bytes)\n CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n    50000 particles in the reference vector.\n    15031 cells with real particles of target vector.\n \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n  x::AbstractVector{<:AbstractVector},\n  y::AbstractVector{<:AbstractVector},\n  box::Box,\n  cl:CellListPair,\n  parallel=true\n)\n\nFunction that will update a previously allocated CellListPair structure, given  new updated particle positions, for example. This method will allocate new  aux threaded auxiliary arrays. For a non-allocating version, see the  UpdateCellList!(x,y,box,cl,aux) method.\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> cl = UpdateCellList!(x,y,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, Box, CellList}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl:CellList,\n    parallel=true\n) \n\nFunction that will update a previously allocated CellList structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the UpdateCellList!(x,box,cl,aux) method instead. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> box = Box([260,260,260],10);\n\njulia> x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = UpdateCellList!(x,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T},\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{<:AbstractVector}, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl::CellList{N,T},\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nFunction that updates the cell list cl new coordinates x and possibly a new box box, and receives a preallocated aux structure of auxiliary vectors for threaded cell list construction. Given a preallocated aux vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux)\n  16.384 ms (41 allocations: 3.88 KiB)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)\n  20.882 ms (0 allocations: 0 bytes)\nCellList{3, Float64}\n  100000 real particles.\n  15603 cells with real particles.\n  125896 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair{N, T}, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box,\n    cl_pair::CellListPair,\n    aux::AuxThreaded;\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N,T},\n    cl_pair::CellListPair;\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap._promote_types-Tuple{Any, Any}","page":"Help entries","title":"CellListMap._promote_types","text":"_promote_types(cell,cutoff)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nPromotes the types of the unit cell matrix (or sides) and cutoff to floats if one or both were input as integers. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particle_to_celllist!","text":"add_particle_to_celllist!(\n    ip,\n    x::SVector{N,T},\n    box,\n    cl::CellList{N,T};\n    real_particle::Bool=true\n) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdds one particle to the cell lists, updating all necessary arrays.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particles!","text":"add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd all particles in vector x to the cell list cl. ishift is the shift in particle index, meaning that particle i of vector x corresponds to the particle with original index i+ishift. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.append_particles!","text":"append_particles!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd the particles of cell2 to cell1, updating the cell data and, if necessary, resizing (increasing) the particles array of cell1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_cartesian_indices","text":"cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nGiven the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.cell_center","text":"cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nComputes the geometric center of a computing cell, to be used in the projection of points. Returns a SVector{N,T}\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_linear_index","text":"cell_linear_index(nc::SVector{N,Int}, indices) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the index of the cell, in the 1D representation, from its cartesian coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}","page":"Help entries","title":"CellListMap.cell_matrix_from_sides","text":"cell_matrix_from_sides(sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the Orthorhombic unit cell matrix given a sides vector.\n\nExample\n\njulia> CellListMap.cell_matrix_from_sides([1,1,1])\n3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.check_unit_cell-Tuple{Box}","page":"Help entries","title":"CellListMap.check_unit_cell","text":"check_unit_cell(box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nChecks if the unit cell satisfies the conditions for using the minimum-image convention. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.copydata!","text":"copydata!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nCopies the data from cell2 to cell1, meaning that particles are copied element-wise from cell2 to cell1, with the particles array of cell1 being resized (increased) if necessary.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Help entries","title":"CellListMap.dot","text":"dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2} \n\nInternal function or structure - interface may change.\n\nExtended help\n\nLinearAlgebra.dot is slower than this for standard arrays (likely more accurate, but that is not relevant here).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType\n\ndraw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType\n\nThis function creates a plot of the computing cell, in two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType\n\nThis function creates a plot of the computing cell, in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Help entries","title":"CellListMap.fix_upper_boundary","text":"fix_upper_boundary(x::T,side) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nMove x to x -side if x == side, because we use the convention that the boundary belongs to the next cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Tuple{AbstractVector{<:AbstractVector}}","page":"Help entries","title":"CellListMap.limits","text":"limits(x)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x,  to be used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector{<:AbstractVector})","page":"Help entries","title":"CellListMap.limits","text":"limits(x,y)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x and y, to used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_naive!-Tuple{Any, Any, Any, Box}","page":"Help entries","title":"CellListMap.map_naive!","text":"map_naive!(f,output,x,box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that uses the naive pairwise mapping algorithm, for testing.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise","page":"Help entries","title":"CellListMap.map_pairwise","text":"map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)`\n\nis an alias for map_pairwise! which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through juliacall does not accept the  bang as a valid character. \n\n\n\n\n\n","category":"function"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)\n\nThe same but to evaluate some function between pairs of the particles of the vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(\n  f::Function,\n  output,\n  box::Box,\n  cl::CellList\n  ;parallel::Bool=true,\n  show_progress::Bool=false\n)\n\nThis function will run over every pair of particles which are closer than  box.cutoff and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the Box structure.  If the distance is smaller than the cutoff, a function f of the  coordinates of the two particles will be computed. \n\nThe function f receives six arguments as input: \n\nf(x,y,i,j,d2,output)\n\nWhich are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the output variable.  It has also to return the same output variable. Thus, f may or not  mutate output, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance d2 is computed  internally for comparison with the  cutoff, and is passed to the f because many times it is used for the  desired computation. \n\nExample\n\nComputing the mean absolute difference in x position between random particles,  remembering the number of pairs of n particles is n(n-1)/2. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.\n\njulia> n = 100_000;\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];\n\njulia> cl = CellList(x,box);\n\njulia> f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\n\njulia> normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\njulia> avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}","page":"Help entries","title":"CellListMap.merge_cell_lists!","text":"merge_cell_lists!(cl::CellList,aux::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nMerges an auxiliary aux cell list to cl, and returns the modified cl. Used to merge cell lists computed in parallel threads.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.nbatches-Tuple{CellList}","page":"Help entries","title":"CellListMap.nbatches","text":"nbatches(cl)\n\nReturns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list cl.  It returns the cl.nbatches.map_computation value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.\n\nA second argument can be provided, which may be :map or :build, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. \n\nExample\n\njulia> x = rand(3,1000); box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box,nbatches=(2,16));\n\njulia> nbatches(cl)\n16\n\njulia> nbatches(cl,:map)\n16\n\njulia> nbatches(cl,:build)\n2\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbor_cells","text":"neighbor_cells(box::Box{UnitCellType,N}) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of all neighboring cells of a cell if the cells have sides of box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbor_cells_forward","text":"neighbor_cells_forward(box::Box{UnitCellType,N}) where UnitCellType \n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(x,y,r;parallel=true,autoswap=true)\n\nComputes the list of pairs of particles of x which are closer than r to the particles of y. The autoswap option will swap x and y to try to optimize the cost of the construction of the cell list. \n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> y = [ rand(3) for i in 1:1_000 ];\n\njulia> CellListMap.neighborlist(x,y,0.05)\n5006-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 269, 0.04770884036497686)\n (25, 892, 0.03850515231540869)\n ⋮\n (9952, 749, 0.048875643578313456)\n (9984, 620, 0.04101242499363183)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(x,r;parallel=true)\n\nComputes the list of pairs of particles in x which are closer to each other than r.\n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> CellListMap.neighborlist(x,0.05)\n24848-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 1055, 0.022977369806392412)\n (1, 5086, 0.026650609138167428)\n ⋮\n (9989, 3379, 0.0467653507446483)\n (9989, 5935, 0.02432728985151653)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Box, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(box, cl; parallel=true)\n\nCompute the neighbor list of a single set or set pairs of particles. Returns a vector of tuples with all indices of the particles that are within box.cutoff, and the distances.  \n\nExample\n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02) \nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n  cutoff: 0.02\n  number of computing cells on each dimension: [52, 52, 52]\n  computing cell sizes: [0.02, 0.02, 0.02] (lcell: 1)\n  Total number of cells: 140608\n\njulia> cl = CellList(x,box) # single set\nCellList{3, Float64}\n  999 cells with real particles.\n  1126 particles in computing box, including images.\n\n\njulia> CellListMap.neighborlist(box,cl,parallel=false)\n15-element Vector{Tuple{Int64, Int64, Float64}}:\n (187, 511, 0.010346860078531755)\n (203, 708, 0.010777737363239403)\n (296, 579, 0.018124283912224655)\n ⋮\n (584, 4, 0.016935844769524398)\n (725, 749, 0.019971874892397875)\n (773, 119, 0.01835233336121765)\n (927, 8, 0.011234110402648743)\n\n\nTo obtain the neighbor list (within the cutoff) between two sets of  particles, initialize the cell lists with the two sets: \n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> y = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02);\n\njulia> cl = CellList(x,y,box)\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   997 cells with real particles of target vector.\n\njulia> CellListMap.neighborlist(box,cl)\n35-element Vector{Tuple{Int64, Int64, Float64}}:\n (409, 982, 0.01634641594779082)\n (521, 422, 0.00919026348035512)\n (625, 731, 0.012986301890746663)\n ⋮\n (647, 730, 0.01565763971458105)\n (296, 668, 0.016556686306217868)\n (992, 589, 0.018392993428289553)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm-Tuple{Any}","page":"Help entries","title":"CellListMap.norm","text":"norm(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own norm(x) = norm_sqr(x).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.norm_sqr","text":"norm_sqr(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.out_of_bounding_box","text":"out_of_bounding_box(x::SVector{N},box::Box) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that evaluates if a particle is outside the computing bounding box, defined by the maximum and minimum unit cell coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.particle_cell","text":"particle_cell(x::SVector{N,T}, box::Box) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the coordinates of the computing cell to which a particle belongs, given its coordinates and the cell_size vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes Box.lcell + 1.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particles_per_cell-Tuple{CellList}","page":"Help entries","title":"CellListMap.particles_per_cell","text":"particles_per_cell(cl)\n\nReturns the average number of real particles per computing cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.partition!-Tuple{Any, AbstractVector}","page":"Help entries","title":"CellListMap.partition!","text":"partition!(x::AbstractVector,by)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that reorders x vector by putting in the first positions the elements with values satisfying by(el). Returns the number of elements that satisfy the condition.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.project_particles!","text":"project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nProjects all particles of the cell cellⱼ into unnitary vector Δc with direction  connecting the centers of cellⱼ and cellᵢ. Modifies projected_particles, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T}}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{2,2,T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 2D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T}}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 3D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reduce-Tuple{Number, Vector{<:Number}}","page":"Help entries","title":"CellListMap.reduce","text":"reduce(output, output_threaded)\n\nFunctions to reduce the output of common options (vectors of numbers  and vectors of vectors). This function can be replacted by custom reduction methods. It always must both receive the output variable as a parameter, and return it at the end.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N}, Any, Any}} where N","page":"Help entries","title":"CellListMap.replicate_particle!","text":"replicate_particle!(ip,p::SVector{N},box,cl) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicates the particle as many times as necessary to fill the computing box.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArrays.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}","page":"Help entries","title":"CellListMap.replicate_system!","text":"replicate_system!(x::AbstractVector,box::Box,ranges::Tuple)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicate the system (modifying the original array of coordinates) in all directions defined by the periodic system and by the range of unitary cells  of interest. x can be a (N,M) matrix, and the unit cell matrix can be provided instead of the box.\n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.replicate_system!(x,box,(0:0,-1:1))\n300-element Vector{SVector{2, Float64}}:\n [0.7119987163255118, 0.6788616154460262]\n [0.6188407316804118, 0.8497116428720384]\n [0.21328895963244354, 0.48932085643862977]\n ⋮\n [0.4114499470191678, 1.1034376619603892]\n [0.6094126258851252, 1.2328989485215263]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.reset!","text":"reset!(cl::CellList{N,T},box,n_real_particles) where{N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nResets a cell list, by setting everything to zero, but retaining the allocated particles and projected_particles vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}","page":"Help entries","title":"CellListMap.set_number_of_batches!","text":"set_number_of_batches!(cl,nbatches::Tuple{Int,Int}=(0,0))  \n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunctions that set the default number of batches for the construction of the cell lists,  and mapping computations. This is of course heuristic, and may not be the best choice for every problem. See the parameter nbatches of the construction of the cell lists for  tunning this.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Tuple{AbstractVector{<:AbstractVector}, Any, Any}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::AbstractVector{<:AbstractVector},unit_cell_matrix,indices)\n\nTranslates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. \n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))\n100-element Vector{SVector{2, Float64}}:\n [1.847791110439223, 1.5989103939725295]\n [1.3493293666090889, 1.4002971843576644]\n [1.4111736701313218, 1.3471780214994182]\n ⋮\n [1.1548437388991908, 1.7034501001177493]\n [1.4066300885242247, 1.2907398318754952]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nTranslate vector x according to the unit_cell_matrix lattice vectors and the indices provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.view_celllist_particles","text":"view_celllist_particles(cl::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAuxiliary function to view the particles of a computing box, including images created for computing purposes.\n\nExample\n\njulia> box = Box([ 100 50; 50 100 ],10);\n\njulia> x = [ box.unit_cell_max .* rand(SVector{2,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> p = CellListMap.view_celllist_particles(cl);\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),label=nothing,xlims=(-10,180),ylims=(-10,180))\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_cell_fraction-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_cell_fraction","text":"wrap_cell_fraction(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nObtaint the coordinates of x as a fraction of unit cell vectors, first positive cell. x is a vector of dimension N and cell a matrix of  dimension NxN\n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_cell_fraction(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 0.5\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, for an Orthorhombic cell of which only the side lengths are provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given an Orthorhombic cell. This is slightly cheaper than for general cells.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given a general Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. \n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_to_first(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 5.0\n 3.0000000000000004\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Box}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given the Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given an Orthorhombic cell.  This is slightly cheaper than for general cells.  \n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full code of the examples described here is available at the examples directory. ","category":"page"},{"location":"examples/#Mean-difference-of-coordinates","page":"Examples","title":"Mean difference of coordinates","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Computing the mean difference in x position between random particles. The closure is used to remove the indexes and the distance of the particles from the parameters of the input function, as they are not needed in this case.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CellListMap\n\n# System properties\nN = 100_000\nsides = [250,250,250]\ncutoff = 10\n\n# Particle positions\nx = [ sides .* rand(3) for i in 1:N ]\n\n# Initialize linked lists and box structures\nbox = Box(sides,cutoff)\ncl = CellList(x,box)\n\n# Function to be evaluated from positions \nf(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\nnormalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\n# Run calculation (0.0 is the initial value)\navg_dx = normalization * map_pairwise(\n    (x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl \n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.average_displacement() and is available in the average_displacement.jl file.","category":"page"},{"location":"examples/#Histogram-of-distances","page":"Examples","title":"Histogram of distances","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Computing the histogram of the distances between particles (considering the same particles as in the above example). Again, we use a closure to remove the positions and indexes of the particles from the function arguments, because they are not needed. The distance, on the other side, is needed in this example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function that accumulates the histogram of distances\nfunction build_histogram!(d2,hist)\n    d = sqrt(d2)\n    ibin = floor(Int,d) + 1\n    hist[ibin] += 1\n    return hist\nend;\n\n# Initialize (and preallocate) the histogram\nhist = zeros(Int,10);\n\n# Run calculation\nmap_pairwise!(\n    (x,y,i,j,d2,hist) -> build_histogram!(d2,hist),\n    hist,box,cl\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that, since hist is mutable, there is no need to assign the output of map_pairwise! to it. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.distance_histogram() and is available in the distance_histogram.jl file.","category":"page"},{"location":"examples/#Gravitational-potential","page":"Examples","title":"Gravitational potential","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this test we compute the \"gravitational potential\", assigning to each particle a different mass. In this case, the closure is used to pass the masses to the function that computes the potential.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair \nfunction potential(i,j,d2,mass,u)\n    d = sqrt(d2)\n    u = u - 9.8*mass[i]*mass[j]/d\n    return u\nend\n\n# Run pairwise computation\nu = map_pairwise((x,y,i,j,d2,u) -> potential(i,j,d2,mass,u),0.0,box,cl)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.gravitational_potential() and is available in the gravitational_potential.jl file.","category":"page"},{"location":"examples/#Gravitational-force","page":"Examples","title":"Gravitational force","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example, we update a force vector of for all particles.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair: update force vector\nfunction calc_forces!(x,y,i,j,d2,mass,forces)\n    G = 9.8*mass[i]*mass[j]/d2\n    d = sqrt(d2)\n    df = (G/d)*(x - y)\n    forces[i] = forces[i] - df\n    forces[j] = forces[j] + df\n    return forces\nend\n\n# Initialize and preallocate forces\nforces = [ zeros(SVector{3,Float64}) for i in 1:N ]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,forces) -> calc_forces!(x,y,i,j,d2,mass,forces),\n    forces,box,cl\n)\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.gravitational_force() and is available in the gravitational_force.jl file.","category":"page"},{"location":"examples/#Nearest-neighbor","page":"Examples","title":"Nearest neighbor","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we compute the indexes of the particles that satisfy the minimum distance between two sets of points, using the linked lists. The distance and the indexes are stored in a tuple, and a reducing method has to be defined for that tuple to run the calculation.  The function does not need the coordinates of the points, only their distance and indexes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Number of particles, sides and cutoff\nN1=1_500\nN2=1_500_000\nsides = [250,250,250]\ncutoff = 10.\nbox = Box(sides,cutoff)\n\n# Particle positions\nx = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N1 ]\ny = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N2 ]\n\n# Initialize auxiliary linked lists\ncl = CellList(x,y,box)\n\n# Function that keeps the minimum distance\nf(i,j,d2,mind) = d2 < mind[3] ? (i,j,d2) : mind\n\n# We have to define our own reduce function here\nfunction reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend\n\n# Initial value\nmind = ( 0, 0, +Inf )\n\n# Run pairwise computation\nmind = map_pairwise( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind),\n    mind,box,cl;reduce=reduce_mind\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.nearest_neighbor() and is available in the nearest_neighbor.jl file.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example CellListMap.Examples.nearest_neighbor_nopbc() of nearest_neighbor_nopbc.jl describes a similar problem but without periodic boundary conditions. Depending on the distribution of points and size it is a faster method than usual ball-tree methods. ","category":"page"},{"location":"examples/#Neighbor-lists","page":"Examples","title":"Neighbor lists","text":"","category":"section"},{"location":"examples/#The-CellListMap.neighborlist-function","page":"Examples","title":"The CellListMap.neighborlist function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The package provides a neighborlist function that implements this calculation. Without periodic boundary conditions, just do:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> x = [ rand(3) for _ in 1:10_000 ];\n\njulia> CellListMap.neighborlist(x,0.05)\n24778-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 62, 0.028481068525796384)\n ⋮\n (9954, 1749, 0.04887502372299809)\n (9974, 124, 0.040110356034451795)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"or CellListMap.neighborlist(x,y,r) for computing the lists of pairs of two sets closer than r.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The returning array contains tuples with the index of the particle in the first vector, the index of the particle in the second vector, and their distance.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If periodic boundary conditions are used, the Box and CellList must be constructed in advance:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> x = [ rand(3) for _ in 1:10_000 ]; \n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box);\n\njulia> CellListMap.neighborlist(box,cl)\n\njulia> CellListMap.neighborlist(box,cl)\n209506-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 121, 0.05553035041478053)\n (1, 1589, 0.051415489701932444)\n ⋮\n (7469, 7946, 0.09760096646331885)","category":"page"},{"location":"examples/#Implementation","page":"Examples","title":"Implementation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The implementation of the above function follows the principles below.   The empty pairs output array will be split in one vector for each thread, and reduced with a custom reduction function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function to be evaluated for each pair: push pair\nfunction push_pair!(i,j,d2,pairs)\n    d = sqrt(d2)\n    push!(pairs,(i,j,d))\n    return pairs\nend\n\n# Reduction function\nfunction reduce_pairs(pairs,pairs_threaded)\n    for i in 1:length(pairs_threaded)\n        append!(pairs,pairs_threaded[i])\n    end\n    return pairs\nend\n\n# Initialize output\npairs = Tuple{Int,Int,Float64}[]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,pairs) -> push_pair!(i,j,d2,pairs),\n    pairs,box,cl,\n    reduce=reduce_pairs\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full example can be run with CellListMap.Examples.neighborlist(), available in the file  neighborlist.jl.","category":"page"},{"location":"units_etc/#Units,-automatic-differentiation,-etc.","page":"Units, autodiff, etc.","title":"Units, automatic differentiation, etc.","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The functions of CellListMap.jl support the propagation of generic (isbits) types, and thus units and thus automatic differentiation and the use of Unitful. A set of working examples can be found in the generic_types.jl file.","category":"page"},{"location":"units_etc/#Unitful-and-units","page":"Units, autodiff, etc.","title":"Unitful and units","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"We start illustrating the support for unit propagation. We need to define all involved quantities in the same units:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using Unitful, StaticArrays\n\njulia> cutoff = 0.1u\"nm\" \n0.1 nm\n\njulia> box = Box([1.0, 1.0, 1.0]u\"nm\",cutoff)\nBox{OrthorhombicCell, 3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}, Quantity{Float64, 𝐋^2, Unitful.FreeUnits{(nm^2,), 𝐋^2, nothing}}, 9}\n  unit cell matrix = [ 1.0 nm, 0.0 nm, 0.0 nm; 0.0 nm, 1.0 nm, 0.0 nm; 0.0 nm, 0.0 nm, 1.0 nm ]\n  cutoff = 0.1 nm\n  number of computing cells on each dimension = [12, 12, 12]\n  computing cell sizes = [0.1 nm, 0.1 nm, 0.1 nm] (lcell: 1)\n  Total number of cells = 1728\n\njulia> x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}\n  1000 real particles.\n  626 cells with real particles.\n  1694 particles in computing box, including images.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The corresponding mapping must take care of defining the result in the correct units associated to the expected output. For example, here we will compute just the sum of the squared distances between the particles within the cutoff. Thus, the expected output has the same units as the square of the dimensions: ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> sum_sqr = zero(typeof(cutoff^2))\n0.0 nm^2\n\njulia> sum_sqr = map_pairwise!(\n           (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n           sum_sqr, box, cl\n       )\n12.983283925249138 nm^2","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The performance penalty associated to propagating units is small. With units, we get:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using BenchmarkTools\n\njulia> @btime let x = $x\n           cutoff = 0.1u\"nm\" \n           box = Box([1.0,1.0,1.0]u\"nm\",cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(typeof(cutoff^2))\n           map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n       end\n  1.828 ms (6547 allocations: 1.22 MiB)\n12.983283925249138 nm^2","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"and the same problem without units runs in:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> @btime let x = $([ SVector{3,Float64}(ustrip.(v)) for v in x ])\n           cutoff = 0.1 \n           box = Box([1.0,1.0,1.0],cutoff)\n           cl = CellList(x,box)\n           sum_sqr = 0.\n           map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n       end\n  1.783 ms (6547 allocations: 1.22 MiB)\n12.983283925249138","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Auxiliary functions, like CellListMap.neighborlist, propagate units correctly:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1u\"nm\"\n0.1 nm\n\njulia> box = Box([1.0, 1.0, 1.0]u\"nm\",cutoff);\n\njulia> x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];\n\njulia> CellListMap.neighborlist(x,cutoff)\n1796-element Vector{Tuple{Int64, Int64, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}}:\n (1, 583, 0.06456224519583421 nm)\n (10, 216, 0.04958058924623024 nm)\n ⋮\n (934, 615, 0.08834318454969409 nm)\n (934, 692, 0.05002019032986014 nm)","category":"page"},{"location":"units_etc/#Automatic-differentiation","page":"Units, autodiff, etc.","title":"Automatic differentiation","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Allowing automatic differentiation follows the same principles, meaning that we only need to allow the propagation of dual types through the computation by proper initialization of the input data.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The variables are each component of each vector, thus the easiest way to represent the points such that automatic differentiation packages understand is by creating a matrix:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> x = rand(3,1000)\n3×1000 Matrix{Float64}:\n 0.186744  0.328719  0.874102  0.503535   …  0.328161  0.0895699  0.917338\n 0.176157  0.972954  0.80729   0.624724      0.655268  0.470754   0.327578\n 0.648482  0.537362  0.599624  0.0688776     0.92333   0.497984   0.208924","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The key here is allow all the types of the parameters to follow the type propagation of the elements of x inside the differentiation routine. The function we define to compute the derivative is, then:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> function sum_sqr(x,sides,cutoff)\n           cutoff = eltype(x)(cutoff)\n           sides = eltype(x).(sides)\n           box = Box(sides,cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(eltype(x))\n           sum_sqr = map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n           return sum_sqr\n       end\nsum_sqr (generic function with 1 method)","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Note that we allow cutoff  and sides  to be converted to the same type of the input x  of the function. For a simple call to the function this is inconsequential:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1; sides = [1,1,1];\n\njulia> sum_sqr(x,sides,cutoff)\n12.897650398753228","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"but the conversion is required to allow the differentiation to take place:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> ForwardDiff.gradient(x -> sum_sqr(x,sides,cutoff),x)\n3×1000 Matrix{Float64}:\n -0.132567   0.029865  -0.101301  …   0.249267    0.0486424  -0.0400487\n  0.122421   0.207495  -0.184366     -0.201648   -0.105031    0.218342\n  0.0856502  0.288924   0.122445     -0.0147022  -0.103314   -0.0862264","category":"page"},{"location":"units_etc/#Measurements","page":"Units, autodiff, etc.","title":"Measurements","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Propagating uncertainties through the Measurements  and other similar packages requires a different strategy, because within CellListMap only isbits types can be used, which is not the case of the type Measurement type. ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"In cases like this, it is better to bypass all the internals of CellListMap  and provide the data to the function that computes pairwise properties directly as a closure. For example:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"A vector of particles with uncertainties in their coordinates can be created with: ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using StaticArrays \n\njulia> x_input = [ SVector{3}(measurement(rand(),0.01*rand()) for i in 1:3) for j in 1:1000 ]\n1000-element Vector{SVector{3, Measurement{Float64}}}:\n [0.1658 ± 0.003, 0.9951 ± 0.0054, 0.5067 ± 0.0035]\n [0.2295 ± 0.0074, 0.2987 ± 0.0021, 0.42828 ± 0.00099]\n ⋮\n [0.1362 ± 0.0034, 0.2219 ± 0.0048, 0.2119 ± 0.0072]\n [0.2521 ± 0.0038, 0.4988 ± 0.00013, 0.856046 ± 4.3e-5]","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The variables within the CellListMap functions will be stripped from the uncertainties. We do:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1; box = Box([1,1,1],cutoff);\n\njulia> x_strip = [ getproperty.(v,:val) for v in x_input ]\n1000-element Vector{SVector{3, Float64}}:\n [0.08441931492362276, 0.9911530546181084, 0.07408559584648788]\n [0.12084764467339837, 0.8284551316333133, 0.9021906852432111]\n ⋮\n [0.2418752113326077, 0.4429225751775432, 0.13576355747772784]\n [0.24440380524702654, 0.07148275176890073, 0.26722687487212315]","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The cell list is built with the stripped values:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cl = CellList(x_strip,box)\nCellList{3, Float64}\n  1000 real particles.\n  637 cells with real particles.\n  1695 particles in computing box, including images.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The result is initialized with the proper type,","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> sum_sqr = measurement(0.,0.)\n0.0 ± 0.0","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"and the mapping is performed with the stripped coordinates, but passing the values with uncertainties to the mapped function, which will perform the computation on the pairs with those values:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using LinearAlgebra: norm_sqr\n\njulia> sum_sqr = map_pairwise!(\n           (xᵢ,xⱼ,i,j,d2,sum_sqr) -> begin\n               x1 = x_input[i]\n               x2 = CellListMap.wrap_relative_to(x_input[j],x1,box)\n               sum_sqr += norm_sqr(x2-x1)\n               return sum_sqr\n           end, \n           sum_sqr, box, cl\n       )\n13.14 ± 0.061","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"In the function above, the xᵢ and xⱼ coordinates, which correspond to the coordinates in x_input[i] and x_input[j], but already wrapped relative to each other, are ignored, because they don't carry the uncertainties. We use only the indexes i and j to recompute the relative position of the particles according to the periodic boundary conditions (using the CellListMap.wrap_relative_to function) and their (squared) distance. Since the x_input  array carries the uncertainties, the computation of sum_sqr will propagate them.   ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"note: Note\nAll these computations should be performed inside the scope of a function for optimal performance. The examples here can be followed by copying and pasting the code into the REPL, but this is not the recommended practice for critical code. The strategy of bypassing the internal computations of CellListMap may be useful for improving performance even if the previous and simpler method is possible. ","category":"page"},{"location":"options/#Additional-options","page":"Options","title":"Additional options","text":"","category":"section"},{"location":"options/#Input-coordinates-as-matrices","page":"Options","title":"Input coordinates as matrices","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"For compatibility with other software, the input coordinates can be provided as matrices. The matrices must have dimensions (2,N) or (3,N), where N is the number of particles (because Julia is column-major, thus this has the same memory layout of an array of length N of static vectors). ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"For example:","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"julia> x = rand(3,100);\n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100 real particles.\n  99 cells with real particles.\n  162 particles in computing box, including images.\n\njulia> map_pairwise!((x,y,i,j,d2,n) -> n += 1, 0, box, cl) # count neighbors\n23","category":"page"},{"location":"python/#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"Callling CellListMap from python can be useful if lists of neighbors or other properties have to be computed many times, making the overhead of initializing Julia negligible. As the example and benchmark below demonstrates, the current implementation of cell lists in this package is faster than common alternatives available in the python ecosystem. ","category":"page"},{"location":"python/#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"First, install julia through the pip package manager, with","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% pip install julia","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Using ipython3 (only Python geq 3 is supported), do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: from juliacall import Main as jl","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which, on the first call only, will install the latest stable version of Julia. Then, install CellListMap, with:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [2]: jl.Pkg.add(\"CellListMap\")","category":"page"},{"location":"python/#Calling-neighborlist","page":"From Python","title":"Calling neighborlist","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The typical input coordinates, in python, are a numpy array with shape (N,dim) where N is the number of particles and dim is the dimension of the space (2 or 3 for CellListMap). Here, we generate a set of 50,000 particles in three dimensions:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: import numpy as np\n\nIn [2]: coords = np.random.random((50_000,3))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Julia is column-major, and python is row-major, thus if we want to use the functions from CellListMap we need to transpose the coordinates:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [3]: coords_t = coords.transpose()","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"These transposed coordinates can be used in the CellListMap.neighborlist function. For example:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [4]: from juliacall import Main as jl\n\nIn [5]: jl.seval(\"using CellListMap\")\n\nIn [6]: neighbor_list = jl.CellListMap.neighborlist(coords_t,0.05)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which will return a list of tuples, containing all pairs of coordinates withing the cutoff (remember that the first call to a Julia function will always take longer than subsequent calls, because the function is JIT compiled):","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [12]: neighbor_list.shape\nOut[12]: (618774,)\n\nIn [13]: neighbor_list[1]\nOut[13]: (1, 37197, 0.047189685889846615)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Note that the third element of the tuple is the distance between the points.","category":"page"},{"location":"python/#Benchmark","page":"From Python","title":"Benchmark","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"To properly benchmark the neighborlist function from CellListMap, let us first define a simple wrapper that will include the transposition of the coordinates in the time:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [14]: def neighborlist(x,cutoff):\n    ...:     y = x.transpose()\n    ...:     nn = jl.CellListMap.neighborlist(y,cutoff)\n    ...:     return nn\n    ...:\n\nIn [15]: %timeit neighborlist(coords,0.05)\n61.7 ms ± 707 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Let us compare this with the performance of a inrange neighborlist algorithm from scipy:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [29]: from scipy.spatial import cKDTree\n\nIn [30]: def neighborlist_scipy(x,cutoff) : \n    ...:     kd_tree = cKDTree(x)  \n    ...:     pairs = kd_tree.query_pairs(r=0.05)  \n    ...:     return pairs \n    ...:\n\nIn [31]: %timeit neighborlist_scipy(coords,0.05)\n206 ms ± 2.07 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Just to confirm, this is the number of pairs that is being output in this test","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [32]: len(neighborlist_scipy(x,cutoff)) # using Scipy\nOut[32]: 618475\n\nIn [20]: len(neighborlist(coords,0.05)) # using CellListMap\nOut[20]: 618475","category":"page"},{"location":"python/#Multi-threading","page":"From Python","title":"Multi-threading","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"These examples were run single-threaded. To run multi-threaded, an environment variable for Julia needs to be set. For example, in bash, do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% export JULIA_NUM_THREADS=8","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"For the current example, this provides a small additional speedup:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [11]: %timeit neighborlist(coords,0.05)\n31.3 ms ± 1.22 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/#Overhead","page":"From Python","title":"Overhead","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The overhead of calling the function through juliacall  is small. From within Julia, the timings of a similar execution would be:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"julia> using BenchmarkTools\n\njulia> using CellListMap\n\njulia> x = rand(3,50_000);\n\njulia> @btime CellListMap.neighborlist($x,0.05);\n  27.294 ms (35935 allocations: 58.39 MiB)\n\njulia> @btime CellListMap.neighborlist($x,0.05,parallel=false);\n  51.299 ms (17687 allocations: 37.43 MiB)","category":"page"},{"location":"python/#General-mappings","page":"From Python","title":"General mappings","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"A greater flexibility on the use of CellListMap from python can be obtained by defining custom Julia functions. The construction of the systems and of the cell lists can be performed without modification. For example:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [28]: box = jl.Box(np.array([1,1,1]),0.05)\n\nIn [29]: box\n\nOut[29]: \nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n  cutoff: 0.05\n  number of computing cells on each dimension: [22, 22, 22]\n  computing cell sizes: [0.05, 0.05, 0.05] (lcell: 1)\n  Total number of cells: 10648","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [30]: x = np.random.random((50_000,3))\n\nIn [31]: x_t = x.transpose()\n\nIn [32]: cl = jl.CellList(x_t,box)\n\nIn [33]: cl\nOut[33]: \nCellList{3, Float64}\n  50000 real particles.\n  7982 cells with real particles.\n  66532 particles in computing box, including images.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The function to be mapped, however, has to be defined in Julia, using seval. For example, here we define a function that computes the histogram of the distances within the cutoff. ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [34]: jl.seval(\"\"\"  \n    ...: function histogram(x,y,i,j,d2,hist) \n    ...:     cutoff = 0.05 \n    ...:     dc = sqrt(d2)/cutoff # in [0,1] \n    ...:     ibin = floor(Int,dc*10) + 1 # in [0,10] \n    ...:     hist[ibin] += 1 \n    ...:     return hist \n    ...: end \n    ...: \"\"\")\nOut[34]: histogram (generic function with 1 method)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"We can initialize the output variable (the histogram) using a regular numpy array: ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [8]: hist = np.zeros(10)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"and call the map_pairwise function to obtain the histogram of the distances within the cutoff:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [37]: jl.map_pairwise(jl.histogram, hist, box, cl)\nOut[37]: \n10-element PythonCall.PyArray{Float64, 1, true, true, Float64}:\n 153344.0\n      1.151744e6\n      3.066624e6\n      5.787392e6\n      9.220608e6\n      1.3175552e7\n      1.7414912e7\n      2.1817088e7\n      2.6189312e7\n      3.0583808e7","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"With this interface, however, it is not possible to pass additional parameters to the mapped function, and thus the additional parameters have to defined inside the called function (as the cutoff in the current example). This is not ideal, for example, for computing accelerations, which depend on the masses of the particles. In this case, currently, either just use Julia from start and closures, or use the neighborlist  function to obtain the list of neighbors to then compute whatever property is desired from the list of pairs, although this is suboptimal in terms of performance.  ","category":"page"},{"location":"reference/#Citation","page":"Reference","title":"Citation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"If you use this software and need to cite it, please use the following reference:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Martínez, Leandro. (2021, June 11). CellListMap.jl: Flexible implementation of cell lists to map the calculations of short-ranged particle-pair dependent functions, such as forces, energies, neighbor lists, etc. Zenodo. http://doi.org/10.5281/zenodo.4927541","category":"page"},{"location":"#CellListMap.jl","page":"Overview","title":"CellListMap.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package is for computing interactions or any other property dependent on the distances between pairs of two- or three-dimensional particles, within a cutoff. It maps a function to be computed pairwise using cell lists, using periodic boundary conditions of any type. Parallel and serial implementations can be used. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It allows the fast computation of any quantity from the pairs that are within the desired cutoff, for example an average distance or an histogram of distances, forces, potentials, minimum distances, etc., as the examples below illustrate. This is done by passing the function to be evaluated as a parameter of the map_pairwise! function. ","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> import Pkg\n\njulia> Pkg.add(\"CellListMap\")","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The main function is map_parwise! (or map_pairwise): ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If the analysis is performed on the pairs of a single vector x (n*(n-1)/2 pairs), the function can be called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellList)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"while if two distinct sets of points are provided (n*m pairs), it is called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where the cl variable of type CellList or CellListPair contains the cell lists built from the coordinates of the system, and box contains the system box properties.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"These functions will run over every pair of particles which are closer than box.cutoff and compute the (squared) Euclidean distance between the particles, considering the periodic boundary conditions given in the Box structure. If the distance is smaller than the cutoff, a user defined function f of the coordinates of the two particles will be computed. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The function f receives six arguments as input: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f(x,y,i,j,d2,output)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Which are the coordinates of one particle, the coordinates of the second particle, the index of the first particle, the index of the second particle, the squared distance between them, and the output variable. It has also to return the same output variable. Thus, f may or not mutate output, but in either case it must return it.  The squared distance d2 is computed   internally for comparison with the cutoff, and is passed to the f because many times it is used for the desired computation. Thus, the function f that is passed to map_pairwise! must be always of the form:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"function f(x,y,i,j,d2,output)\n    # update output\n    return output\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and the user can define more or less parameters or additional data required to compute the function using closures, as shown in the examples.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Parallel calculations are the default if more than one thread is available. Use parallel=false as an optional argument to map_pairwise! to run the serial version instead.","category":"page"},{"location":"#Mutable-and-immutable-outputs","page":"Overview","title":"Mutable and immutable outputs","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise! and map_pairwise (with the bang, or not) are aliases of the same function, which always returns the result value. It is a convention in Julia that functions ending with the ! mutate the arguments, while those without do not. Here, this behavior is dependent on the type of input. If the output variable is immutable, its value won't be mutated, and the assignment of the result to the output value depends on explicit assignment. In these cases, it is customary to use the map_pairwise (without !) function name:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"output = map_pairwise(function, output0, box, cl)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where output0 represents the initial value of the immutable output. When, on the contrary, the output is a mutable variable (an array, for example), the map_pairwise! version is preferred for code clarity, and the reassignment is not needed (nor recommendable): ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"output = zeros(10) # example of mutable output\nmap_pairwise!(function, output, box, cl)","category":"page"},{"location":"pbc/#Periodic-boundary-conditions","page":"Periodic conditions","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"pbc/#Orthorhombic-periodic-boundary-conditions","page":"Periodic conditions","title":"Orthorhombic periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Orthorhombic periodic boundary conditions allow some special methods that are faster than those for general cells. To initialize an Orthorhombic cell, just provide the length of the cell on each side, and the cutoff. For example:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([100,70,130],12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 0.0 0.0; 0.0 70.0 0.0; 0.0 0.0 130.0]\n  cutoff: 12.0\n  number of computing cells on each dimension: [10, 7, 12]\n  computing cell sizes: [12.5, 14.0, 13.0] (lcell: 1)\n  Total number of cells: 840","category":"page"},{"location":"pbc/#Triclinic-periodic-boundary-conditions","page":"Periodic conditions","title":"Triclinic periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Triclinic periodic boundary conditions of any kind can be used. However, the input has some limitations for the moment. The lattice vectors must have strictly positive coordinates, and the smallest distance within the cell cannot be smaller than twice the size of the cutoff. An error will be produced if the cell does not satisfy these conditions. ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Let us illustrate building a two-dimensional cell, for easier visualization. A matrix of column-wise lattice vectors is provided in the construction of the box, and that is all. ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Here, the lattice vectors are [1,0] and [0.5,1] (and we illustrate with cutoff=0.1): ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([ 1.0  0.5\n                     0  1.0 ], 0.1);\n\njulia> x = 10*rand(SVector{2,Float64},1000);","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"We have created random coordinates for 1000 particles, that are not necessarily wrapped according to the periodic boundary conditions. We can see the coordinates in the minimum image cell with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> using Plots\n\njulia> CellListMap.draw_computing_cell(x,box)","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/lattice.png>","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"The construction of the cell list is, as always, done with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> cl = CellList(x,box)\nCellList{2, Float64}\n  109 cells with real particles.\n  2041 particles in computing box, including images.\n","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Upon construction of the cell lists, the particles are replicated to fill a rectangular box (or orthorhombic box, in three-dimensions), with boundaries that exceed the actual system size. This improves the performance of the pairwise computations by avoiding the necessity of wrapping coordinates on the main loop (this is an implementation detail only). ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"In summary, to use arbitrary periodic boundary conditions, just initialize the box with the matrix of lattice vectors. In three dimensions, for example, one could use:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([ 50.  0. 00. \n                    0. 30. 30.          \n                    0. 00. 50. ],  2.)\n\njulia> x = 100*rand(SVector{3,Float64},10000);\n\njulia> p = [ CellListMap.wrap_to_first(x,box) for x in x ];\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),aspect_ratio=1,framestyle=:box,label=:none)","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"to work with an arbitrary 3D lattice, Which in this case looks like:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/3Dlattice.png>","category":"page"},{"location":"pbc/#Without-periodic-boundary-conditions","page":"Periodic conditions","title":"Without periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"To avoid the use of periodic boundary conditions it is enough to define an Orthorhombic box with lengths in each direction that are larger than the limits of the coordinates of the particles plus the cutoff. This can be done automatically with the limits function. The box must be constructed with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [111.99749159163106 0.0 0.0; 0.0 111.99757156637344 0.0; 0.0 0.0 111.99910298572958]\n  cutoff: 12.0\n  number of computing cells on each dimension: [11, 11, 11]\n  computing cell sizes: [12.444165732403452, 12.444174618485938, 12.444344776192175] (lcell: 1)\n  Total number of cells: 1331","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"or, for computing the interaction between two disjoint sets of particles, call the limits function with two arguments:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> y = [ [120,180,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [131.9978650409108 0.0 0.0; 0.0 191.99730748624336 0.0; 0.0 0.0 111.99917288242698]\n  cutoff: 12.0\n  number of computing cells on each dimension: [12, 17, 11]\n  computing cell sizes: [13.19978650409108, 12.799820499082891, 12.444352542491886] (lcell: 1)\n  Total number of cells: 2244","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Note that the unit cell length is, on each direction, the maximum coordinates of all particles plus the cutoff. This will avoid the computation of pairs of periodic images. The algorithms used for computing interactions in Orthorhombic cells will then be used.","category":"page"}]
}
