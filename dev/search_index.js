var documenterSearchIndex = {"docs":
[{"location":"parallelization/#Parallelization-splitting-and-reduction","page":"Parallelization","title":"Parallelization splitting and reduction","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The parallel execution requires the splitting of the computation among threads, obviously. Thus, the output variable must be split and then reduced to avoid concurrency. To control these steps, set manually the output_threaded and reduce optional input parameters of the map_pairwise! function. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"By default, we define (here using Base.Threads):","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"output_threaded = [ deepcopy(output) for i in 1:nthreads() ]","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"and, for scalars and vectors, the reduction is just the sum of the output per thread:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"reduce(output::Number,output_threaded) = sum(output_threaded)\nfunction reduce(output::Vector,output_threaded) \n    for i in 1:nthreads()\n         @. output += output_threaded[i] \n    end\n    return output\nend","category":"page"},{"location":"parallelization/#Custom-reduction-functions","page":"Parallelization","title":"Custom reduction functions","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"In some cases, as in the Nearest neighbour example, the output is a tuple and reduction consists in keeping the output from each thread having the minimum value for the distance. Thus, the reduction operation is not a simple sum over the elements of each threaded output. We can, therefore, overwrite the default reduction method, by passing the reduction function as the reduce parameter of map_pairwise!:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"mind = map_pairwise!( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind), mind,box,cl;\n    reduce=reduce_mind\n)","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"where here the reduce function is set to be the custom function that keeps the tuple associated to the minimum distance obtained between threads:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"function reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:Threads.nthreads()\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"This function must return the updated output variable, being it mutable or not, to be compatible with the interface.  ","category":"page"},{"location":"parallelization/#Preallocating-auxiliary-arrays:-threaded-output-and-cell-lists","page":"Parallelization","title":"Preallocating auxiliary arrays: threaded output and cell lists","text":"","category":"section"},{"location":"parallelization/#Preallocating-the-cell-lists-and-cell-list-auxiliary-arrays","page":"Parallelization","title":"Preallocating the cell lists and cell list auxiliary arrays","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The arrays containing the cell lists can be initialized only once, and then updated. This is useful for iterative runs. Note that, since the list size depends on the box size and cutoff, if the box properties changes some arrays might be increased (never shrink) on this update. ","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"# Initialize cell lists with initial coordinates\ncl = CellList(x,box)\n# Allocate auxiliary arrays for threaded cell list construction\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,box,cl,aux) \nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"The procedure is identical if using two sets of coordinates, in which case, one would do:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"cl = CellList(x,y,box)\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,y,box,cl,aux)\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"By passing the aux auxiliary structure, the UpdateCellList! functions will only allocate some minor variables associated to the launching of multiple threads and, possibly, to the expansion of the cell lists if the box or the number of particles became greater. ","category":"page"},{"location":"parallelization/#Preallocating-threaded-output-auxiliary-arrays","page":"Parallelization","title":"Preallocating threaded output auxiliary arrays","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"On parallel runs, note that output_threaded is, by default, initialized on the call to map_pairwise!. Thus, if the calculation must be run multiple times (for example, for several steps of a trajectory), it is probably a good idea to preallocate the threaded output, particularly if it is a large array. For example, the arrays of forces should be created only once, and reset to zero after each use:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"forces = zeros(SVector{3,Float64},N)\nforces_threaded = [ deepcopy(forces) for i in 1:nthreads() ]\nfor i in 1:nsteps\n    map_pairwise!(f, forces, box, cl, output_threaded=forces_threaded)\n    # work with the final forces vector\n    ...\n    # Reset forces_threaded\n    for i in 1:Threads.nthreads()\n        @. forces_threaded[i] = zero(SVector{3,Float64}) \n    end\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"In this case, the forces vector will be updated by the default reduction method.","category":"page"},{"location":"performance/#Performance-tunning-and-additional-options","page":"Performance","title":"Performance tunning and additional options","text":"","category":"section"},{"location":"performance/#Optimizing-the-cell-grid","page":"Performance","title":"Optimizing the cell grid","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Until this is automatized (hopefully soon), the partition of the space into cells is dependent on a parameter lcell which can be passed to Box. For example:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"box = Box(x,box,lcell=2)\ncl = CellList(x,box)\nmap_pairwise!(...)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"This parameter determines how fine is the mesh of cells. There is a trade-off between the number of cells and the number of particles per cell. For low-density systems, greater meshes are better, because each cell will have only a few particles and the computations loop over a smaller number of cells. For dense systems, it is better to run over more cells with less particles per cell. It is a good idea to test different values of lcell to check which is the optimal choice for your system. Usually the best value is between lcell=1 and lcell=6, but for large and dense systems a larger value may be optimal. For molecular systems with normal densities lcell=1 is likely the optimal choice. The performance can be tested using the progress meter, as explained below.  ","category":"page"},{"location":"performance/#Output-progress","page":"Performance","title":"Output progress","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"For long-running computations, the user might want to see the progress. A progress meter can be turned on with the show_progress option. For example:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"map_pairwise!(f,output,box,cl,show_progress=true)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"whill print something like:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Progress:  43%|█████████████████                    | ETA: 0:18:25","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Thus, besides being useful for following the progress of a long run, it is useful to test different values of lcell to tune the performance of the code, by looking at the estimated time to finish (ETA) and killing the execution after a sample run. The default and recommended option for production runs is to use show_progress=false, because tracking the progress introduces a small overhead into the computation. ","category":"page"},{"location":"performance/#Some-benchmarks","page":"Performance","title":"Some benchmarks","text":"","category":"section"},{"location":"performance/#Computing-a-histogram-of-pairwise-velocities","page":"Performance","title":"Computing a histogram of pairwise velocities","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"The goal here is to provide a good implementation of cell lists. We compare it with the implementation of the nice cython/python halotools package, in the computation of an histogram of mean pairwise velocities. ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"<center>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cd_v0.5.3.png>\n<br>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cv_v0.5.3.png>\n</center>","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The full test is available at this repository. And we kindly thank Carolina Cuesta for providing the example. These benchmarks were run on an Intel i7 8th gen laptop, with 4 cores (8 threads). ","category":"page"},{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"These entries can be viewed at the Julia REPL Julia using ","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? \nhelp?> function_name","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"Modules=[CellListMap]","category":"page"},{"location":"help/#CellListMap.AuxThreaded","page":"Help entries","title":"CellListMap.AuxThreaded","text":"struct AuxThreaded{N, T}\n\nstruct AuxThreaded{N, T}\n\nAuxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.AuxThreaded-Union{Tuple{CellListMap.CellListPair{V, N, T}}, Tuple{T}, Tuple{N}, Tuple{V}} where {V, N, T}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellListPair{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type for lists of disjoint particle sets,  to be passed to UpdateCellList! for in-place update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellList{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type, to be passed to UpdateCellList! for in-place  update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for _ in 1:100_000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box","page":"Help entries","title":"CellListMap.Box","text":"struct Box{UnitCellType, N, T, TSQ, M}\n\nunit_cell::CellListMap.UnitCell\nlcell::Int64\nnc::StaticArrays.SVector{N, Int64} where N\ncutoff::Any\ncutoff_sq::Any\nranges::StaticArrays.SVector{N, UnitRange{Int64}} where N\ncell_size::StaticArrays.SVector{N, T} where {N, T}\nunit_cell_max::StaticArrays.SVector{N, T} where {N, T}\n\nStructure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. \n\nExamples\n\njulia> using CellListMap\n\njulia> sides = [250,250,250];\n\njulia> cutoff = 10;\n\njulia> box = Box(sides,cutoff)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [27, 27, 27]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 19683\n\n\njulia> box = Box([ 10  0  0 \n                    0 10  5\n                    0  0 10 ], 1)\nBox{TriclinicCell, 3, Float64, 9}\nunit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]\ncutoff: 1.0\nnumber of computing cells on each dimension: [12, 17, 12]\ncomputing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)\nTotal number of cells: 2448\n\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T","page":"Help entries","title":"CellListMap.Box","text":"Box(\n    limits::Limits,\n    cutoff;\n    lcell::Int=1\n)\n\nThis constructor receives the output of limits(x) or limits(x,y) where x and y are the coordinates of the particles involved, and constructs a Box with size larger than the maximum coordinates ranges of all particles plus the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is always an Orthorhombic cell.\n\nExamples\n\njulia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [109.99633932875878 0.0 0.0; 0.0 109.99780283179763 0.0; 0.0 0.0 109.99587254766517]\n  cutoff: 10.0\n  number of computing cells on each dimension: [12, 12, 12]\n  computing cell sizes: [10.999633932875877, 10.999780283179764, 10.999587254766517] (lcell: 1)\n  Total number of cells: 1728\n\njulia> y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [159.99787690924168 0.0 0.0; 0.0 159.98878289444897 0.0; 0.0 0.0 109.99587254766517]\n  cutoff: 10.0\n  number of computing cells on each dimension: [18, 17, 12]\n  computing cell sizes: [10.666525127282778, 10.665918859629931, 10.999587254766517] (lcell: 1)\n  Total number of cells: 3672\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector{T} where T, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  sides::AbstractVector, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=OrthorhombicCell\n)\n\nFor orthorhombic unit cells, Box can be initialized with a vector of the  length of each side. \n\nExample\n\njulia> box = Box([120,150,100],10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [14, 17, 12]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 2856\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{T}, Tuple{AbstractMatrix{T}, Any, Int64, Type{UnitCellType}}} where {T, UnitCellType}","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  unit_cell_matrix::AbstractMatrix, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=TriclinicCell\n)\n\nConstruct box structure given the cell matrix of lattice vectors. This  constructor will always return a TriclinicCell box type, unless the UnitCellType parameter is set manually to OrthorhombicCell\n\nExample\n\njulia> unit_cell = [ 100   50    0 \n                       0  120    0\n                       0    0  130 ];\n\njulia> box = Box(unit_cell,10)\nBox{TriclinicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [17, 14, 15]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 3570\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Cell","page":"Help entries","title":"CellListMap.Cell","text":"struct Cell{N, T}\n\nlinear_index::Int64\ncartesian_index::CartesianIndex\ncenter::StaticArrays.SVector{N, T} where {N, T}\ncontains_real::Bool\nn_particles::Int64\nparticles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}\n\nThis structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighbouring cells need to be wrapped) \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList","page":"Help entries","title":"CellListMap.CellList","text":"struct CellList{N, T}\n\nn_real_particles::Int64\nNumber of real particles.\nnumber_of_cells::Int64\nNumber of cells.\nn_particles::Int64\nmutable number of particles in the computing box.\nn_cells_with_real_particles::Int64\nmutable number of cells with real particles.\nn_cells_with_particles::Int64\nmutable number of cells with particles, real or images.\ncell_indices::Vector{Int64}\nAuxiliary array that contains the indexes in list of the cells with particles, real or images.\ncell_indices_real::Vector{Int64}\nAuxiliary array that contains the indexes in the cells with real particles.\ncells::Array{CellListMap.Cell{N, T}, 1} where {N, T}\nVector containing cell lists of cells with particles.\nprojected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}\nAuxiliar array to store projected particles.\n\nStructure that contains the cell lists information.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"function CellList(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    autoswap=true\n) where {UnitCellType,N,T} \n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"function CellList(\n    x::AbstractMatrix,\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true\n) where {UnitCellType,N,T} \n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var\"#s20\"} where var\"#s20\"<:(AbstractVector{T} where T), AbstractVector{var\"#s19\"} where var\"#s19\"<:(AbstractVector{T} where T), Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    autoswap::Bool=true\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellListPair structure from scracth, given two vectors of particle coordinates and a Box, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using autoswap=false the cell list is constructed for the second (y)\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   10000 particles in the reference vector.\n   961 cells with real particles of target vector.\n\njulia> cl = CellList(x,y,box,autoswap=false)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   7389 cells with real particles of target vector.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var\"#s23\"} where var\"#s23\"<:(AbstractVector{T} where T), Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellList structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a Box, which contain the size ofthe system, cutoff, etc.  \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100000 real particles.\n  15600 cells with real particles.\n  126276 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellListPair","page":"Help entries","title":"CellListMap.CellListPair","text":"struct CellListPair{V, N, T}\n\nref::Any\ntarget::CellList\nswap::Bool\n\nStructure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Limits","page":"Help entries","title":"CellListMap.Limits","text":"struct Limits{T<:(AbstractVector{T} where T)}\n\nlimits::AbstractVector{T} where T\n\nStructure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ParticleWithIndex","page":"Help entries","title":"CellListMap.ParticleWithIndex","text":"struct ParticleWithIndex{N, T}\n\nindex::Int64\nreal::Bool\ncoordinates::StaticArrays.SVector{N, T} where {N, T}\n\nCopies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. The index is a 32bit integer such  that the complete struct has 32bytes.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ProjectedParticle","page":"Help entries","title":"CellListMap.ProjectedParticle","text":"struct ProjectedParticle{N, T}\n\nindex::Int64\nxproj::Any\ncoordinates::StaticArrays.SVector{N, T} where {N, T}\n\nAuxiliary structure to contain projected particles. Types of  scalars are chosen such that with a SVector{3,Float64} the complete struct has 32bytes.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T},\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var\"#s17\"} where var\"#s17\"<:(AbstractVector{T} where T), Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl::CellList{N,T},\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nFunction that updates the cell list cl new coordinates x and possibly a new box box, and receives a preallocated aux structure of auxiliary vectors for threaded cell list construction. Given a preallocated aux vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux)\n  16.384 ms (41 allocations: 3.88 KiB)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)\n  20.882 ms (0 allocations: 0 bytes)\nCellList{3, Float64}\n  100000 real particles.\n  15603 cells with real particles.\n  125896 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var\"#s23\"} where var\"#s23\"<:(AbstractVector{T} where T), Box, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl:CellList{N,T},\n    parallel=true\n) where {N,T}\n\nFunction that will update a previously allocated CellList structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the UpdateCellList!(x,box,cl,aux) method instead. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> box = Box([260,260,260],10);\n\njulia> x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = UpdateCellList!(x,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N,T},\n    cl_pair::CellListPair,\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}, CellListMap.CellListPair}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N,T},\n    cl_pair::CellListPair;\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var\"#s20\"} where var\"#s20\"<:(AbstractVector{T} where T), AbstractVector{var\"#s19\"} where var\"#s19\"<:(AbstractVector{T} where T), Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box{UnitCellType,N,T},\n    cl_pair::CellListPair,\n    aux::AuxThreaded{N,T};\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nThis function will update the cl_pair structure that contains the cell lists for disjoint sets of particles. It receives the preallocated aux structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7381 cells with real particles of target vector.\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = UpdateCellList!(x,y,box,cl,aux)\nCellList{3, Float64}\n  10000 real particles.\n  7358 cells with real particles.\n  12591 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux)\n  715.661 μs (41 allocations: 3.88 KiB)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7414 cells with real particles of target vector.\n   \njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)\n   13.042 ms (0 allocations: 0 bytes)\n CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n    50000 particles in the reference vector.\n    15031 cells with real particles of target vector.\n \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var\"#s20\"} where var\"#s20\"<:(AbstractVector{T} where T), AbstractVector{var\"#s19\"} where var\"#s19\"<:(AbstractVector{T} where T), Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}, CellListMap.CellListPair}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n  x::AbstractVector{<:AbstractVector},\n  y::AbstractVector{<:AbstractVector},\n  box::Box{UnitCellType,N,T},\n  cl:CellListPair,\n  parallel=true\n) where {UnitCellType,N,T}\n\nFunction that will update a previously allocated CellListPair structure, given  new updated particle positions, for example. This method will allocate new  aux threaded auxiliary arrays. For a non-allocating version, see the  UpdateCellList!(x,y,box,cl,aux) method.\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> cl = UpdateCellList!(x,y,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particle_to_celllist!","text":"add_particle_to_celllist!(\n    ip,\n    x::SVector{N,T},\n    box,\n    cl::CellList{N,T};\n    real_particle::Bool=true\n) where {N,T}\n\nAdds one particle to the cell lists, updating all necessary arrays.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particles!","text":"add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}\n\nAdd all particles in vector x to the cell list cl. ishift is the shift in particle index, meaning that particle i of vector x corresponds to the particle with original index i+ishift. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.append_particles!","text":"append_particles!(cell1::Cell,cell2::Cell)\n\nAdd the particles of cell2 to cell1, updating the cell data and, if necessary, resizing (increasing) the particles array of cell1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_cartesian_indices","text":"cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}\n\nGiven the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.cell_center","text":"cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nComputes the geometric center of a computing cell, to be used in the projection of points. Returns a SVector{N,T}\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_linear_index","text":"cell_linear_index(nc::SVector{N,Int}, indices) where N\n\nReturns the index of the cell, in the 1D representation, from its cartesian coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.check_unit_cell-Tuple{Box}","page":"Help entries","title":"CellListMap.check_unit_cell","text":"check_unit_cell(box::Box)\n\nChecks if the unit cell satisfies the conditions for using the minimum-image convention. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.copydata!","text":"copydata!(cell1::Cell,cell2::Cell)\n\nCopies the data from cell2 to cell1, meaning that particles are copied element-wise from cell2 to cell1, with the particles array of cell1 being resized (increased) if necessary.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Help entries","title":"CellListMap.dot","text":"dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2} \n\nLinearAlgebra.dot is slower than this for standard arrays (likely more accurate, but that is not relevant here).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2, T, TSQ, M} where {T, TSQ, M}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType\n\ndraw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType\n\nThis function creates a plot of the computing cell, in two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3, T, TSQ, M} where {T, TSQ, M}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType\n\nThis function creates a plot of the computing cell, in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Help entries","title":"CellListMap.fix_upper_boundary","text":"fix_upper_boundary(x::T,side) where T\n\nMove x to x -side if x == side, because we use the convention that the boundary belongs to the next cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.init_aux_threaded!-Tuple{CellListMap.AuxThreaded, CellList}","page":"Help entries","title":"CellListMap.init_aux_threaded!","text":"init_aux_threaded!(aux::AuxThreaded,cl::CellList)\n\nGiven an AuxThreaded object initialized with zero-length arrays, push ntrheads copies of cl into aux.lists and resize aux.idxs to the number of threads.  \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Tuple{AbstractVector{var\"#s25\"} where var\"#s25\"<:(AbstractVector{T} where T)}","page":"Help entries","title":"CellListMap.limits","text":"limits(x)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x,  to be used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector{var\"#s24\"} where var\"#s24\"<:(AbstractVector{T} where T))","page":"Help entries","title":"CellListMap.limits","text":"limits(x,y)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x and y, to used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_naive!-Tuple{Any, Any, Any, Box}","page":"Help entries","title":"CellListMap.map_naive!","text":"map_naive!(f,output,x,box)\n\nFunction that uses the naive pairwise mapping algorithm, for testing.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)\n\nThe same but to evaluate some function between pairs of the particles of the vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(\n  f::Function,\n  output,\n  box::Box,\n  cl::CellList\n  ;parallel::Bool=true,\n  show_progress::Bool=false\n)\n\nThis function will run over every pair of particles which are closer than  box.cutoff and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the Box structure.  If the distance is smaller than the cutoff, a function f of the  coordinates of the two particles will be computed. \n\nThe function f receives six arguments as input: \n\nf(x,y,i,j,d2,output)\n\nWhich are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the output variable.  It has also to return the same output variable. Thus, f may or not  mutate output, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance d2 is computed  internally for comparison with the  cutoff, and is passed to the f because many times it is used for the  desired computation. \n\nExample\n\nComputing the mean absolute difference in x position between random particles,  remembering the number of pairs of n particles is n(n-1)/2. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.\n\njulia> n = 100_000;\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];\n\njulia> cl = CellList(x,box);\n\njulia> f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\n\njulia> normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\njulia> avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}","page":"Help entries","title":"CellListMap.merge_cell_lists!","text":"merge_cell_lists!(cl::CellList,aux::CellList)\n\nMerges an auxiliary aux cell list to cl, and returns the modified cl. Used to merge cell lists computed in parallel threads.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbour_cells-Union{Tuple{Box{UnitCellType, 3, T, TSQ, M} where {T, TSQ, M}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbour_cells","text":"neighbour_cells(box::Box{UnitCellType,N}) where N\n\nFunction that returns the iterator of the cartesian indices of all neighbouring cells of a cell if the cells have sides of box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbour_cells_forward-Union{Tuple{Box{UnitCellType, 3, T, TSQ, M} where {T, TSQ, M}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbour_cells_forward","text":"neighbour_cells_forward(box::Box{UnitCellType,N}) where UnitCellType \n\nFunction that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbourlist-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.neighbourlist","text":"neighbourlist(x,y,r;parallel=true,autoswap=true)\n\nComputes the list of pairs of particles of x which are closer than r to the particles of y. The autoswap option will swap x and y to try to optimize the cost of the construction of the cell list. \n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> y = [ rand(3) for i in 1:1_000 ];\n\njulia> CellListMap.neighbourlist(x,y,0.05)\n5006-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 269, 0.04770884036497686)\n (25, 892, 0.03850515231540869)\n ⋮\n (9952, 749, 0.048875643578313456)\n (9984, 620, 0.04101242499363183)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbourlist-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.neighbourlist","text":"neighbourlist(x,r;parallel=true)\n\nComputes the list of pairs of particles in x which are closer to each other than r.\n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> CellListMap.neighbourlist(x,0.05)\n24848-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 1055, 0.022977369806392412)\n (1, 5086, 0.026650609138167428)\n ⋮\n (9989, 3379, 0.0467653507446483)\n (9989, 5935, 0.02432728985151653)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbourlist-Tuple{Box, Any}","page":"Help entries","title":"CellListMap.neighbourlist","text":"neighbourlist(box, cl; parallel=true)\n\nCompute the neighbour list of a single set or set pairs of particles. Returns a vector of tuples with all indices of the particles that are within box.cutoff, and the distances.  \n\nExample\n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02) \nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n  cutoff: 0.02\n  number of computing cells on each dimension: [52, 52, 52]\n  computing cell sizes: [0.02, 0.02, 0.02] (lcell: 1)\n  Total number of cells: 140608\n\njulia> cl = CellList(x,box) # single set\nCellList{3, Float64}\n  999 cells with real particles.\n  1126 particles in computing box, including images.\n\n\njulia> CellListMap.neighbourlist(box,cl,parallel=false)\n15-element Vector{Tuple{Int64, Int64, Float64}}:\n (187, 511, 0.010346860078531755)\n (203, 708, 0.010777737363239403)\n (296, 579, 0.018124283912224655)\n ⋮\n (584, 4, 0.016935844769524398)\n (725, 749, 0.019971874892397875)\n (773, 119, 0.01835233336121765)\n (927, 8, 0.011234110402648743)\n\n\nTo obtain the neighbour list (within the cutoff) between two sets of  particles, initialize the cell lists with the two sets: \n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> y = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02);\n\njulia> cl = CellList(x,y,box)\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   997 cells with real particles of target vector.\n\njulia> CellListMap.neighbourlist(box,cl)\n35-element Vector{Tuple{Int64, Int64, Float64}}:\n (409, 982, 0.01634641594779082)\n (521, 422, 0.00919026348035512)\n (625, 731, 0.012986301890746663)\n ⋮\n (647, 730, 0.01565763971458105)\n (296, 668, 0.016556686306217868)\n (992, 589, 0.018392993428289553)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm-Tuple{Any}","page":"Help entries","title":"CellListMap.norm","text":"norm(v::AbstractVector{T}) where T\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own norm(x) = norm_sqr(x).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.norm_sqr","text":"norm_sqr(v::AbstractVector{T}) where T\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N","page":"Help entries","title":"CellListMap.out_of_bounding_box","text":"out_of_bounding_box(x::SVector{N},box::Box) where N\n\nFunction that evaluates if a particle is outside the computing bounding box, defined by the maximum and minimum unit cell coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N","page":"Help entries","title":"CellListMap.particle_cell","text":"particle_cell(x::SVector{N,T}, box::Box) where {N,T}\n\nReturns the coordinates of the computing cell to which a particle belongs, given its coordinates and the cell_size vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes Box.lcell + 1.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particles_per_cell-Tuple{CellList, Box}","page":"Help entries","title":"CellListMap.particles_per_cell","text":"particles_per_cell(cl::CellList,box::Box)\n\nReturns the average number of particles per computing cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.partition!-Tuple{Any, AbstractVector{T} where T}","page":"Help entries","title":"CellListMap.partition!","text":"partition!(x::AbstractVector,by)\n\nFunction that reorders x vector by putting in the first positions the elements with values satisfying by(el). Returns the number of elements that satisfy the condition.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N, T, TSQ, M} where {T, TSQ, M}}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.project_particles!","text":"project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)\n\nProjects all particles of the cell cellⱼ into unnitary vector Δc with direction  connecting the centers of cellⱼ and cellᵢ. Modifies projected_particles, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T, L} where L}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 2D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T, L} where L}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 3D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reduce-Tuple{Number, Vector{var\"#s48\"} where var\"#s48\"<:Number}","page":"Help entries","title":"CellListMap.reduce","text":"reduce(output::Number, output_threaded::Vector{<:Number})\n\nFunctions to reduce the output of common options (vectors of numbers  and vectors of vectors). This function can be overloaded by custom reduction methods. It always must both receive the output variable as a parameter, and return it at the end.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T} where T, Any, Any}} where N","page":"Help entries","title":"CellListMap.replicate_particle!","text":"replicate_particle!(ip,p::SVector{N},box,cl) where N\n\nReplicates the particle as many times as necessary to fill the computing box.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.reset!","text":"reset!(cl::CellList{N,T},box) where{N,T}\n\nResets a cell list, by setting everything to zero, but retaining the allocated particles and projected_particles vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_nt-Tuple{Any}","page":"Help entries","title":"CellListMap.set_nt","text":"set_nt(cl) = max(1,min(cl.n_real_particles÷500,nthreads()))\n\nDon't use all threads to build cell lists if the number of particles per thread is smaller than 500.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}\n\nTranslate vector x according to the unit_cell_matrix lattice vectors and the indices provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.view_celllist_particles","text":"view_celllist_particles(cl::CellList)\n\nAuxiliary function to view the particles of a computing box, including images created for computing purposes.\n\nExample\n\njulia> box = Box([ 100 50; 50 100 ],10);\n\njulia> x = [ box.unit_cell_max .* rand(SVector{2,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> p = CellListMap.view_celllist_particles(cl);\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),label=nothing,xlims=(-10,180),ylims=(-10,180))\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_cell_fraction-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_cell_fraction","text":"wrap_cell_fraction(x,unit_cell_matrix)\n\nObtaint the coordinates of x as a fraction of unit cell vectors, first positive cell. x is a vector of dimension N and cell a matrix of  dimension NxN\n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_cell_fraction(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 0.5\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector{T} where T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,sides::AbstractVector)\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, for an Orthorhombic cell of which only the side lengths are provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T, TSQ, M} where {TSQ, M}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given an Orthorhombic cell. This is slightly cheaper than for general cells.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T, L} where L}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T, TSQ, M} where {TSQ, M}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given a general Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,unit_cell_matrix)\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. \n\nExample\n\n```julia-repl julia> unitcellmatrix = [ 10 0                             0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wraptofirst(x,unitcellmatrix) 2-element Vector{Float64}:  5.0  3.0000000000000004  ```\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Box}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box)\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given the Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T, TSQ, M} where {TSQ, M}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given an Orthorhombic cell.  This is slightly cheaper than for general cells.  \n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full code of the examples described here is available at the examples directory. ","category":"page"},{"location":"examples/#Mean-difference-of-coordinates","page":"Examples","title":"Mean difference of coordinates","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Computing the mean difference in x position between random particles. The closure is used to remove the indexes and the distance of the particles from the parameters of the input function, as they are not needed in this case.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CellListMap\n\n# System properties\nN = 100_000\nsides = [250,250,250]\ncutoff = 10\n\n# Particle positions\nx = [ sides .* rand(3) for i in 1:N ]\n\n# Initialize linked lists and box structures\nbox = Box(sides,cutoff)\ncl = CellList(x,box)\n\n# Function to be evaluated from positions \nf(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\nnormalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\n# Run calculation (0.0 is the initial value)\navg_dx = normalization * map_pairwise!(\n    (x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl \n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.average_displacement() and is available in the average_displacement.jl file.","category":"page"},{"location":"examples/#Histogram-of-distances","page":"Examples","title":"Histogram of distances","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Computing the histogram of the distances between particles (considering the same particles as in the above example). Again, we use a closure to remove the positions and indexes of the particles from the function arguments, because they are not needed. The distance, on the other side, is needed in this example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function that accumulates the histogram of distances\nfunction build_histogram!(d2,hist)\n    d = sqrt(d2)\n    ibin = floor(Int,d) + 1\n    hist[ibin] += 1\n    return hist\nend;\n\n# Initialize (and preallocate) the histogram\nhist = zeros(Int,10);\nnormalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\n# Run calculation\nhist = normalization * map_pairwise!(\n    (x,y,i,j,d2,hist) -> build_histogram!(d2,hist),\n    hist,box,cl\n)\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.distance_histogram() and is available in the distance_histogram.jl file.","category":"page"},{"location":"examples/#Gravitational-potential","page":"Examples","title":"Gravitational potential","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this test we compute the \"gravitational potential\", assigning to each particle a different mass. In this case, the closure is used to pass the masses to the function that computes the potential.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair \nfunction potential(i,j,d2,mass,u)\n    d = sqrt(d2)\n    u = u - 9.8*mass[i]*mass[j]/d\n    return u\nend\n\n# Run pairwise computation\nu = map_pairwise!((x,y,i,j,d2,u) -> potential(i,j,d2,mass,u),0.0,box,cl)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.gravitational_potential() and is available in the gravitational_potential.jl file.","category":"page"},{"location":"examples/#Gravitational-force","page":"Examples","title":"Gravitational force","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example, we update a force vector of for all particles.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair: update force vector\nfunction calc_forces!(x,y,i,j,d2,mass,forces)\n    G = 9.8*mass[i]*mass[j]/d2\n    d = sqrt(d2)\n    df = (G/d)*(x - y)\n    forces[i] = forces[i] - df\n    forces[j] = forces[j] + df\n    return forces\nend\n\n# Initialize and preallocate forces\nforces = [ zeros(SVector{3,Float64}) for i in 1:N ]\n\n# Run pairwise computation\nforces = map_pairwise!(\n    (x,y,i,j,d2,forces) -> calc_forces!(x,y,i,j,d2,mass,forces),\n    forces,box,cl\n)\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.gravitational_force() and is available in the gravitational_force.jl file.","category":"page"},{"location":"examples/#Nearest-neighbour","page":"Examples","title":"Nearest neighbour","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we compute the indexes of the particles that satisfy the minimum distance between two sets of points, using the linked lists. The distance and the indexes are stored in a tuple, and a reducing method has to be defined for that tuple to run the calculation.  The function does not need the coordinates of the points, only their distance and indexes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Number of particles, sides and cutoff\nN1=1_500\nN2=1_500_000\nsides = [250,250,250]\ncutoff = 10.\nbox = Box(sides,cutoff)\n\n# Particle positions\nx = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N1 ]\ny = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N2 ]\n\n# Initialize auxiliary linked lists\ncl = CellList(x,y,box)\n\n# Function that keeps the minimum distance\nf(i,j,d2,mind) = d2 < mind[3] ? (i,j,d2) : mind\n\n# We have to define our own reduce function here\nfunction reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:Threads.nthreads()\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend\n\n# Initial value\nmind = ( 0, 0, +Inf )\n\n# Run pairwise computation\nmind = map_pairwise!( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind),\n    mind,box,cl;reduce=reduce_mind\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example above can be run with CellListMap.Examples.nearest_neighbour() and is available in the nearest_neighbour.jl file.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example CellListMap.Examples.nearest_neighbour_nopbc() of nearest_neighbour_nopbc.jl describes a similar problem but without periodic boundary conditions. Depending on the distribution of points and size it is a faster method than usual ball-tree methods. ","category":"page"},{"location":"examples/#Neighbour-list","page":"Examples","title":"Neighbour list","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe package provides a neighbourlist function that implements this calculation, and can be used with:julia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> CellListMap.neighbourlist(x,0.05)\n24778-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 62, 0.028481068525796384)\n ⋮\n (9954, 1749, 0.04887502372299809)\n (9974, 124, 0.040110356034451795)or CellListMap.neighbourlist(x,y,r) for computing the lists of pairs of two sets closer than r.The returning array contains tuples with the index of the particle in the first vector, the index of the particle in the second vector, and their distance.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The implementation of the above function follows the principles below.   The empty pairs output array will be split in one vector for each thread, and reduced with a custom reduction function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Function to be evaluated for each pair: push pair\nfunction push_pair!(i,j,d2,pairs)\n    d = sqrt(d2)\n    push!(pairs,(i,j,d))\n    return pairs\nend\n\n# Reduction function\nfunction reduce_pairs(pairs,pairs_threaded)\n    pairs = pairs_threaded[1]\n    for i in 2:Threads.nthreads()\n        append!(pairs,pairs_threaded[i])\n    end\n    return pairs\nend\n\n# Initialize output\npairs = Tuple{Int,Int,Float64}[]\n\n# Run pairwise computation\npairs = map_pairwise!(\n    (x,y,i,j,d2,pairs) -> push_pair!(i,j,d2,pairs),\n    pairs,box,cl,\n    reduce=reduce_pairs\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full example can be run with CellListMap.Examples.neighbourlist(), available in the file  neighbourlist.jl.","category":"page"},{"location":"units_etc/#Units,-automatic-differentiation,-etc.","page":"Units, autodiff, etc.","title":"Units, automatic differentiation, etc.","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The functions of CellListMap.jl support the propagation of generic (isbits) types, and thus units and thus automatic differentiation and the use of Unitful. A set of working examples can be found in the generic_types.jl file.","category":"page"},{"location":"units_etc/#Unitful-and-units","page":"Units, autodiff, etc.","title":"Unitful and units","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"We start illustrating the support for unit propagation. We need to define all involved quantities in the same units:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using Unitful, StaticArrays\n\njulia> cutoff = 0.1u\"nm\" \n0.1 nm\n\njulia> box = Box([1.0, 1.0, 1.0]u\"nm\",cutoff)\nBox{OrthorhombicCell, 3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}, Quantity{Float64, 𝐋^2, Unitful.FreeUnits{(nm^2,), 𝐋^2, nothing}}, 9}\n  unit cell matrix = [ 1.0 nm, 0.0 nm, 0.0 nm; 0.0 nm, 1.0 nm, 0.0 nm; 0.0 nm, 0.0 nm, 1.0 nm ]\n  cutoff = 0.1 nm\n  number of computing cells on each dimension = [12, 12, 12]\n  computing cell sizes = [0.1 nm, 0.1 nm, 0.1 nm] (lcell: 1)\n  Total number of cells = 1728\n\njulia> x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}\n  1000 real particles.\n  626 cells with real particles.\n  1694 particles in computing box, including images.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The corresponding mapping must take care of defining the result in the correct units associated to the expected output. For example, here we will compute just the sum of the squared distances between the particles within the cutoff. Thus, the expected output has the same units as the square of the dimensions: ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> sum_sqr = zero(typeof(cutoff^2))\n0.0 nm^2\n\njulia> sum_sqr = map_pairwise!(\n           (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n           sum_sqr, box, cl\n       )\n12.983283925249138 nm^2","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The performance penalty associated to propagating units is small. With units, we get:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using BenchmarkTools\n\njulia> @btime let x = $x\n           cutoff = 0.1u\"nm\" \n           box = Box([1.0,1.0,1.0]u\"nm\",cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(typeof(cutoff^2))\n           map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n       end\n  1.828 ms (6547 allocations: 1.22 MiB)\n12.983283925249138 nm^2","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"and the same problem without units runs in:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> @btime let x = $([ SVector{3,Float64}(ustrip.(v)) for v in x ])\n           cutoff = 0.1 \n           box = Box([1.0,1.0,1.0],cutoff)\n           cl = CellList(x,box)\n           sum_sqr = 0.\n           map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n       end\n  1.783 ms (6547 allocations: 1.22 MiB)\n12.983283925249138","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Auxiliary functions, like CellListMap.neighbourlist, propagate units correctly:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1u\"nm\"\n0.1 nm\n\njulia> box = Box([1.0, 1.0, 1.0]u\"nm\",cutoff);\n\njulia> x = [ rand(typeof(cutoff),3) for _ in 1:1000 ];\n\njulia> CellListMap.neighbourlist(x,cutoff)\n1796-element Vector{Tuple{Int64, Int64, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}}:\n (1, 583, 0.06456224519583421 nm)\n (10, 216, 0.04958058924623024 nm)\n ⋮\n (934, 615, 0.08834318454969409 nm)\n (934, 692, 0.05002019032986014 nm)","category":"page"},{"location":"units_etc/#Automatic-differentiation","page":"Units, autodiff, etc.","title":"Automatic differentiation","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Allowing automatic differentiation follows the same principles, meaning that we only need to allow the propagation of dual types through the computation by proper initialization of the input data.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The variables are each component of each vector, thus the easiest way to represent the points such that automatic differentiation packages understand is by creating a matrix:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> x = rand(3,1000)\n3×1000 Matrix{Float64}:\n 0.186744  0.328719  0.874102  0.503535   …  0.328161  0.0895699  0.917338\n 0.176157  0.972954  0.80729   0.624724      0.655268  0.470754   0.327578\n 0.648482  0.537362  0.599624  0.0688776     0.92333   0.497984   0.208924","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The key here is allow all the types of the parameters to follow the type propagation of the elements of x inside the differentiation routine. The function we define to compute the derivative is, then:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> function sum_sqr(x,sides,cutoff)\n           cutoff = eltype(x)(cutoff)\n           sides = eltype(x).(sides)\n           box = Box(sides,cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(eltype(x))\n           sum_sqr = map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n           return sum_sqr\n       end\nsum_sqr (generic function with 1 method)","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Note that we allow cutoff  and sides  to be converted to the same type of the input x  of the function. For a simple call to the function this is inconsequential:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1; sides = [1,1,1];\n\njulia> sum_sqr(x,sides,cutoff)\n12.897650398753228","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"but the conversion is required to allow the differentiation to take place:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> ForwardDiff.gradient(x -> sum_sqr(x,sides,cutoff),x)\n3×1000 Matrix{Float64}:\n -0.132567   0.029865  -0.101301  …   0.249267    0.0486424  -0.0400487\n  0.122421   0.207495  -0.184366     -0.201648   -0.105031    0.218342\n  0.0856502  0.288924   0.122445     -0.0147022  -0.103314   -0.0862264","category":"page"},{"location":"units_etc/#Measurements","page":"Units, autodiff, etc.","title":"Measurements","text":"","category":"section"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"Propagating uncertainties through the Measurements  and other similar packages requires a different strategy, because within CellListMap only isbits types can be used, which is not the case of the type Measurement type. ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"In cases like this, it is better to bypass all the internals of CellListMap  and provide the data to the function that computes pairwise properties directly as a closure. For example:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"A vector of particles with uncertainties in their coordinates can be created with: ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using StaticArrays \n\njulia> x_input = [ SVector{3}(measurement(rand(),0.01*rand()) for i in 1:3) for j in 1:1000 ]\n1000-element Vector{SVector{3, Measurement{Float64}}}:\n [0.1658 ± 0.003, 0.9951 ± 0.0054, 0.5067 ± 0.0035]\n [0.2295 ± 0.0074, 0.2987 ± 0.0021, 0.42828 ± 0.00099]\n ⋮\n [0.1362 ± 0.0034, 0.2219 ± 0.0048, 0.2119 ± 0.0072]\n [0.2521 ± 0.0038, 0.4988 ± 0.00013, 0.856046 ± 4.3e-5]","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The variables within the CellListMap functions will be stripped from the uncertainties. We do:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cutoff = 0.1; box = Box([1,1,1],cutoff);\n\njulia> x_strip = [ getproperty.(v,:val) for v in x_input ]\n1000-element Vector{SVector{3, Float64}}:\n [0.08441931492362276, 0.9911530546181084, 0.07408559584648788]\n [0.12084764467339837, 0.8284551316333133, 0.9021906852432111]\n ⋮\n [0.2418752113326077, 0.4429225751775432, 0.13576355747772784]\n [0.24440380524702654, 0.07148275176890073, 0.26722687487212315]","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The cell list is built with the stripped values:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> cl = CellList(x_strip,box)\nCellList{3, Float64}\n  1000 real particles.\n  637 cells with real particles.\n  1695 particles in computing box, including images.","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"The result is initialized with the proper type,","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> sum_sqr = measurement(0.,0.)\n0.0 ± 0.0","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"and the mapping is performed with the stripped coordinates, but passing the values with uncertainties to the mapped function, which will perform the computation on the pairs with those values:","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"julia> using LinearAlgebra: norm_sqr\n\njulia> sum_sqr = map_pairwise!(\n           (xᵢ,xⱼ,i,j,d2,sum_sqr) -> begin\n               x1 = x_input[i]\n               x2 = CellListMap.wrap_relative_to(x_input[j],x1,box)\n               sum_sqr += norm_sqr(x2-x1)\n               return sum_sqr\n           end, \n           sum_sqr, box, cl\n       )\n13.14 ± 0.061","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"In the function above, the xᵢ and xⱼ coordinates, which correspond to the coordinates in x_input[i] and x_input[j], but already wrapped relative to each other, are ignored, because they don't carry the uncertainties. We use only the indexes i and j to recompute the relative position of the particles according to the periodic boundary conditions (using the CellListMap.wrap_relative_to function) and their (squared) distance. Since the x_input  array carries the uncertainties, the computation of sum_sqr will propagate them.   ","category":"page"},{"location":"units_etc/","page":"Units, autodiff, etc.","title":"Units, autodiff, etc.","text":"note: Note\nAll these computations should be performed inside the scope of a function for optimal performance. The examples here can be followed by copying and pasting the code into the REPL, but this is not the recommended practice for critical code. The strategy of bypassing the internal computations of CellListMap may be useful for improving performance even if the previous and simpler method is possible. ","category":"page"},{"location":"options/#Additional-options","page":"Options","title":"Additional options","text":"","category":"section"},{"location":"options/#Input-coordinates-as-matrices","page":"Options","title":"Input coordinates as matrices","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"For compatibility with other software, the input coordinates can be provided as matrices. The matrices must have dimensions (2,N) or (3,N), where N is the number of particles (because Julia is column-major, thus this has the same memory layout of an array of length N of static vectors). ","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"For example:","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"julia> x = rand(3,100);\n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100 real particles.\n  99 cells with real particles.\n  162 particles in computing box, including images.\n\njulia> map_pairwise!((x,y,i,j,d2,n) -> n += 1, 0, box, cl) # count neighbours\n23","category":"page"},{"location":"reference/#Citation","page":"Reference","title":"Citation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"If you use this software and need to cite it, please use the following reference:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Martínez, Leandro. (2021, June 11). CellListMap.jl: Flexible implementation of cell lists to map the calculations of short-ranged particle-pair dependent functions, such as forces, energies, neighbour lists, etc. Zenodo. http://doi.org/10.5281/zenodo.4927541","category":"page"},{"location":"#CellListMap.jl","page":"Overview","title":"CellListMap.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package is for computing interactions or any other property that is dependent on the distances between pairs of two- or three-dimensional particles, within a cutoff. It maps a function to be computed pairwise using cell lists, using periodic boundary conditions of any type. Parallel and serial implementations can be used. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It allows the fast computation of any quantity from the pairs that are within the desired cutoff, for example an average distance or an histogram of distances, forces, potentials, minimum distances, etc., as the examples below illustrate. This is done by passing the function to be evaluated as a parameter of the map_pairwise! function. ","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> import Pkg\n\njulia> Pkg.add(\"CellListMap\")\n","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The main function is map_parwise!: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If the analysis is performed on the pairs of a single vector x (n*(n-1)/2 pairs), the function can be called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellList)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"while if two distinct sets of points are provided (n*m pairs), it is called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where the cl variable of type CellList or CellListPair contains the cell lists built from the coordinates of the system, and box contains the system box properties.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"These functions will run over every pair of particles which are closer than box.cutoff and compute the (squared) Euclidean distance between the particles, considering the periodic boundary conditions given in the Box structure. If the distance is smaller than the cutoff, a user defined function f of the coordinates of the two particles will be computed. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The function f receives six arguments as input: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f(x,y,i,j,d2,output)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Which are the coordinates of one particle, the coordinates of the second particle, the index of the first particle, the index of the second particle, the squared distance between them, and the output variable. It has also to return the same output variable. Thus, f may or not mutate output, but in either case it must return it.  The squared distance d2 is computed   internally for comparison with the cutoff, and is passed to the f because many times it is used for the desired computation. Thus, the function f that is passed to map_pairwise! must be always of the form:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"function f(x,y,i,j,d2,output)\n    # update output\n    return output\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and the user can define more or less parameters or additional data required to compute the function using closures, as shown in the examples.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Parallel calculations are the default if more than one thread is available. Use parallel=false as an optional argument to map_pairwise! to run the serial version instead.","category":"page"},{"location":"pbc/#Periodic-boundary-conditions","page":"Periodic conditions","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"pbc/#Orthorhombic-periodic-boundary-conditions","page":"Periodic conditions","title":"Orthorhombic periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Orthorhombic periodic boundary conditions allow some special methods that are faster than those for general cells. To initialize an Orthorhombic cell, just provide the length of the cell on each side, and the cutoff. For example:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([100,70,130],12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 0.0 0.0; 0.0 70.0 0.0; 0.0 0.0 130.0]\n  cutoff: 12.0\n  number of computing cells on each dimension: [10, 7, 12]\n  computing cell sizes: [12.5, 14.0, 13.0] (lcell: 1)\n  Total number of cells: 840","category":"page"},{"location":"pbc/#Triclinic-periodic-boundary-conditions","page":"Periodic conditions","title":"Triclinic periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Triclinic periodic boundary conditions of any kind can be used. However, the input has some limitations for the moment. The lattice vectors must have strictly positive coordinates, and the smallest distance within the cell cannot be smaller than twice the size of the cutoff. An error will be produced if the cell does not satisfy these conditions. ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Let us illustrate building a two-dimensional cell, for easier visualization. A matrix of column-wise lattice vectors is provided in the construction of the box, and that is all. ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Here, the lattice vectors are [1,0] and [0.5,1] (and we illustrate with cutoff=0.1): ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([ 1.0  0.5\n                     0  1.0 ], 0.1);\n\njulia> x = 10*rand(SVector{2,Float64},1000);","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"We have created random coordinates for 1000 particles, that are not necessarily wrapped according to the periodic boundary conditions. We can see the coordinates in the minimum image cell with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> using Plots\n\njulia> CellListMap.draw_computing_cell(x,box)","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/lattice.png>","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"The construction of the cell list is, as always, done with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> cl = CellList(x,box)\nCellList{2, Float64}\n  109 cells with real particles.\n  2041 particles in computing box, including images.\n","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Upon construction of the cell lists, the particles are replicated to fill a rectangular box (or orthorhombic box, in three-dimensions), with boundaries that exceed the actual system size. This improves the performance of the pairwise computations by avoiding the necessity of wrapping coordinates on the main loop (this is an implementation detail only). ","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"In summary, to use arbitrary periodic boundary conditions, just initialize the box with the matrix of lattice vectors. In three dimensions, for example, one could use:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> box = Box([ 50.  0. 00. \n                    0. 30. 30.          \n                    0. 00. 50. ],  2.)\n\njulia> x = 100*rand(SVector{3,Float64},10000);\n\njulia> p = [ CellListMap.wrap_to_first(x,box) for x in x ];\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),aspect_ratio=1,framestyle=:box,label=:none)","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"to work with an arbitrary 3D lattice, Which in this case looks like:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/3Dlattice.png>","category":"page"},{"location":"pbc/#Without-periodic-boundary-conditions","page":"Periodic conditions","title":"Without periodic boundary conditions","text":"","category":"section"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"To avoid the use of periodic boundary conditions it is enough to define an Orthorhombic box with lengths in each direction that are larger than the limits of the coordinates of the particles plus the cutoff. This can be done automatically with the limits function. The box must be constructed with:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [111.99749159163106 0.0 0.0; 0.0 111.99757156637344 0.0; 0.0 0.0 111.99910298572958]\n  cutoff: 12.0\n  number of computing cells on each dimension: [11, 11, 11]\n  computing cell sizes: [12.444165732403452, 12.444174618485938, 12.444344776192175] (lcell: 1)\n  Total number of cells: 1331","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"or, for computing the interaction between two disjoint sets of particles, call the limits function with two arguments:","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> y = [ [120,180,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [131.9978650409108 0.0 0.0; 0.0 191.99730748624336 0.0; 0.0 0.0 111.99917288242698]\n  cutoff: 12.0\n  number of computing cells on each dimension: [12, 17, 11]\n  computing cell sizes: [13.19978650409108, 12.799820499082891, 12.444352542491886] (lcell: 1)\n  Total number of cells: 2244","category":"page"},{"location":"pbc/","page":"Periodic conditions","title":"Periodic conditions","text":"Note that the unit cell length is, on each direction, the maximum coordinates of all particles plus the cutoff. This will avoid the computation of pairs of periodic images. The algorithms used for computing interactions in Orthorhombic cells will then be used.","category":"page"}]
}
