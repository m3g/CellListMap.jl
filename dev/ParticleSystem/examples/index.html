<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Complete examples · CellListMap.jl</title><meta name="title" content="Complete examples · CellListMap.jl"/><meta property="og:title" content="Complete examples · CellListMap.jl"/><meta property="twitter:title" content="Complete examples · CellListMap.jl"/><meta name="description" content="Documentation for CellListMap.jl."/><meta property="og:description" content="Documentation for CellListMap.jl."/><meta property="twitter:description" content="Documentation for CellListMap.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CellListMap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><a class="tocitem" href="../../neighborlists/">Neighbor lists</a></li><li><a class="tocitem" href="../introduction/">ParticleSystem</a></li><li><a class="tocitem" href="../single_set_simple/">Single set: Simple outputs</a></li><li><a class="tocitem" href="../single_set_compound/">Single set: Compound outputs</a></li><li><a class="tocitem" href="../two_sets/">Two sets of particles</a></li><li><a class="tocitem" href="../updating/">Updating the system</a></li><li><a class="tocitem" href="../options/">Options</a></li><li class="is-active"><a class="tocitem" href>Complete examples</a><ul class="internal"><li><a class="tocitem" href="#Simple-energy-computation"><span>Simple energy computation</span></a></li><li><a class="tocitem" href="#Force-computation"><span>Force computation</span></a></li><li><a class="tocitem" href="#Energy-and-forces"><span>Energy and forces</span></a></li><li><a class="tocitem" href="#Two-sets-of-particles"><span>Two sets of particles</span></a></li><li><a class="tocitem" href="#Particle-simulation"><span>Particle simulation</span></a></li></ul></li><li><a class="tocitem" href="../../unitcell/">Unitcell requirements</a></li><li><a class="tocitem" href="../../ecosystem/">Ecosystem integration</a></li><li><a class="tocitem" href="../../API/">Public Interface</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li><li><a class="tocitem" href="../../migrating/">Migrating from 0.9</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Complete examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Complete examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl/blob/main/docs/src/ParticleSystem/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Complete-examples"><a class="docs-heading-anchor" href="#Complete-examples">Complete examples</a><a id="Complete-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-examples" title="Permalink"></a></h1><p>This section contains complete, self-contained example codes that can be copied and run directly.</p><h2 id="Simple-energy-computation"><a class="docs-heading-anchor" href="#Simple-energy-computation">Simple energy computation</a><a id="Simple-energy-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-energy-computation" title="Permalink"></a></h2><p>In this example, a simple potential energy defined as the sum of the inverse of the distance between the particles is computed.</p><pre><code class="language-julia hljs">using CellListMap
using StaticArrays
system = ParticleSystem(
    xpositions = rand(SVector{3,Float64},1000),
    unitcell=[1.0,1.0,1.0],
    cutoff = 0.1,
    output = 0.0,
    output_name = :energy
)
pairwise!((pair, energy) -&gt; energy += 1 / pair.d, system)</code></pre><h2 id="Force-computation"><a class="docs-heading-anchor" href="#Force-computation">Force computation</a><a id="Force-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Force-computation" title="Permalink"></a></h2><p>Here we compute the force vector associated to the potential energy function of the previous example.</p><pre><code class="language-julia hljs">using CellListMap
using StaticArrays
positions = rand(SVector{3,Float64},1000)
system = ParticleSystem(
    xpositions = positions,
    unitcell=[1.0,1.0,1.0],
    cutoff = 0.1,
    output = similar(positions),
    output_name = :forces
)
function update_forces!(pair, forces)
    (; x, y, i, j, d2, d) = pair
    df = (1/d2)*(1/d)*(y - x)
    forces[i] += df
    forces[j] -= df
    return forces
end
pairwise!(update_forces!, system)</code></pre><h2 id="Energy-and-forces"><a class="docs-heading-anchor" href="#Energy-and-forces">Energy and forces</a><a id="Energy-and-forces-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-and-forces" title="Permalink"></a></h2><p>In this example, the potential energy and the forces are computed in a single run, and a custom data structure is defined to store both values.</p><pre><code class="language-julia hljs">using CellListMap
using StaticArrays
# Define custom type
mutable struct EnergyAndForces
    energy::Float64
    forces::Vector{SVector{3,Float64}}
end
# Custom copy, reset and reducer functions
import CellListMap: copy_output, reset_output!, reducer
copy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))
function reset_output!(output::EnergyAndForces)
    output.energy = 0.0
    for i in eachindex(output.forces)
        output.forces[i] = SVector(0.0, 0.0, 0.0)
    end
    return output
end
function reducer(x::EnergyAndForces, y::EnergyAndForces)
    e_tot = x.energy + y.energy
    x.forces .+= y.forces
    return EnergyAndForces(e_tot, x.forces)
end
# Function that updates energy and forces for each pair
function energy_and_forces!(pair, output::EnergyAndForces)
    (; i, j, x, y, d2, d) = pair
    output.energy += 1/d
    df = (1/d2)*(1/d)*(y - x)
    output.forces[i] += df
    output.forces[j] -= df
    return output
end
# Initialize system
positions = rand(SVector{3,Float64},1000);
system = ParticleSystem(
    xpositions = positions,
    unitcell=[1.0,1.0,1.0],
    cutoff = 0.1,
    output = EnergyAndForces(0.0, similar(positions)),
    output_name = :energy_and_forces
)
# Compute energy and forces
pairwise!(energy_and_forces!, system)</code></pre><h2 id="Two-sets-of-particles"><a class="docs-heading-anchor" href="#Two-sets-of-particles">Two sets of particles</a><a id="Two-sets-of-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Two-sets-of-particles" title="Permalink"></a></h2><p>In this example we illustrate the interface for the computation of properties of two sets of particles, by computing the minimum distance between the two sets.</p><pre><code class="language-julia hljs">using CellListMap
using StaticArrays
# Custom structure to store the minimum distance pair
struct MinimumDistance
    i::Int
    j::Int
    d::Float64
end
# Function that updates the minimum distance found
function minimum_distance(pair, md)
    (; i, j, d) = pair
    if d &lt; md.d
        md = MinimumDistance(i, j, d)
    end
    return md
end
# Define appropriate methods for copy, reset and reduce
import CellListMap: copy_output, reset_output!, reducer!
copy_output(md::MinimumDistance) = md
reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)
reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d &lt; md2.d ? md1 : md2
# Build system
xpositions = rand(SVector{3,Float64},100);
ypositions = rand(SVector{3,Float64},1000);
system = ParticleSystem(
       xpositions = xpositions,
       ypositions = ypositions,
       unitcell=[1.0,1.0,1.0],
       cutoff = 0.1,
       output = MinimumDistance(0,0,+Inf),
       output_name = :minimum_distance,
)
# Compute the minimum distance
pairwise!(minimum_distance, system)</code></pre><p>In the above example, the function is used such that cell lists are constructed for both sets. There are situations where this is not optimal, in particular:</p><ol><li>When one of the sets if very small. In this case, constructing a cell list for the largest set becomes the bottleneck. Therefore, it is better to construct a cell list for the smallest set and loop over the particles of the largest set.</li><li>When one of the set is fixed and the second set is variable. In this case, it is better to construct the cell list for the fixed set only and loop over the variables of the variable set.</li></ol><p>For dealing with these possibilities, an additional two-set interface is available, where one maps the computation over an array of particles relative to a previously computed cell list. Complementing the example above, we could compute the same minimum distance using:</p><pre><code class="language-julia hljs"># Construct the cell list system only for one of the sets: ypositions
ysystem = ParticleSystem(
       positions = ypositions,
       unitcell=[1.0,1.0,1.0],
       cutoff = 0.1,
       output = MinimumDistance(0,0,+Inf),
       output_name = :minimum_distance,
)
# obtain the minimum distance between xpositions and the cell list in system
# Note the additional `xpositions` parameter in the call to pairwise.
pairwise!(get_md, xpositions, ysystem)</code></pre><p>Additionally, if the <code>xpositions</code> are updated, we can obtain compute the function relative to <code>ysystem</code> without having to update the cell lists:</p><pre><code class="language-julia-repl hljs">julia&gt; xpositions = rand(SVector{3,Float64},100);

julia&gt; pairwise!(minimum_distance, xpositions, ysystem)
MinimumDistance(67, 580, 0.008423693268450603)</code></pre><p>while with the two-set cell list system one would need to update the cell lists for this new computation.</p><div class="admonition is-compat" id="Compat-6c2f10c08188a248"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-6c2f10c08188a248" title="Permalink"></a></header><div class="admonition-body"><p>The single-set cross-interaction was introduced in v0.10.0. It uses the method previously implemented for all cross-interactions.</p></div></div><h2 id="Particle-simulation"><a class="docs-heading-anchor" href="#Particle-simulation">Particle simulation</a><a id="Particle-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-simulation" title="Permalink"></a></h2><p>In this example, a complete particle simulation is illustrated, with a simple potential.  This example can illustrate how particle positions and forces can be updated. Run this simulation with:</p><pre><code class="language-julia-repl hljs">julia&gt; system = init_system(N=200); # number of particles

julia&gt; trajectory = simulate(system);

julia&gt; animate(trajectory)</code></pre><p>One important characteristic of this example is that the <code>system</code> is built outside the function that performs the simulation. This is done because the construction of the system is type-unstable (it is dimension, geometry and output-type dependent). Adding a function barrier avoids type-instabilities to propagate to the simulation causing possible performance problems.</p><pre><code class="language-julia hljs">using StaticArrays
using CellListMap
import CellListMap.wrap_relative_to
# Function that updates the forces, for potential of the form:
# if d &lt; cutoff k*(d^2-cutoff^2)^2 else 0.0 with k = 10^6
function update_forces!(pair, forces, cutoff)
    (;i, j, x, y, d2) = pair
    r = y - x
    dudr = 10^6 * 4 * r * (d2 - cutoff^2)
    forces[i] += dudr
    forces[j] -= dudr
    return forces
end
# Function that initializes the system: it is preferable to initialize
# the system outside the function that performs the simulation, because
# the system (data)type is defined on initialization. Initializing it outside
# the simulation function avoids possible type-instabilities.
function init_system(;N::Int=200)
    Vec2D = SVector{2,Float64}
    positions = rand(Vec2D, N)
    unitcell = [1.0, 1.0]
    cutoff = 0.1
    system = ParticleSystem(
        positions=positions,
        cutoff=cutoff,
        unitcell=unitcell,
        output=similar(positions),
        output_name=:forces,
    )
    return system
end
function simulate(system=init_system(); nsteps::Int=100, isave=1)
    # initial velocities
    velocities = [ randn(eltype(system.positions)) for _ in 1:length(system.positions) ]
    dt = 1e-3
    trajectory = typeof(system.positions)[]
    for step in 1:nsteps
        # compute forces at this step
        pairwise!(
            (pair, forces) -&gt; update_forces!(pair, forces, system.cutoff),
            system
        )
        # Update positions and velocities
        for i in eachindex(system.positions, system.forces)
            f = system.forces[i]
            x = system.positions[i]
            v = velocities[i]
            x = x + v * dt + (f / 2) * dt^2
            v = v + f * dt
            # wrapping to origin for obtaining a pretty animation
            x = wrap_relative_to(x, SVector(0.0, 0.0), system.unitcell)
            # !!! IMPORTANT: Update arrays of positions and velocities
            system.positions[i] = x
            velocities[i] = v
        end
        # Save step for printing
        if step % isave == 0
            push!(trajectory, copy(system.positions))
        end
    end
    return trajectory
end

using Plots
function animate(trajectory)
    anim = @animate for step in trajectory
        scatter(
            Tuple.(step),
            label=nothing,
            lims=(-0.5, 0.5),
            aspect_ratio=1,
            framestyle=:box,
        )
    end
    gif(anim, &quot;simulation.gif&quot;, fps=10)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../options/">« Options</a><a class="docs-footer-nextpage" href="../../unitcell/">Unitcell requirements »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 22:28">Wednesday 18 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
