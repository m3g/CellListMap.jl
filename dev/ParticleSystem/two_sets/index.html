<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Two sets of particles · CellListMap.jl</title><meta name="title" content="Two sets of particles · CellListMap.jl"/><meta property="og:title" content="Two sets of particles · CellListMap.jl"/><meta property="twitter:title" content="Two sets of particles · CellListMap.jl"/><meta name="description" content="Documentation for CellListMap.jl."/><meta property="og:description" content="Documentation for CellListMap.jl."/><meta property="twitter:description" content="Documentation for CellListMap.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CellListMap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><a class="tocitem" href="../../neighborlists/">Neighbor lists</a></li><li><a class="tocitem" href="../introduction/">ParticleSystem</a></li><li><a class="tocitem" href="../single_set_simple/">Single set: Simple outputs</a></li><li><a class="tocitem" href="../single_set_compound/">Single set: Compound outputs</a></li><li class="is-active"><a class="tocitem" href>Two sets of particles</a><ul class="internal"><li><a class="tocitem" href="#Minimum-distance-example"><span>Minimum-distance example</span></a></li><li><a class="tocitem" href="#Cross-interactions-with-two-cell-lists"><span>Cross-interactions with two cell lists</span></a></li><li><a class="tocitem" href="#Cross-interactions-with-a-single-cell-list"><span>Cross-interactions with a single cell list</span></a></li><li><a class="tocitem" href="#Benchmarking-of-cross-interaction-alternatives"><span>Benchmarking of cross-interaction alternatives</span></a></li></ul></li><li><a class="tocitem" href="../updating/">Updating the system</a></li><li><a class="tocitem" href="../options/">Options</a></li><li><a class="tocitem" href="../examples/">Complete examples</a></li><li><a class="tocitem" href="../../unitcell/">Unitcell requirements</a></li><li><a class="tocitem" href="../../ecosystem/">Ecosystem integration</a></li><li><a class="tocitem" href="../../API/">Public Interface</a></li><li><a class="tocitem" href="../../citation/">Citation</a></li><li><a class="tocitem" href="../../migrating/">Migrating from 0.9</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Two sets of particles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Two sets of particles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl/blob/main/docs/src/ParticleSystem/two_sets.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Two-sets-of-particles"><a class="docs-heading-anchor" href="#Two-sets-of-particles">Two sets of particles</a><a id="Two-sets-of-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Two-sets-of-particles" title="Permalink"></a></h1><p>If the computation involves two sets of particles, a similar interface is available. The only difference is that the coordinates of the two sets must be provided to the <code>ParticleSystem</code> constructor as the <code>xpositions</code> and <code>ypositions</code> arrays.</p><h2 id="Minimum-distance-example"><a class="docs-heading-anchor" href="#Minimum-distance-example">Minimum-distance example</a><a id="Minimum-distance-example-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-distance-example" title="Permalink"></a></h2><p>We will illustrate this interface by computing the minimum distance between two sets of particles, which allows us to showcase further the definition of custom type interfaces:</p><pre><code class="language-julia hljs">using CellListMap, StaticArrays</code></pre><p>First, we define a variable type that will carry the indexes and the distance of the closest pair of particles:</p><pre><code class="language-julia hljs">struct MinimumDistance
    i::Int
    j::Int
    d::Float64
end</code></pre><p>The function that, given two particles, retains the minimum distance, is:</p><pre><code class="language-julia hljs">function minimum_distance(pair, md)
    (; i, j, d) = pair
    if d &lt; md.d
        md = MinimumDistance(i, j, d)
    end
    return md
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">minimum_distance (generic function with 1 method)</code></pre><p>We overload <code>copy</code>, <code>reset</code>, and <code>reducer</code> functions, accordingly:</p><pre><code class="language-julia hljs">import CellListMap: copy_output, reset_output!, reducer!
copy_output(md::MinimumDistance) = md</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">copy_output (generic function with 5 methods)</code></pre><pre><code class="language-julia hljs">reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reset_output! (generic function with 6 methods)</code></pre><pre><code class="language-julia hljs">reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d &lt; md2.d ? md1 : md2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reducer! (generic function with 4 methods)</code></pre><p>Note that since <code>MinimumDistance</code> is immutable, copying it is the same as returning the value. Also, resetting the minimum distance consists of setting its <code>d</code> field to <code>+Inf</code>. And, finally, reducing the threaded distances consists of keeping the pair with the shortest distance.</p><h2 id="Cross-interactions-with-two-cell-lists"><a class="docs-heading-anchor" href="#Cross-interactions-with-two-cell-lists">Cross-interactions with two cell lists</a><a id="Cross-interactions-with-two-cell-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-interactions-with-two-cell-lists" title="Permalink"></a></h2><p>Next, we build the system. Here we choose to provide both sets of particles to the <code>ParticleSystem</code> constructor, which means that cell lists will be built for both sets:</p><pre><code class="language-julia hljs">xpositions = rand(SVector{3,Float64},1000);
ypositions = rand(SVector{3,Float64},1000);
system = ParticleSystem(
   xpositions = xpositions,
   ypositions = ypositions,
   unitcell=[1.0,1.0,1.0],
   cutoff = 0.1,
   output = MinimumDistance(0,0,+Inf),
   output_name = :minimum_distance,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleSystem2{minimum_distance} of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0 ]
      cutoff = 0.1
      number of computing cells on each dimension = [13, 13, 13]
      computing cell sizes = [0.1, 0.1, 0.1] (lcell: 1)
      Total number of cells = 2197
    CellListMap.CellListPair{3, Float64}
       627 cells with real particles of the smallest set.
       628 cells with real particles of the largest set.
    Parallelization auxiliary data set for 8 batch(es).
    Type of output variable (minimum_distance): Main.MinimumDistance</code></pre><p>And finally we can obtain the minimum distance between the sets:</p><pre><code class="language-julia hljs">pairwise!(minimum_distance, system)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MinimumDistance(558, 21, 0.003362490614117385)</code></pre><h2 id="Cross-interactions-with-a-single-cell-list"><a class="docs-heading-anchor" href="#Cross-interactions-with-a-single-cell-list">Cross-interactions with a single cell list</a><a id="Cross-interactions-with-a-single-cell-list-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-interactions-with-a-single-cell-list" title="Permalink"></a></h2><p>The two-set interface above builds cell lists for both sets. There are situations where this is not optimal:</p><ol><li><strong>One set is fixed, the other changes.</strong> If <code>ypositions</code> never changes but <code>xpositions</code> is updated each step, rebuilding a cell list for <code>ypositions</code> every time is wasteful. Build it once and reuse.</li><li><strong>One set is much smaller.</strong> Building a cell list for a very large set can be expensive. Build the cell list only for the smaller set and iterate over the larger set directly.</li></ol><p>For these cases, construct a <code>ParticleSystem</code> for the <em>reference</em> set (the one whose cell list you want to keep), then pass the <em>other</em> set as a plain array to <code>pairwise</code>:</p><p>Build the system only for ypositions (the reference set):</p><pre><code class="language-julia hljs">ysystem = ParticleSystem(
    positions = ypositions,
    unitcell = [1.0, 1.0, 1.0],
    cutoff = 0.1,
    output = MinimumDistance(0, 0, +Inf),
    output_name = :minimum_distance,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleSystem1{minimum_distance} of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0 ]
      cutoff = 0.1
      number of computing cells on each dimension = [13, 13, 13]
      computing cell sizes = [0.1, 0.1, 0.1] (lcell: 1)
      Total number of cells = 2197
    CellListMap.CellList{3, Float64}
      1000 real particles.
      628 cells with real particles.
      1747 particles in computing box, including images.
    Parallelization auxiliary data set for 8 batch(es).
    Type of output variable (minimum_distance): Main.MinimumDistance</code></pre><p>Compute interactions between xpositions and the cell list in ysystem. Note: <code>xpositions</code> is passed as a plain array, before the system argument.</p><pre><code class="language-julia hljs">pairwise!(minimum_distance, xpositions, ysystem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MinimumDistance(558, 21, 0.003362490614117385)</code></pre><p>When <code>xpositions</code> changes, the cell list in <code>ysystem</code> does not need to be rebuilt:</p><pre><code class="language-julia hljs">xpositions = rand(SVector{3,Float64}, 100);  # new positions
pairwise!(minimum_distance, xpositions, ysystem; update_lists=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MinimumDistance(53, 263, 0.006980951860473764)</code></pre><p>The <code>update_lists=false</code> keyword skips updating the cell list of <code>ysystem</code>, since only <code>xpositions</code> changed. If <code>ysystem.positions</code> itself changed, use <code>update_lists=true</code> (the default).</p><div class="admonition is-compat" id="Compat-315dd72820eaaf55"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-315dd72820eaaf55" title="Permalink"></a></header><div class="admonition-body"><p>The single-set cross-interaction interface (<code>pairwise!(f, x, system)</code>) was introduced in v0.10.0.</p></div></div><h2 id="Benchmarking-of-cross-interaction-alternatives"><a class="docs-heading-anchor" href="#Benchmarking-of-cross-interaction-alternatives">Benchmarking of cross-interaction alternatives</a><a id="Benchmarking-of-cross-interaction-alternatives-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking-of-cross-interaction-alternatives" title="Permalink"></a></h2><p>With the following functions we will benchmark the performance of the two alternatives for computing cross-set interactions, <strong>including</strong> the time required to build the cell lists (the initialization of the <code>ParticleSystem</code>) objects:</p><h3 id="First-alternative:-compute-cell-lists-for-the-two-sets"><a class="docs-heading-anchor" href="#First-alternative:-compute-cell-lists-for-the-two-sets">First alternative: compute cell lists for the two sets</a><a id="First-alternative:-compute-cell-lists-for-the-two-sets-1"></a><a class="docs-heading-anchor-permalink" href="#First-alternative:-compute-cell-lists-for-the-two-sets" title="Permalink"></a></h3><pre><code class="language-julia hljs">function two_set_celllist(xpositions, ypositions)
   system = ParticleSystem(
       xpositions = xpositions,
       ypositions = ypositions,
       unitcell=[1.0,1.0,1.0],
       cutoff = 0.1,
       output = MinimumDistance(0,0,+Inf),
       output_name = :minimum_distance,
    )
    return pairwise!(minimum_distance, system)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">two_set_celllist (generic function with 1 method)</code></pre><h3 id="Second-alternative:-compute-cell-lists-for-one-set"><a class="docs-heading-anchor" href="#Second-alternative:-compute-cell-lists-for-one-set">Second alternative: compute cell lists for one set</a><a id="Second-alternative:-compute-cell-lists-for-one-set-1"></a><a class="docs-heading-anchor-permalink" href="#Second-alternative:-compute-cell-lists-for-one-set" title="Permalink"></a></h3><pre><code class="language-julia hljs">function one_set_celllist(xpositions, ypositions)
   system = ParticleSystem(
       positions = ypositions,
       unitcell=[1.0,1.0,1.0],
       cutoff = 0.1,
       output = MinimumDistance(0,0,+Inf),
       output_name = :minimum_distance,
    )
    return pairwise!(minimum_distance, xpositions, system)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">one_set_celllist (generic function with 1 method)</code></pre><p>If one of the sets is small, the one-set alternative is clearly faster, if we construct the cell lists for the smaller set:</p><pre><code class="language-julia hljs">using BenchmarkTools
xpositions = rand(SVector{3,Float64}, 10^5);
ypositions = rand(SVector{3,Float64}, 100);
@benchmark one_set_celllist($xpositions, $ypositions) samples=1 evals=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation per sample.
 Single result which took <span class="sgr34">6.991 ms</span> (0.00% GC) to evaluate,
 with a memory estimate of <span class="sgr33">581.78 KiB</span>, over <span class="sgr33">1353</span> allocations.</code></pre><pre><code class="language-julia hljs">@benchmark two_set_celllist($xpositions, $ypositions) samples=1 evals=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation per sample.
 Single result which took <span class="sgr34">72.591 ms</span> (0.00% GC) to evaluate,
 with a memory estimate of <span class="sgr33">81.93 MiB</span>, over <span class="sgr33">86204</span> allocations.</code></pre><p>If both sets are large, though, the computation of the cell lists become less relevant and the first alternative might be the most favorable, even including the cell lists updates:</p><pre><code class="language-julia hljs">xpositions = rand(SVector{3,Float64}, 10^5);
ypositions = rand(SVector{3,Float64}, 10^5);
@benchmark one_set_celllist($xpositions, $ypositions) samples=1 evals=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation per sample.
 Single result which took <span class="sgr34">416.408 ms</span> (0.00% GC) to evaluate,
 with a memory estimate of <span class="sgr33">80.87 MiB</span>, over <span class="sgr33">84677</span> allocations.</code></pre><pre><code class="language-julia hljs">@benchmark two_set_celllist($xpositions, $ypositions) samples=1 evals=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1 sample with 1 evaluation per sample.
 Single result which took <span class="sgr34">318.814 ms</span> (0.00% GC) to evaluate,
 with a memory estimate of <span class="sgr33">161.29 MiB</span>, over <span class="sgr33">169307</span> allocations.</code></pre><p>This performance advantage of the two-set cell lists arises because more interactions can be skipped by <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/jcc.20563">precomputing properties of the cells involved</a>. On the other side, when the lists are available for only one set, the loop over all the particles of the second set is mandatory. Since this loop is fast, it is favorable over the construction of the cell lists for smaller sets.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../single_set_compound/">« Single set: Compound outputs</a><a class="docs-footer-nextpage" href="../updating/">Updating the system »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 23:34">Tuesday 3 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
