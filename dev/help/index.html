<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Help entries · CellListMap.jl</title><meta name="title" content="Help entries · CellListMap.jl"/><meta property="og:title" content="Help entries · CellListMap.jl"/><meta property="twitter:title" content="Help entries · CellListMap.jl"/><meta name="description" content="Documentation for CellListMap.jl."/><meta property="og:description" content="Documentation for CellListMap.jl."/><meta property="twitter:description" content="Documentation for CellListMap.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../ParticleSystem/">ParticleSystem interface</a></li><li><a class="tocitem" href="../neighborlists/">Neighbor lists</a></li><li><a class="tocitem" href="../LowLevel/">Low level interface</a></li><li><a class="tocitem" href="../ecosystem/">Ecosystem integration</a></li><li><a class="tocitem" href="../python/">From Python</a></li><li class="is-active"><a class="tocitem" href>Help entries</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Help entries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Help entries</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl/blob/main/docs/src/help.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Help-entries"><a class="docs-heading-anchor" href="#Help-entries">Help entries</a><a id="Help-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Help-entries" title="Permalink"></a></h1><p>These entries can be viewed at the <code>Julia</code> REPL <code>Julia</code> using </p><pre><code class="language-julia-repl hljs">julia&gt; ? 
help?&gt; function_name</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}" href="#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellListPair{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type for lists of disjoint particle sets,  to be passed to <code>UpdateCellList!</code> for in-place update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L395-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellList{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type, to be passed to <code>UpdateCellList!</code> for in-place  update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for _ in 1:100_000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L318-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T" href="#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(unitcell::Limits, cutoff; lcell::Int=1)</code></pre><p>This constructor receives the output of <code>limits(x)</code> or <code>limits(x,y)</code> where <code>x</code> and <code>y</code> are the coordinates of the particles involved, and constructs a <code>Box</code> with size larger than the maximum coordinates ranges of all particles plus twice the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is an <code>NonPeriodicCell</code> box type, which internally is treated as Orthorhombic with boundaries that guarantee that particles do not see images of each other. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x),10)
Box{NonPeriodicCell, 3}
  unit cell matrix = [ 110.0, 0.0, 0.0; 0.0, 110.0, 0.0; 0.0, 0.0, 110.0 ]
  cutoff = 10.0
  number of computing cells on each dimension = [12, 12, 12]
  computing cell sizes = [11.0, 11.0, 11.0] (lcell: 1)
  Total number of cells = 1728

julia&gt; y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x,y),10)
Box{NonPeriodicCell, 3}
  unit cell matrix = [ 160.0, 0.0, 0.0; 0.0, 160.0, 0.0; 0.0, 0.0, 110.0 ]
  cutoff = 10.0
  number of computing cells on each dimension = [17, 17, 12]
  computing cell sizes = [10.67, 10.67, 11.0] (lcell: 1)
  Total number of cells = 3468</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/Box.jl#L345-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(unit_cell_matrix::AbstractMatrix, cutoff, lcell::Int=1, UnitCellType=TriclinicCell)</code></pre><p>Construct box structure given the cell matrix of lattice vectors. This  constructor will always return a <code>TriclinicCell</code> box type, unless the <code>UnitCellType</code> parameter is set manually to <code>OrthorhombicCell</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell = [ 100   50    0 
                       0  120    0
                       0    0  130 ];

julia&gt; box = Box(unit_cell,10)
Box{TriclinicCell, 3, Float64, 9}
  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]
  cutoff: 10.0
  number of computing cells on each dimension: [17, 14, 15]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 3570
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/Box.jl#L158-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(sides::AbstractVector, cutoff, lcell::Int=1, UnitCellType=OrthorhombicCell)</code></pre><p>For orthorhombic unit cells, <code>Box</code> can be initialized with a vector of the length of each side. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([120,150,100],10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]
  cutoff: 10.0
  number of computing cells on each dimension: [14, 17, 12]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 2856
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/Box.jl#L320-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L570-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L470-L477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0),
    autoswap::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Function that will initialize a <code>CellListPair</code> structure from scratch, given two vectors of particle coordinates and a <code>Box</code>, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using <code>autoswap=false</code> the cell list is constructed for the second (<code>y</code>)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   10000 particles in the reference vector.
   961 cells with real particles of target vector.

julia&gt; cl = CellList(x,y,box,autoswap=false)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   7389 cells with real particles of target vector.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L511-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0)
) where {UnitCellType,N,T}</code></pre><p>Function that will initialize a <code>CellList</code> structure from scratch, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a <code>Box</code>, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box)
CellList{3, Float64}
  100000 real particles.
  15600 cells with real particles.
  126276 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L426-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.InPlaceNeighborList-Union{Tuple{}, Tuple{T}} where T" href="#CellListMap.InPlaceNeighborList-Union{Tuple{}, Tuple{T}} where T"><code>CellListMap.InPlaceNeighborList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InPlaceNeighborList(;
    x::AbstractVecOrMat,
    y::Union{AbstractVecOrMat,Nothing}=nothing,
    cutoff::T,
    unitcell::Union{AbstractVecOrMat,Nothing}=nothing,
    parallel::Bool=true,
    show_progress::Bool=false,
) where {T}</code></pre><p>Function that initializes the <code>InPlaceNeighborList</code> structure, to be used for in-place computation of neighbor lists.</p><ul><li>If only <code>x</code> is provided, the neighbor list of the set is computed. </li><li>If <code>x</code> and <code>y</code> are provided, the neighbor list between the sets is computed.</li><li>If <code>unitcell</code> is provided, periodic boundary conditions will be used. The <code>unitcell</code> can be a vector of Orthorhombic box sides, or an actual unitcell matrix for general cells. </li><li>If <code>unicell</code> is not provide (value <code>nothing</code>), no periodic boundary conditions will be considered. </li></ul><p><strong>Examples</strong></p><p>Here the neighborlist structure is constructed for the first time, and used to compute the neighbor lists with the mutating <code>neighborlist!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, StaticArrays

julia&gt; x = rand(SVector{3,Float64}, 10^4);

julia&gt; system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]) 
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{OrthorhombicCell, 3, Float64, Float64, 9}
Current list buffer size: 0

julia&gt; neighborlist!(system)
210034-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 357, 0.09922225615002134)
 (1, 488, 0.043487074695938925)
 (1, 2209, 0.017779967072139684)
 ⋮
 (9596, 1653, 0.0897570322108541)
 (9596, 7927, 0.0898266280344037)</code></pre><p>The coordinates of the system, its unitcell, or the cutoff can be changed with the <code>update!</code> function. If the number of pairs of the list does not change  significantly, the new calculation is minimally allocating, or non-allocating  at all, in particular if the computation is run without parallelization:</p><p>If the structure is used repeatedly for similar systems, the allocations will vanish, except for minor allocations used in the threading computation (if a  non-parallel computation is executed, the allocations will vanish completely):</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{3,Float64}, 10^4);

julia&gt; system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]);

julia&gt; @time neighborlist!(system);
  0.008004 seconds (228 allocations: 16.728 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.024811 seconds (167 allocations: 7.887 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.005213 seconds (164 allocations: 1.439 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.005276 seconds (162 allocations: 15.359 KiB)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/neighborlists.jl#L99-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.ParticleSystem1" href="#CellListMap.ParticleSystem1"><code>CellListMap.ParticleSystem1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParticleSystem1{OutputName, V, O, B, C, A} &lt;: CellListMap.AbstractParticleSystem{OutputName}</code></pre><ul><li><p><code>xpositions::Any</code></p></li><li><p><code>output::Any</code></p></li><li><p><code>_box::Any</code></p></li><li><p><code>_cell_list::Any</code></p></li><li><p><code>_output_threaded::Vector</code></p></li><li><p><code>_aux::Any</code></p></li><li><p><code>parallel::Bool</code></p></li></ul><p>Structure that carries the information necessary for <code>map_pairwise!</code> computations, for systems with one set of positions (thus, replacing the loops over <code>N(N-1)</code>  pairs of particles of the set). </p><p>The <code>xpositions</code>, <code>output</code>, and <code>parallel</code> fields are considered part of the API, and you can retrive or mutate <code>xpositions</code>, retrieve the <code>output</code> or its elements, and set the computation to use or not parallelization by directly accessing these elements.</p><p>The other fileds of the structure (starting with <code>_</code>) are internal and must not  be modified or accessed directly. The construction of the <code>ParticleSystem1</code> structure is done through the <code>ParticleSystem(;xpositions, unitcell, cutoff, output)</code>  auxiliary function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L313-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.ParticleSystem2" href="#CellListMap.ParticleSystem2"><code>CellListMap.ParticleSystem2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParticleSystem2{OutputName, V, O, B, C, A} &lt;: CellListMap.AbstractParticleSystem{OutputName}</code></pre><ul><li><p><code>xpositions::Any</code></p></li><li><p><code>ypositions::Any</code></p></li><li><p><code>output::Any</code></p></li><li><p><code>_box::Any</code></p></li><li><p><code>_cell_list::Any</code></p></li><li><p><code>_output_threaded::Vector</code></p></li><li><p><code>_aux::Any</code></p></li><li><p><code>parallel::Bool</code></p></li></ul><p>Structure that carries the information necessary for <code>map_pairwise!</code> computations, for systems with two set of positions (thus, replacing the loops over <code>N×M</code>  pairs of particles, being <code>N</code> and <code>M</code> the number of particles of each set).</p><p>The <code>xpositions</code>, <code>ypositions</code>, <code>output</code>, and <code>parallel</code> fields are considered part of the API, and you can retrive or mutate positions, retrieve the <code>output</code> or its elements, and set the computation to use or not parallelization by directly accessing these elements.</p><p>The other fileds of the structure (starting with <code>_</code>) are internal and must not  be modified or accessed directly. The construction of the <code>ParticleSystem1</code> structure is done through the <code>ParticleSystem(;xpositions, ypositions, unitcell, cutoff, output)</code>  auxiliary function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L347-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.ParticleSystem-Tuple{}" href="#CellListMap.ParticleSystem-Tuple{}"><code>CellListMap.ParticleSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParticleSystem(;
    xpositions::Union{AbstractVector{&lt;:AbstractVector},AbstractMatrix},
    #or
    xpositions::Union{AbstractVector{&lt;:AbstractVector},AbstractMatrix},
    ypositions::Union{AbstractVector{&lt;:AbstractVector},AbstractMatrix},
    # and
    unitcell::Union{Nothing,AbstractVecOrMat} = nothing,
    cutoff::Number,
    output::Any;
    output_name::Symbol,
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0, 0),
    autoswap::Bool = true
)</code></pre><p>Constructor of the <code>ParticleSystem</code> type given the positions of the particles.</p><ul><li><p>Positions can be provided as vectors of 2D or 3D vectors  (preferentially static vectors from <code>StaticArrays</code>), or as  (2,N) or (3,N) matrices (v0.8.28 is required for matrices).</p></li><li><p>If only the <code>xpositions</code> array is provided, a single set of coordinates  is considered, and the computation will be mapped for the <code>N(N-1)</code>  pairs of this set. </p></li><li><p>If the <code>xpositions</code> and <code>ypositions</code> arrays of coordinates are provided,  the computation will be mapped to the <code>N×M</code> pairs of particles,  being <code>N</code> and <code>M</code> the number of particles of each set of coordinates.</p></li></ul><p>The unit cell (either a vector for <code>Orthorhombic</code> cells or a  full unit cell matrix for <code>Triclinic</code> cells), the cutoff used for the construction of the cell lists and the output variable of the calculations. If unitcell == nothing, the system is considered not-periodic, in which case artificial periodic boundaries will be built such that images  are farther from each other than the cutoff.</p><p><code>output_name</code> can be set to a symbol that best identifies the output variable. For instance, if <code>output_name=:forces</code>, the forces can be retrieved from the structure using the <code>system.forces</code> notation.</p><p>The <code>parallel</code> and <code>nbatches</code> flags control the parallelization scheme of computations (see https://m3g.github.io/CellListMap.jl/stable/parallelization/#Number-of-batches)). By default the parallelization is turned on and <code>nbatches</code> is set with heuristics that may provide good efficiency in most cases. <code>autoswap = false</code> will guarantee that the cell lists will be buitl for the <code>ypositions</code> (by default they are constructed for the smallest set, which is faster).</p><p><strong>Example</strong></p><p>In these examples, we compute the sum of the squared distances between the particles that are within the cutoff:</p><p><strong>Single set of particles</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; using PDBTools: readPDB, coor

julia&gt; positions = coor(readPDB(CellListMap.argon_pdb_file));

julia&gt; sys = ParticleSystem(
           xpositions = positions, 
           unitcell = [21.0, 21.0, 21.0],
           cutoff = 8.0, 
           output = 0.0, 
        );

julia&gt; map_pairwise!((x,y,i,j,d2,output) -&gt; output += d2, sys)
43774.54367600002</code></pre><p><strong>Two sets of particles</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, PDBTools

julia&gt; xpositions = coor(readPDB(CellListMap.argon_pdb_file))[1:50];

julia&gt; ypositions = coor(readPDB(CellListMap.argon_pdb_file))[51:100];

julia&gt; sys = ParticleSystem(
           xpositions = xpositions, 
           ypositions = ypositions, 
           unitcell = [21.0, 21.0, 21.0],
           cutoff = 8.0, 
           output = 0.0, 
           parallel = false, # use true for parallelization
        );

julia&gt; map_pairwise!((x,y,i,j,d2,output) -&gt; output += d2, sys)
21886.196785000004</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L17-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellListPair,
    parallel=true
)</code></pre><p>Function that will update a previously allocated <code>CellListPair</code> structure, given  new updated particle positions, for example. This method will allocate new  <code>aux</code> threaded auxiliary arrays. For a non-allocating version, see the  <code>UpdateCellList!(x,y,box,cl,aux)</code> method.</p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; UpdateCellList!(x,y,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L1035-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellList,
    parallel=true
)</code></pre><p>Function that will update a previously allocated <code>CellList</code> structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the <code>UpdateCellList!(x,box,cl,aux)</code> method instead. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; box = Box([260,260,260],10);

julia&gt; x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; UpdateCellList!(x,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L586-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair, Union{Nothing, CellListMap.AuxThreaded}}} where {UnitCellType, N}" href="#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair, Union{Nothing, CellListMap.AuxThreaded}}} where {UnitCellType, N}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box,
    cl_pair::CellListPair,
    aux::Union{Nothing,AuxThreaded};
    parallel::Bool=true
) where {UnitCellType,N}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L1213-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair}} where {UnitCellType, N}" href="#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair}} where {UnitCellType, N}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N},
    cl_pair::CellListPair;
    parallel::Bool=true
) where {UnitCellType,N}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L1078-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap&lt;:CellListMap.NotSwapped}" href="#CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap&lt;:CellListMap.NotSwapped}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl_pair::CellListPair,
    aux::Union{Nothing,AuxThreaded};
    parallel::Bool=true
)</code></pre><p>This function will update the <code>cl_pair</code> structure that contains the cell lists for disjoint sets of particles. It receives the preallocated <code>aux</code> structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7381 cells with real particles of target vector.

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; UpdateCellList!(x,y,box,cl,aux)
CellList{3, Float64}
  10000 real particles.
  7358 cells with real particles.
  12591 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux)
  715.661 μs (41 allocations: 3.88 KiB)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7414 cells with real particles of target vector.
   
julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)
   13.042 ms (0 allocations: 0 bytes)
 CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
    50000 particles in the reference vector.
    15031 cells with real particles of target vector.
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L1106-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T},
    aux::Union{Nothing,AuxThreaded{N,T}};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L770-L783">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L631-L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl::CellList{N,T},
    aux::Union{Nothing,AuxThreaded{N,T}};
    parallel::Bool=true
) where {N,T}</code></pre><p>Function that updates the cell list <code>cl</code> new coordinates <code>x</code> and possibly a new box <code>box</code>, and receives a preallocated <code>aux</code> structure of auxiliary vectors for threaded cell list construction. Given a preallocated <code>aux</code> vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux)
  16.384 ms (41 allocations: 3.88 KiB)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)
  20.882 ms (0 allocations: 0 bytes)
CellList{3, Float64}
  100000 real particles.
  15603 cells with real particles.
  125896 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L655-L716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.copy_output-Tuple{Any}" href="#CellListMap.copy_output-Tuple{Any}"><code>CellListMap.copy_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_output(x)</code></pre><p>Defines how the <code>output</code> variable is copied. Identical to <code>Base.copy(x)</code> and implemented for the types in <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code>.</p><p>Other custom output types must have their <code>copy_output</code> method implemented.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CellListMap
# Custom data type
struct A x::Int end
# Custom output type (array of A)
output = [ A(0) for _ in 1:100 ]
# How to copy an array of `A`
CellListMap.copy_output(v::Vector{A}) = [ x for x in v ]

# Alternativelly, in this case, one could have defined:
Base.copy(a::A) = a
CellListMap.copy_output(v::Vector{A}) = copy(v)</code></pre><p>The user must guarantee that the copy is independent of the original array. For many custom types it is possible to define </p><pre><code class="nohighlight hljs">CellListMap.copy_output(v::Vector{T}) where {T&lt;:CustomType} = deepcopy(v)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L412-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}}" href="#CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x,y)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code> and <code>y</code>, to used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellOperations.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}" href="#CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code>,  to be used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellOperations.jl#L271-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise" href="#CellListMap.map_pairwise"><code>CellListMap.map_pairwise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)</code></pre><p>is an alias for <code>map_pairwise!</code> which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through <code>juliacall</code> does not accept the  bang as a valid character. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellListMap.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F" href="#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(
    f::Function,
    output,
    box::Box,
    cl::CellList
    ;parallel::Bool=true,
    show_progress::Bool=false
)</code></pre><p>This function will run over every pair of particles which are closer than  <code>box.cutoff</code> and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the <code>Box</code> structure.  If the distance is smaller than the cutoff, a function <code>f</code> of the  coordinates of the two particles will be computed. </p><p>The function <code>f</code> receives six arguments as input: </p><pre><code class="nohighlight hljs">f(x,y,i,j,d2,output)</code></pre><p>Which are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the <code>output</code> variable.  It has also to return the same <code>output</code> variable. Thus, <code>f</code> may or not  mutate <code>output</code>, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance <code>d2</code> is computed  internally for comparison with the  <code>cutoff</code>, and is passed to the <code>f</code> because many times it is used for the  desired computation. </p><p><strong>Example</strong></p><p>Computing the mean absolute difference in <code>x</code> position between random particles,  remembering the number of pairs of <code>n</code> particles is <code>n(n-1)/2</code>. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 100_000;

julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];

julia&gt; cl = CellList(x,box);

julia&gt; f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])

julia&gt; normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

julia&gt; avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -&gt; f(x,y,sum_dx), 0.0, box, cl)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellListMap.jl#L49-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, CellListMap.AbstractParticleSystem}} where F&lt;:Function" href="#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, CellListMap.AbstractParticleSystem}} where F&lt;:Function"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function, system; show_progress = true, update_lists = true)</code></pre><p>Function that maps the <code>f</code> function into all pairs of particles of <code>system</code> that are found to be within the <code>cutoff</code>. </p><p>The function <code>f</code> must be of the general form:</p><pre><code class="nohighlight hljs">function f(x,y,i,j,d2,output)
    # operate on particle coordinates, distance and indexes
    # update output
    return output
end</code></pre><p>where <code>x</code> and <code>y</code> are the coordinates (adjusted for the minimum image) of the two particles involved, <code>i</code> and <code>j</code> their indices in the original arrays of positions, <code>d2</code> their squared Euclidean distance, and <code>output</code> the current value of the <code>output</code> variable. The <code>output</code> variable must be updated within this function with the contribution of the two particles involved. </p><p>Thread-safety is taken care automatically in parallel executions.</p><p><code>map_pairwise</code> is an alias to <code>map_pairwise!</code> for syntax consistency when the <code>output</code> variable is immutable.</p><p>If <code>update_lists</code> is <code>false</code>, the cell lists will not be recomputed, this may be useful for computing a different function from the same coordinates.</p><p><strong>Example</strong></p><p>In this example we compute the sum of <code>1/(1+d)</code> where <code>d</code> is the distance between particles of a set, for <code>d &lt; cutoff</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; sys = ParticleSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           );

julia&gt; map_pairwise((x,y,i,j,d2,output) -&gt; output += 1 / (1 + sqrt(d2)), sys)
1870.0274887950268</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L977-L1024">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}" href="#CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function,output,box::Box,cl::CellListPair)</code></pre><p>The same but to evaluate some function between pairs of the particles of the vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellListMap.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.nbatches-Tuple{CellList}" href="#CellListMap.nbatches-Tuple{CellList}"><code>CellListMap.nbatches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nbatches(cl)</code></pre><p>Returns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list <code>cl</code>.  It returns the <code>cl.nbatches.map_computation</code> value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.</p><p>A second argument can be provided, which may be <code>:map</code> or <code>:build</code>, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(3,1000); box = Box([1,1,1],0.1);

julia&gt; cl = CellList(x,box,nbatches=(2,16));

julia&gt; nbatches(cl)
16

julia&gt; nbatches(cl,:map)
16

julia&gt; nbatches(cl,:build)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellLists.jl#L259-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(
    x, y, cutoff; 
    unitcell=nothing, 
    parallel=true, 
    show_progress=false, 
    autoswap=true,
    nbatches=(0,0)
)</code></pre><p>Computes the list of pairs of particles of <code>x</code> which are closer than <code>r</code> to the particles of <code>y</code>. The <code>autoswap</code> option will swap <code>x</code> and <code>y</code> to try to optimize the cost of the construction of the cell list. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; y = [ rand(3) for i in 1:1_000 ];

julia&gt; CellListMap.neighborlist(x,y,0.05)
5006-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 269, 0.04770884036497686)
 (25, 892, 0.03850515231540869)
 ⋮
 (9952, 749, 0.048875643578313456)
 (9984, 620, 0.04101242499363183)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/neighborlists.jl#L531-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(x, cutoff; unitcell=nothing, parallel=true, show_progress=false)</code></pre><p>Computes the list of pairs of particles in <code>x</code> which are closer to each other than <code>cutoff</code>. If the keyword parameter <code>unitcell</code> is provided (as a vector of sides or a general unit cell matrix, periodic boundary conditions are considered). </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; neighborlist(x,0.05)
24848-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 1055, 0.022977369806392412)
 (1, 5086, 0.026650609138167428)
 ⋮
 (9989, 3379, 0.0467653507446483)
 (9989, 5935, 0.02432728985151653)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/neighborlists.jl#L489-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T" href="#CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T"><code>CellListMap.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(output, output_threaded)</code></pre><p>Most common reduction function, which sums the elements of the output.  Here, <code>output_threaded</code> is a vector containing <code>nbatches(cl)</code> copies of the <code>output</code> variable (a scalar or an array). Custom reduction functions  must replace this one if the reduction operation is not a simple sum.  The <code>output_threaded</code> array is, by default, created automatically by copying the given <code>output</code> variable <code>nbatches(cl)</code> times. </p><p><strong>Examples</strong></p><p>Scalar reduction: </p><pre><code class="language-julia-repl hljs">julia&gt; output = 0.; output_threaded = [ 1, 2 ];

julia&gt; CellListMap.reduce(output,output_threaded)
3</code></pre><p>Array reduction:</p><pre><code class="language-julia-repl hljs">julia&gt; output = [0,0]; output_threaded = [ [1,1], [2,2] ];

julia&gt; CellListMap.reduce(output,output_threaded)
2-element Vector{Int64}:
 3
 3

julia&gt; output
2-element Vector{Int64}:
 3
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CoreComputing.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.reducer!-Tuple{Any, Any}" href="#CellListMap.reducer!-Tuple{Any, Any}"><code>CellListMap.reducer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducer(x,y)
reducer!(x,y)</code></pre><p>Defines how to reduce (combine, or merge) to variables computed in parallel to obtain a single instance of the variable with the reduced result. </p><p><code>reducer</code> and <code>reducer!</code> are aliases, and <code>reducer!</code> is preferred, by convention for mutating functions.</p><p>The most commont <code>reducer</code> is the sum, and this is how it is implemented for <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code>. For example, when computin energies, or forces, the total energy is the sum of the energies. The force on one particle is the sum of the forces between the particle and every other particle. Thus, the implemented reducer is the sum: </p><pre><code class="nohighlight hljs">reducer(x,y) = +(x,y)</code></pre><p>However, in  many cases, reduction must be done differently. For instance, if the minimum distance between particles is to be computed, it is interesting to define a custom type and associated reducer. For example:</p><pre><code class="nohighlight hljs">struct MinimumDistance d::Float64 end
reducer(x::MinimumDistance, y::MinimumDistance) = MinimumDistance(min(x.d, y.d))</code></pre><p>The overloading of <code>reducer</code> allows the use of parallel computations for custom,  complex data types, containing different types of variables, fields, or sizes.</p><p>The appropriate behavior of the reducer should be carefuly inspected by the user to avoid spurious results. </p><p><strong>Example</strong></p><p>In this example we show how to obtain the minimum distance among argon atoms in a simulation box.</p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, PDBTools

julia&gt; positions = coor(readPDB(CellListMap.argon_pdb_file));

julia&gt; struct MinimumDistance d::Float64 end # Custom output type

julia&gt; CellListMap.copy_output(d::MinimumDistance) = MinimumDistance(d.d) # Custom copy function for `Out`

julia&gt; CellListMap.reset_output(d::MinimumDistance) = MinimumDistance(+Inf) # How to reset an array with elements of type `MinimumDistance`

julia&gt; CellListMap.reducer(md1::MinimumDistance, md2::MinimumDistance) = MinimumDistance(min(md1.d, md2.d)) # Custom reduction function

julia&gt; # Construct the system
       sys = ParticleSystem(;
           positions = positions,
           unitcell = [21,21,21],
           cutoff = 8.0,
           output = MinimumDistance(+Inf),
       );

julia&gt; # Obtain the minimum distance between atoms:
       map_pairwise!((x,y,i,j,d2,output) -&gt; sqrt(d2) &lt; output.d ? MinimumDistance(sqrt(d2)) : output, sys)
MinimumDistance(2.1991993997816563)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L528-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.reset_output!-Tuple{Any}" href="#CellListMap.reset_output!-Tuple{Any}"><code>CellListMap.reset_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_output(x)
reset_output!(x)</code></pre><p>Function that defines how to reset (or zero) the <code>output</code> variable. For <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code> it is  implemented as <code>zero(x)</code>, and for <code>AbstractVecOrMat</code> containers of <code>Number</code>s or <code>SVector</code>s it is implemented as <code>fill!(x, zero(eltype(x))</code>.</p><p>Other custom output types must have their <code>reset_output!</code> method implemented.</p><p>If the variable is mutable, the function <em>must</em> return the variable itself. If it is immutable, a new instante of the variable must be created, with the reset value. </p><p><code>reset_output</code> and <code>reset_output!</code> are aliases, and <code>reset_output!</code> is preferred, by convention for mutating functions.</p><p><strong>Example</strong></p><p>In this example, we define a <code>reset_output</code> function that will set to <code>+Inf</code> the minimum distance between particles (not always resetting means zeroing).</p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; struct MinimumDistance d::Float64 end

julia&gt; CellListMap.reset_output(x::MinimumDistance) = MinimumDistance(+Inf)

julia&gt; x = MinimumDistance(1.0)
MinimumDistance(1.0)

julia&gt; CellListMap.reset_output(x)
MinimumDistance(Inf)</code></pre><p>See the <code>reducer</code> help entry for a complete example of how to use <code>reset_output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L458-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.resize_output!-Tuple{CellListMap.AbstractParticleSystem, Int64}" href="#CellListMap.resize_output!-Tuple{CellListMap.AbstractParticleSystem, Int64}"><code>CellListMap.resize_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_output!(sys::AbstractParticleSystem, n::Int)</code></pre><p>Resizes the output array and the auxiliary output arrays used for multithreading, if the number of particles of the system changed.</p><p>This function must be implemented by the user if the output variable is a  vector whose length is dependent on the number of particles. For example, if the output is a vector of forces acting on each particle, the output vector must be resized if the number of particles changes. </p><p>This function <em>must</em> be used in that case, to guarantee that the  auxiliary arrays used for multi-threading are resized accordingly. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L669-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}" href="#CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::AbstractVector{&lt;:AbstractVector},unit_cell_matrix,indices)</code></pre><p>Translates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{2,Float64},100);

julia&gt; box = Box([1,1],0.1);

julia&gt; CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))
100-element Vector{SVector{2, Float64}}:
 [1.847791110439223, 1.5989103939725295]
 [1.3493293666090889, 1.4002971843576644]
 [1.4111736701313218, 1.3471780214994182]
 ⋮
 [1.1548437388991908, 1.7034501001177493]
 [1.4066300885242247, 1.2907398318754952]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/CellOperations.jl#L129-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.unitcelltype-Tuple{CellListMap.AbstractParticleSystem}" href="#CellListMap.unitcelltype-Tuple{CellListMap.AbstractParticleSystem}"><code>CellListMap.unitcelltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcelltype(sys::AbstractParticleSystem)</code></pre><p>Returns the type of a unitcell from the <code>ParticleSystem</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.unitcelltype-Union{Tuple{Box{T}}, Tuple{T}} where T" href="#CellListMap.unitcelltype-Union{Tuple{Box{T}}, Tuple{T}} where T"><code>CellListMap.unitcelltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcelltype(::Box{T}) where T = T</code></pre><p>Returns the type of a unitcell from the <code>Box</code> structure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([1,1,1], 0.1)

julia&gt; unitcelltype(box)
OrthorhombicCell

julia&gt; box = Box([1 0 0; 0 1 0; 0 0 1], 0.1)

julia&gt; unitcelltype(box)
TriclinicCell</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/Box.jl#L96-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.update!-Union{Tuple{C}, Tuple{UnitCellType}, Tuple{InPlaceNeighborList{&lt;:Box{UnitCellType}, C}, AbstractVecOrMat}} where {UnitCellType, C&lt;:CellList}" href="#CellListMap.update!-Union{Tuple{C}, Tuple{UnitCellType}, Tuple{InPlaceNeighborList{&lt;:Box{UnitCellType}, C}, AbstractVecOrMat}} where {UnitCellType, C&lt;:CellList}"><code>CellListMap.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update!(system::InPlaceNeighborList, x::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)
update!(system::InPlaceNeighborList, x::AbstractVecOrMat, y::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)</code></pre><p>Updates a <code>InPlaceNeighborList</code> system, by updating the coordinates, cutoff, and unitcell.</p><p><strong>Examples</strong></p><p><strong>For self-pairs computations</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{3,Float64}, 10^3);

julia&gt; system = InPlaceNeighborList(x=x; cutoff=0.1)
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{NonPeriodicCell, 3, Float64, Float64, 9}
Current list buffer size: 0

julia&gt; neighborlist!(system);

julia&gt; new_x = rand(SVector{3,Float64}, 10^3);

julia&gt; update!(system, new_x; cutoff = 0.05)
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{NonPeriodicCell, 3, Float64, Float64, 9}
Current list buffer size: 1826

julia&gt; neighborlist!(system)
224-element Vector{Tuple{Int64, Int64, Float64}}:
 (25, 486, 0.03897345036790646)
 ⋮
 (723, 533, 0.04795768478723409)
 (868, 920, 0.042087156715720137)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/neighborlists.jl#L210-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.update_cutoff!-Tuple{CellListMap.ParticleSystem1, Any}" href="#CellListMap.update_cutoff!-Tuple{CellListMap.ParticleSystem1, Any}"><code>CellListMap.update_cutoff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_cutoff!(system, cutoff)</code></pre><p>Function to update the <code>cutoff</code>` of the system. </p><p>This function can be used to update the system geometry in iterative schemes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, StaticArrays

julia&gt; sys = ParticleSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           );

julia&gt; update_cutoff!(sys, 0.2)
ParticleSystem1 of dimension 3, composed of:
    Box{OrthorhombicCell, 3}
      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.2
      number of computing cells on each dimension = [7, 7, 7]
      computing cell sizes = [0.2, 0.2, 0.2] (lcell: 1)
      Total number of cells = 343
    CellListMap.CellList{3, Float64}
      1000 real particles.
      620 cells with real particles.
      1746 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 12
    Type of output variable: Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L779-L815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.update_unitcell!-Tuple{Any, Any}" href="#CellListMap.update_unitcell!-Tuple{Any, Any}"><code>CellListMap.update_unitcell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_unitcell!(system, unitcell)</code></pre><p>Function to update the unit cell of the system. The <code>unicell</code> must be of the  same type (<code>OrthorhombicCell</code>, <code>TriclinicCell</code>) of the original <code>system</code>  (changing the type of unit cell requires reconstructing the system).</p><p>The <code>unitcell</code> can be a <code>N×N</code> matrix or a vector of dimension <code>N</code>, where <code>N</code> is the dimension of the sytem (2D or 3D).</p><p>This function can be used to update the system geometry in iterative schemes, where the size of the simulation box changes during the simulation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Manual updating of the unit cell of non-periodic systems is not allowed.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, StaticArrays, PDBTools

julia&gt; xpositions = coor(readPDB(CellListMap.argon_pdb_file));

julia&gt; sys = ParticleSystem(
           xpositions = xpositions,
           unitcell=[21,21,21], 
           cutoff = 8.0, 
           output = 0.0
       );

julia&gt; update_unitcell!(sys, [30.0, 30.0, 30.0])
ParticleSystem1{output} of dimension 3, composed of:
    Box{OrthorhombicCell, 3}
      unit cell matrix = [ 30.0 0.0 0.0; 0.0 30.0 0.0; 0.0 0.0 30.0 ]
      cutoff = 8.0
      number of computing cells on each dimension = [6, 6, 6]
      computing cell sizes = [10.0, 10.0, 10.0] (lcell: 1)
      Total number of cells = 216
    CellList{3, Float64}
      100 real particles.
      8 cells with real particles.
      800 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 8
    Type of output variable (output): Float64
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/76860537d43b9594b58754daf3c548498c88bf3e/src/ParticleSystem.jl#L695-L744">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../python/">« From Python</a><a class="docs-footer-nextpage" href="../citation/">Citation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 17:00">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
