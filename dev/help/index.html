<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Help entries · CellListMap.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../pbc/">Periodic conditions</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li><li><a class="tocitem" href="../units_etc/">Units, autodiff, etc.</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../options/">Options</a></li><li><a class="tocitem" href="../python/">From Python</a></li><li class="is-active"><a class="tocitem" href>Help entries</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Help entries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Help entries</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/m3g/CellListMap.jl/blob/master/docs/src/help.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Help-entries"><a class="docs-heading-anchor" href="#Help-entries">Help entries</a><a id="Help-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Help-entries" title="Permalink"></a></h1><p>These entries can be viewed at the <code>Julia</code> REPL <code>Julia</code> using </p><pre><code class="language-julia-repl hljs">julia&gt; ? 
help?&gt; function_name</code></pre><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded" href="#CellListMap.AuxThreaded"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AuxThreaded{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>n_per_cycle::Int64</code></p></li><li><p><code>idxs::Vector{UnitRange{Int64}}</code></p><p>Default: Vector{UnitRange{Int}}(undef, 0)</p></li><li><p><code>lists::Array{CellList{N, T}, 1} where {N, T}</code></p><p>Default: Vector{CellList{N, T}}(undef, 0)</p></li></ul><p>Auxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L280-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}" href="#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellListPair{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type for lists of disjoint particle sets,  to be passed to <code>UpdateCellList!</code> for in-place update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L364-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellList{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type, to be passed to <code>UpdateCellList!</code> for in-place  update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for _ in 1:100_000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L304-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box" href="#CellListMap.Box"><code>CellListMap.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Box{UnitCellType, N, T, TSQ, M}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>unit_cell::CellListMap.UnitCell</code></p></li><li><p><code>lcell::Int64</code></p></li><li><p><code>nc::StaticArrays.SVector{N, Int64} where N</code></p></li><li><p><code>cutoff::Any</code></p></li><li><p><code>cutoff_sq::Any</code></p></li><li><p><code>ranges::StaticArrays.SVector{N, UnitRange{Int64}} where N</code></p></li><li><p><code>cell_size::StaticArrays.SVector</code></p></li><li><p><code>unit_cell_max::StaticArrays.SVector</code></p></li></ul><p>Structure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; sides = [250,250,250];

julia&gt; cutoff = 10;

julia&gt; box = Box(sides,cutoff)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]
  cutoff: 10.0
  number of computing cells on each dimension: [27, 27, 27]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 19683
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; box = Box([ 10  0  0 
                    0 10  5
                    0  0 10 ], 1)
Box{TriclinicCell, 3, Float64, 9}
unit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]
cutoff: 1.0
number of computing cells on each dimension: [12, 17, 12]
computing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)
Total number of cells: 2448
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L32-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T" href="#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
    limits::Limits,
    cutoff;
    lcell::Int=1
)</code></pre><p>This constructor receives the output of <code>limits(x)</code> or <code>limits(x,y)</code> where <code>x</code> and <code>y</code> are the coordinates of the particles involved, and constructs a <code>Box</code> with size larger than the maximum coordinates ranges of all particles plus the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is always an <code>Orthorhombic</code> cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x),10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [109.99633932875878 0.0 0.0; 0.0 109.99780283179763 0.0; 0.0 0.0 109.99587254766517]
  cutoff: 10.0
  number of computing cells on each dimension: [12, 12, 12]
  computing cell sizes: [10.999633932875877, 10.999780283179764, 10.999587254766517] (lcell: 1)
  Total number of cells: 1728

julia&gt; y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x,y),10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [159.99787690924168 0.0 0.0; 0.0 159.98878289444897 0.0; 0.0 0.0 109.99587254766517]
  cutoff: 10.0
  number of computing cells on each dimension: [18, 17, 12]
  computing cell sizes: [10.666525127282778, 10.665918859629931, 10.999587254766517] (lcell: 1)
  Total number of cells: 3672
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L303-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
  unit_cell_matrix::AbstractMatrix, 
  cutoff, 
  lcell::Int=1,
  UnitCellType=TriclinicCell
)</code></pre><p>Construct box structure given the cell matrix of lattice vectors. This  constructor will always return a <code>TriclinicCell</code> box type, unless the <code>UnitCellType</code> parameter is set manually to <code>OrthorhombicCell</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell = [ 100   50    0 
                       0  120    0
                       0    0  130 ];

julia&gt; box = Box(unit_cell,10)
Box{TriclinicCell, 3, Float64, 9}
  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]
  cutoff: 10.0
  number of computing cells on each dimension: [17, 14, 15]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 3570
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L116-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
  sides::AbstractVector, 
  cutoff, 
  lcell::Int=1,
  UnitCellType=OrthorhombicCell
)</code></pre><p>For orthorhombic unit cells, <code>Box</code> can be initialized with a vector of the  length of each side. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([120,150,100],10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]
  cutoff: 10.0
  number of computing cells on each dimension: [14, 17, 12]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 2856
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L259-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Cell" href="#CellListMap.Cell"><code>CellListMap.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Cell{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>linear_index::Int64</code></p></li><li><p><code>cartesian_index::CartesianIndex</code></p></li><li><p><code>center::StaticArrays.SVector</code></p></li><li><p><code>contains_real::Bool</code></p></li><li><p><code>n_particles::Int64</code></p></li><li><p><code>particles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}</code></p></li></ul><p>This structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighboring cells need to be wrapped) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList" href="#CellListMap.CellList"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellList{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>n_real_particles::Int64</code></p><p>Number of real particles.</p></li><li><p><code>number_of_cells::Int64</code></p><p>Number of cells.</p></li><li><p><code>n_particles::Int64</code></p><p><em>mutable</em> number of particles in the computing box.</p></li><li><p><code>n_cells_with_real_particles::Int64</code></p><p><em>mutable</em> number of cells with real particles.</p></li><li><p><code>n_cells_with_particles::Int64</code></p><p><em>mutable</em> number of cells with particles, real or images.</p></li><li><p><code>cell_indices::Vector{Int64}</code></p><p>Auxiliary array that contains the indexes in list of the cells with particles, real or images.</p></li><li><p><code>cell_indices_real::Vector{Int64}</code></p><p>Auxiliary array that contains the indexes in the cells with real particles.</p></li><li><p><code>cells::Array{CellListMap.Cell{N, T}, 1} where {N, T}</code></p><p>Vector containing cell lists of cells with particles.</p></li><li><p><code>nbatches::CellListMap.NumberOfBatches</code></p><p>Number of batches for the parallel calculations.</p></li><li><p><code>projected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}</code></p><p>Auxiliar array to store projected particles.</p></li></ul><p>Structure that contains the cell lists information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} </code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L563-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} </code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L445-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0),
    autoswap::Bool=true
) where {UnitCellType,N,T} </code></pre><p>Function that will initialize a <code>CellListPair</code> structure from scracth, given two vectors of particle coordinates and a <code>Box</code>, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using <code>autoswap=false</code> the cell list is constructed for the second (<code>y</code>)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   10000 particles in the reference vector.
   961 cells with real particles of target vector.

julia&gt; cl = CellList(x,y,box,autoswap=false)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   7389 cells with real particles of target vector.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L501-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0)
) where {UnitCellType,N,T} </code></pre><p>Function that will initialize a <code>CellList</code> structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a <code>Box</code>, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box)
CellList{3, Float64}
  100000 real particles.
  15600 cells with real particles.
  126276 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L398-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellListPair" href="#CellListMap.CellListPair"><code>CellListMap.CellListPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellListPair{V, N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>ref::Any</code></p></li><li><p><code>target::CellList</code></p></li><li><p><code>swap::Bool</code></p></li></ul><p>Structure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L157-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Limits" href="#CellListMap.Limits"><code>CellListMap.Limits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Limits{T&lt;:(AbstractVector)}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><code>limits::AbstractVector</code></li></ul><p>Structure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.NumberOfBatches" href="#CellListMap.NumberOfBatches"><code>CellListMap.NumberOfBatches</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NumberOfBatches</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>build_cell_lists::Int64</code></p></li><li><p><code>map_computation::Int64</code></p></li></ul><p>Structure to define the number of batches used in the parallel splitting of the calculations of the cell list construction and of the <code>map_pairwise</code> computation. It is initialized with a standard heuristic that returns at most the number of threads, but may return a smaller number if the system is small. The two parameters can be tunned for optimal performance of each step of the calculation (cell list construction and mapping of interactions). The construction of the cell lists require a larger number of particles for threading to be effective, Thus by default the system size that allows multi-threading is greater for this part of the calculation.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ParticleWithIndex" href="#CellListMap.ParticleWithIndex"><code>CellListMap.ParticleWithIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParticleWithIndex{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>index::Int64</code></p></li><li><p><code>real::Bool</code></p></li><li><p><code>coordinates::StaticArrays.SVector</code></p></li></ul><p>Copies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ProjectedParticle" href="#CellListMap.ProjectedParticle"><code>CellListMap.ProjectedParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProjectedParticle{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>index::Int64</code></p></li><li><p><code>xproj::Any</code></p></li><li><p><code>coordinates::StaticArrays.SVector</code></p></li></ul><p>Auxiliary structure to contain projected particles. Types of  scalars are chosen such that with a <code>SVector{3,Float64}</code> the complete struct has 32bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L93-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair, CellListMap.AuxThreaded}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair, CellListMap.AuxThreaded}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl_pair::CellListPair,
    aux::AuxThreaded;
    parallel::Bool=true
)</code></pre><p>This function will update the <code>cl_pair</code> structure that contains the cell lists for disjoint sets of particles. It receives the preallocated <code>aux</code> structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7381 cells with real particles of target vector.

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = UpdateCellList!(x,y,box,cl,aux)
CellList{3, Float64}
  10000 real particles.
  7358 cells with real particles.
  12591 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux)
  715.661 μs (41 allocations: 3.88 KiB)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7414 cells with real particles of target vector.
   
julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)
   13.042 ms (0 allocations: 0 bytes)
 CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
    50000 particles in the reference vector.
    15031 cells with real particles of target vector.
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L1117-L1184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
  x::AbstractVector{&lt;:AbstractVector},
  y::AbstractVector{&lt;:AbstractVector},
  box::Box,
  cl:CellListPair,
  parallel=true
)</code></pre><p>Function that will update a previously allocated <code>CellListPair</code> structure, given  new updated particle positions, for example. This method will allocate new  <code>aux</code> threaded auxiliary arrays. For a non-allocating version, see the  <code>UpdateCellList!(x,y,box,cl,aux)</code> method.</p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; cl = UpdateCellList!(x,y,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L1044-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellList,
    parallel=true
) </code></pre><p>Function that will update a previously allocated <code>CellList</code> structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the <code>UpdateCellList!(x,box,cl,aux)</code> method instead. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; box = Box([260,260,260],10);

julia&gt; x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = UpdateCellList!(x,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L582-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T},
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L768-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L626-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl::CellList{N,T},
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Function that updates the cell list <code>cl</code> new coordinates <code>x</code> and possibly a new box <code>box</code>, and receives a preallocated <code>aux</code> structure of auxiliary vectors for threaded cell list construction. Given a preallocated <code>aux</code> vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux)
  16.384 ms (41 allocations: 3.88 KiB)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)
  20.882 ms (0 allocations: 0 bytes)
CellList{3, Float64}
  100000 real particles.
  15603 cells with real particles.
  125896 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L653-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair{N, T}, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair{N, T}, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box,
    cl_pair::CellListPair,
    aux::AuxThreaded;
    parallel::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L1202-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N,T},
    cl_pair::CellListPair;
    parallel::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L1086-L1102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap._promote_types-Tuple{Any, Any}" href="#CellListMap._promote_types-Tuple{Any, Any}"><code>CellListMap._promote_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_promote_types(cell,cutoff)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Promotes the types of the unit cell matrix (or sides) and cutoff to floats if one or both were input as integers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L89-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particle_to_celllist!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particle_to_celllist!(
    ip,
    x::SVector{N,T},
    box,
    cl::CellList{N,T};
    real_particle::Bool=true
) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Adds one particle to the cell lists, updating all necessary arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L947-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Add all particles in vector <code>x</code> to the cell list <code>cl</code>. <code>ishift</code> is the shift in particle index, meaning that particle <code>i</code> of vector <code>x</code> corresponds to the particle with original index <code>i+ishift</code>. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L797-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.append_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append_particles!(cell1::Cell,cell2::Cell)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Add the particles of <code>cell2</code> to <code>cell1</code>, updating the cell data and, if necessary, resizing (increasing) the <code>particles</code> array of <code>cell1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L858-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_cartesian_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Given the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L418-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.cell_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Computes the geometric center of a computing cell, to be used in the projection of points. Returns a <code>SVector{N,T}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L401-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_linear_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_linear_index(nc::SVector{N,Int}, indices) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Returns the index of the cell, in the 1D representation, from its cartesian coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L435-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}" href="#CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}"><code>CellListMap.cell_matrix_from_sides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_matrix_from_sides(sides::AbstractVector)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the Orthorhombic unit cell matrix given a sides vector.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; CellListMap.cell_matrix_from_sides([1,1,1])
3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/Box.jl#L219-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.check_unit_cell-Tuple{Box}" href="#CellListMap.check_unit_cell-Tuple{Box}"><code>CellListMap.check_unit_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_unit_cell(box::Box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Checks if the unit cell satisfies the conditions for using the minimum-image convention. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L501-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.copydata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copydata!(cell1::Cell,cell2::Cell)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Copies the data from <code>cell2</code> to <code>cell1</code>, meaning that particles are copied element-wise from <code>cell2</code> to <code>cell1</code>, with the <code>particles</code> array of <code>cell1</code> being resized (increased) if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L826-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}" href="#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}"><code>CellListMap.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2} </code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>LinearAlgebra.dot</code> is slower than this for standard arrays (likely more accurate, but that is not relevant here).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/linearalgebra.jl#L39-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType</code></pre><pre><code class="nohighlight hljs">draw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType</code></pre><p>This function creates a plot of the computing cell, in two dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/testing.jl#L233-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType</code></pre><p>This function creates a plot of the computing cell, in three dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/testing.jl#L271-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T" href="#CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T"><code>CellListMap.fix_upper_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_upper_boundary(x::T,side) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Move <code>x</code> to <code>x -side</code> if <code>x == side</code>, because we use the convention that the boundary belongs to the next cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}" href="#CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code>,  to be used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L598-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector{&lt;:AbstractVector})" href="#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector{&lt;:AbstractVector})"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x,y)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code> and <code>y</code>, to used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L620-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_naive!-Tuple{Any, Any, Any, Box}" href="#CellListMap.map_naive!-Tuple{Any, Any, Any, Box}"><code>CellListMap.map_naive!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_naive!(f,output,x,box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that uses the naive pairwise mapping algorithm, for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/testing.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_pairwise" href="#CellListMap.map_pairwise"><code>CellListMap.map_pairwise</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)</code>`</p><p>is an alias for <code>map_pairwise!</code> which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through <code>juliacall</code> does not accept the  bang as a valid character. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellListMap.jl#L138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}" href="#CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function,output,box::Box,cl::CellListPair)</code></pre><p>The same but to evaluate some function between pairs of the particles of the vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellListMap.jl#L104-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F" href="#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(
  f::Function,
  output,
  box::Box,
  cl::CellList
  ;parallel::Bool=true,
  show_progress::Bool=false
)</code></pre><p>This function will run over every pair of particles which are closer than  <code>box.cutoff</code> and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the <code>Box</code> structure.  If the distance is smaller than the cutoff, a function <code>f</code> of the  coordinates of the two particles will be computed. </p><p>The function <code>f</code> receives six arguments as input: </p><pre><code class="nohighlight hljs">f(x,y,i,j,d2,output)</code></pre><p>Which are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the <code>output</code> variable.  It has also to return the same <code>output</code> variable. Thus, <code>f</code> may or not  mutate <code>output</code>, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance <code>d2</code> is computed  internally for comparison with the  <code>cutoff</code>, and is passed to the <code>f</code> because many times it is used for the  desired computation. </p><p><strong>Example</strong></p><p>Computing the mean absolute difference in <code>x</code> position between random particles,  remembering the number of pairs of <code>n</code> particles is <code>n(n-1)/2</code>. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 100_000;

julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];

julia&gt; cl = CellList(x,box);

julia&gt; f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])

julia&gt; normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

julia&gt; avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -&gt; f(x,y,sum_dx), 0.0, box, cl)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellListMap.jl#L25-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.merge_cell_lists!-Tuple{CellList, CellList}" href="#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}"><code>CellListMap.merge_cell_lists!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_cell_lists!(cl::CellList,aux::CellList)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Merges an auxiliary <code>aux</code> cell list to <code>cl</code>, and returns the modified <code>cl</code>. Used to merge cell lists computed in parallel threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L886-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.nbatches-Tuple{CellList}" href="#CellListMap.nbatches-Tuple{CellList}"><code>CellListMap.nbatches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nbatches(cl)</code></pre><p>Returns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list <code>cl</code>.  It returns the <code>cl.nbatches.map_computation</code> value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.</p><p>A second argument can be provided, which may be <code>:map</code> or <code>:build</code>, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(3,1000); box = Box([1,1,1],0.1);

julia&gt; cl = CellList(x,box,nbatches=(2,16));

julia&gt; nbatches(cl)
16

julia&gt; nbatches(cl,:map)
16

julia&gt; nbatches(cl,:build)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L240-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType" href="#CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType"><code>CellListMap.neighbor_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_cells(box::Box{UnitCellType,N}) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the iterator of the cartesian indices of all neighboring cells of a cell if the cells have sides of <code>box.cell_size</code>. <code>N</code> can be <code>2</code> or <code>3</code>, for two- or three-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L358-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType" href="#CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType"><code>CellListMap.neighbor_cells_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_cells_forward(box::Box{UnitCellType,N}) where UnitCellType </code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length <code>box.cell_size</code>. <code>N</code> can be <code>2</code> or <code>3</code>, for two- or three-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L323-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(x,y,r;parallel=true,autoswap=true)</code></pre><p>Computes the list of pairs of particles of <code>x</code> which are closer than <code>r</code> to the particles of <code>y</code>. The <code>autoswap</code> option will swap <code>x</code> and <code>y</code> to try to optimize the cost of the construction of the cell list. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; y = [ rand(3) for i in 1:1_000 ];

julia&gt; CellListMap.neighborlist(x,y,0.05)
5006-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 269, 0.04770884036497686)
 (25, 892, 0.03850515231540869)
 ⋮
 (9952, 749, 0.048875643578313456)
 (9984, 620, 0.04101242499363183)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/utils.jl#L135-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(x,r;parallel=true)</code></pre><p>Computes the list of pairs of particles in <code>x</code> which are closer to each other than <code>r</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; CellListMap.neighborlist(x,0.05)
24848-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 1055, 0.022977369806392412)
 (1, 5086, 0.026650609138167428)
 ⋮
 (9989, 3379, 0.0467653507446483)
 (9989, 5935, 0.02432728985151653)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/utils.jl#L106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Box, Any}" href="#CellListMap.neighborlist-Tuple{Box, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(box, cl; parallel=true)</code></pre><p>Compute the neighbor list of a single set or set pairs of particles. Returns a vector of tuples with all indices of the particles that are within <code>box.cutoff</code>, and the distances.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:1000 ];

julia&gt; box = Box([1,1,1],0.02) 
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
  cutoff: 0.02
  number of computing cells on each dimension: [52, 52, 52]
  computing cell sizes: [0.02, 0.02, 0.02] (lcell: 1)
  Total number of cells: 140608

julia&gt; cl = CellList(x,box) # single set
CellList{3, Float64}
  999 cells with real particles.
  1126 particles in computing box, including images.


julia&gt; CellListMap.neighborlist(box,cl,parallel=false)
15-element Vector{Tuple{Int64, Int64, Float64}}:
 (187, 511, 0.010346860078531755)
 (203, 708, 0.010777737363239403)
 (296, 579, 0.018124283912224655)
 ⋮
 (584, 4, 0.016935844769524398)
 (725, 749, 0.019971874892397875)
 (773, 119, 0.01835233336121765)
 (927, 8, 0.011234110402648743)
</code></pre><p>To obtain the neighbor list (within the cutoff) between two sets of  particles, initialize the cell lists with the two sets: </p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:1000 ];

julia&gt; y = [ rand(3) for i in 1:1000 ];

julia&gt; box = Box([1,1,1],0.02);

julia&gt; cl = CellList(x,y,box)

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   997 cells with real particles of target vector.

julia&gt; CellListMap.neighborlist(box,cl)
35-element Vector{Tuple{Int64, Int64, Float64}}:
 (409, 982, 0.01634641594779082)
 (521, 422, 0.00919026348035512)
 (625, 731, 0.012986301890746663)
 ⋮
 (647, 730, 0.01565763971458105)
 (296, 668, 0.016556686306217868)
 (992, 589, 0.018392993428289553)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/utils.jl#L1-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.norm-Tuple{Any}" href="#CellListMap.norm-Tuple{Any}"><code>CellListMap.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::AbstractVector{T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own <code>norm(x) = norm_sqr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/linearalgebra.jl#L23-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>CellListMap.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_sqr(v::AbstractVector{T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/linearalgebra.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N" href="#CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N"><code>CellListMap.out_of_bounding_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">out_of_bounding_box(x::SVector{N},box::Box) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that evaluates if a particle is outside the computing bounding box, defined by the maximum and minimum unit cell coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L451-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N" href="#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N}, Box}} where N"><code>CellListMap.particle_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particle_cell(x::SVector{N,T}, box::Box) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Returns the coordinates of the <em>computing cell</em> to which a particle belongs, given its coordinates and the <code>cell_size</code> vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes <code>Box.lcell + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L383-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.particles_per_cell-Tuple{CellList}" href="#CellListMap.particles_per_cell-Tuple{CellList}"><code>CellListMap.particles_per_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particles_per_cell(cl)</code></pre><p>Returns the average number of real particles per computing cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L1235-L1243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.partition!-Tuple{Any, AbstractVector}" href="#CellListMap.partition!-Tuple{Any, AbstractVector}"><code>CellListMap.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition!(x::AbstractVector,by)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that reorders <code>x</code> vector by putting in the first positions the elements with values satisfying <code>by(el)</code>. Returns the number of elements that satisfy the condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CoreComputing.jl#L71-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}" href="#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}"><code>CellListMap.project_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Projects all particles of the cell <code>cellⱼ</code> into unnitary vector <code>Δc</code> with direction  connecting the centers of <code>cellⱼ</code> and <code>cellᵢ</code>. Modifies <code>projected_particles</code>, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CoreComputing.jl#L295-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T}}} where T" href="#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T}}} where T"><code>CellListMap.ranges_of_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{2,2,T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that sets which is the range of periodic images necessary to fill the computing box, in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L695-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T}}} where T" href="#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T}}} where T"><code>CellListMap.ranges_of_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that sets which is the range of periodic images necessary to fill the computing box, in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L653-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.reduce-Tuple{Number, Vector{&lt;:Number}}" href="#CellListMap.reduce-Tuple{Number, Vector{&lt;:Number}}"><code>CellListMap.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(output, output_threaded)</code></pre><p>Functions to reduce the output of common options (vectors of numbers  and vectors of vectors). This function can be replacted by custom reduction methods. It always must both receive the <code>output</code> variable as a parameter, and return it at the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CoreComputing.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N}, Any, Any}} where N" href="#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N}, Any, Any}} where N"><code>CellListMap.replicate_particle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replicate_particle!(ip,p::SVector{N},box,cl) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Replicates the particle as many times as necessary to fill the computing box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L476-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArrays.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}" href="#CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArrays.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}"><code>CellListMap.replicate_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replicate_system!(x::AbstractVector,box::Box,ranges::Tuple)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Replicate the system (modifying the original array of coordinates) in all directions defined by the periodic system and by the range of unitary cells  of interest. <code>x</code> can be a <code>(N,M)</code> matrix, and the unit cell matrix can be provided instead of the <code>box</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{2,Float64},100);

julia&gt; box = Box([1,1],0.1);

julia&gt; CellListMap.replicate_system!(x,box,(0:0,-1:1))
300-element Vector{SVector{2, Float64}}:
 [0.7119987163255118, 0.6788616154460262]
 [0.6188407316804118, 0.8497116428720384]
 [0.21328895963244354, 0.48932085643862977]
 ⋮
 [0.4114499470191678, 1.1034376619603892]
 [0.6094126258851252, 1.2328989485215263]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L261-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}" href="#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}"><code>CellListMap.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset!(cl::CellList{N,T},box,n_real_particles) where{N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Resets a cell list, by setting everything to zero, but retaining the allocated <code>particles</code> and <code>projected_particles</code> vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L462-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}" href="#CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}"><code>CellListMap.set_number_of_batches!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_number_of_batches!(cl,nbatches::Tuple{Int,Int}=(0,0))  </code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Functions that set the default number of batches for the construction of the cell lists,  and mapping computations. This is of course heuristic, and may not be the best choice for every problem. See the parameter <code>nbatches</code> of the construction of the cell lists for  tunning this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellLists.jl#L182-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}" href="#CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::AbstractVector{&lt;:AbstractVector},unit_cell_matrix,indices)</code></pre><p>Translates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{2,Float64},100);

julia&gt; box = Box([1,1],0.1);

julia&gt; CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))
100-element Vector{SVector{2, Float64}}:
 [1.847791110439223, 1.5989103939725295]
 [1.3493293666090889, 1.4002971843576644]
 [1.4111736701313218, 1.3471780214994182]
 ⋮
 [1.1548437388991908, 1.7034501001177493]
 [1.4066300885242247, 1.2907398318754952]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L227-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}" href="#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Translate vector <code>x</code> according to the <code>unit_cell_matrix</code> lattice vectors and the <code>indices</code> provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L210-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.view_celllist_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_celllist_particles(cl::CellList)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Auxiliary function to view the particles of a computing box, including images created for computing purposes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([ 100 50; 50 100 ],10);

julia&gt; x = [ box.unit_cell_max .* rand(SVector{2,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; p = CellListMap.view_celllist_particles(cl);

julia&gt; using Plots

julia&gt; scatter(Tuple.(p),label=nothing,xlims=(-10,180),ylims=(-10,180))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/testing.jl#L44-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_cell_fraction-Tuple{Any, Any}" href="#CellListMap.wrap_cell_fraction-Tuple{Any, Any}"><code>CellListMap.wrap_cell_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_cell_fraction(x,unit_cell_matrix)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Obtaint the coordinates of <code>x</code> as a fraction of unit cell vectors, first positive cell. <code>x</code> is a vector of dimension <code>N</code> and <code>cell</code> a matrix of  dimension <code>NxN</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell_matrix = [ 10 0
                            0 10 ];

julia&gt; x = [ 15, 13 ];

julia&gt; wrap_cell_fraction(x,unit_cell_matrix)
2-element Vector{Float64}:
 0.5
 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L16-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}" href="#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,sides::AbstractVector)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, for an Orthorhombic cell of which only the side lengths are provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L178-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T}}} where {N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T}}} where {N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,box::Box{OrthorhombicCell,N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, given an Orthorhombic cell. This is slightly cheaper than for general cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L159-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T}}} where {N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T}}} where {N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, given a general <code>Box</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Tuple{Any, Any}" href="#CellListMap.wrap_to_first-Tuple{Any, Any}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,unit_cell_matrix)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell_matrix = [ 10 0
                            0 10 ];

julia&gt; x = [ 15, 13 ];

julia&gt; wrap_to_first(x,unit_cell_matrix)
2-element Vector{Float64}:
 5.0
 3.0000000000000004</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L51-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Tuple{Any, Box}" href="#CellListMap.wrap_to_first-Tuple{Any, Box}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,box::Box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates, given the <code>Box</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L84-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T}}} where {N, T}" href="#CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T}}} where {N, T}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,box::Box{OrthorhombicCell,N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates, given an Orthorhombic cell.  This is slightly cheaper than for general cells.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/1d218962b3fc7e91200950faf8f06b48ba855c23/src/CellOperations.jl#L100-L114">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../python/">« From Python</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 21 December 2021 21:15">Tuesday 21 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
