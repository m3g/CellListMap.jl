<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Help entries · CellListMap.jl</title><meta name="title" content="Help entries · CellListMap.jl"/><meta property="og:title" content="Help entries · CellListMap.jl"/><meta property="twitter:title" content="Help entries · CellListMap.jl"/><meta name="description" content="Documentation for CellListMap.jl."/><meta property="og:description" content="Documentation for CellListMap.jl."/><meta property="twitter:description" content="Documentation for CellListMap.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../PeriodicSystems/">PeriodicSystems interface</a></li><li><a class="tocitem" href="../neighborlists/">Neighbor lists</a></li><li><a class="tocitem" href="../LowLevel/">Low level interface</a></li><li><a class="tocitem" href="../ecosystem/">Ecosystem integration</a></li><li><a class="tocitem" href="../python/">From Python</a></li><li class="is-active"><a class="tocitem" href>Help entries</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Help entries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Help entries</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl/blob/main/docs/src/help.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Help-entries"><a class="docs-heading-anchor" href="#Help-entries">Help entries</a><a id="Help-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Help-entries" title="Permalink"></a></h1><p>These entries can be viewed at the <code>Julia</code> REPL <code>Julia</code> using </p><pre><code class="language-julia-repl hljs">julia&gt; ? 
help?&gt; function_name</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.AuxThreaded" href="#CellListMap.AuxThreaded"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AuxThreaded{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>particles_per_batch::Int64</code></p></li><li><p><code>idxs::Vector{UnitRange{Int64}}</code>: Default: Vector{UnitRange{Int}}(undef, 0)</p></li><li><p><code>lists::Array{CellList{N, T}, 1} where {N, T}</code>: Default: Vector{CellList{N, T}}(undef, 0)</p></li></ul><p>Auxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L314-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}" href="#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellListPair{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type for lists of disjoint particle sets,  to be passed to <code>UpdateCellList!</code> for in-place update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L415-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellList{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type, to be passed to <code>UpdateCellList!</code> for in-place  update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for _ in 1:100_000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L338-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box" href="#CellListMap.Box"><code>CellListMap.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Box{UnitCellType, N, T, TSQ, M, TR}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>input_unit_cell::CellListMap.UnitCell</code></p></li><li><p><code>aligned_unit_cell::CellListMap.UnitCell</code></p></li><li><p><code>rotation::StaticArraysCore.SMatrix{N, N, TR, M} where {N, M, TR}</code></p></li><li><p><code>inv_rotation::StaticArraysCore.SMatrix{N, N, TR, M} where {N, M, TR}</code></p></li><li><p><code>lcell::Int64</code></p></li><li><p><code>nc::StaticArraysCore.SVector{N, Int64} where N</code></p></li><li><p><code>cutoff::Any</code></p></li><li><p><code>cutoff_sqr::Any</code></p></li><li><p><code>computing_box::Tuple{StaticArraysCore.SVector{N, T}, StaticArraysCore.SVector{N, T}} where {N, T}</code></p></li><li><p><code>cell_size::StaticArraysCore.SVector</code></p></li></ul><p>Structure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; sides = [250,250,250];

julia&gt; cutoff = 10;

julia&gt; box = Box(sides,cutoff)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]
  cutoff: 10.0
  number of computing cells on each dimension: [27, 27, 27]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 19683
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; box = Box([ 10  0  0 
                    0 10  5
                    0  0 10 ], 1)
Box{TriclinicCell, 3, Float64, 9}
unit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]
cutoff: 1.0
number of computing cells on each dimension: [12, 17, 12]
computing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)
Total number of cells: 2448
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L41-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T" href="#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(unitcell::Limits, cutoff; lcell::Int=1)</code></pre><p>This constructor receives the output of <code>limits(x)</code> or <code>limits(x,y)</code> where <code>x</code> and <code>y</code> are the coordinates of the particles involved, and constructs a <code>Box</code> with size larger than the maximum coordinates ranges of all particles plus twice the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is an <code>NonPeriodicCell</code> box type, which internally is treated as Orthorhombic with boundaries that guarantee that particles do not see images of each other. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x),10)
Box{NonPeriodicCell, 3}
  unit cell matrix = [ 110.0, 0.0, 0.0; 0.0, 110.0, 0.0; 0.0, 0.0, 110.0 ]
  cutoff = 10.0
  number of computing cells on each dimension = [12, 12, 12]
  computing cell sizes = [11.0, 11.0, 11.0] (lcell: 1)
  Total number of cells = 1728

julia&gt; y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x,y),10)
Box{NonPeriodicCell, 3}
  unit cell matrix = [ 160.0, 0.0, 0.0; 0.0, 160.0, 0.0; 0.0, 0.0, 110.0 ]
  cutoff = 10.0
  number of computing cells on each dimension = [17, 17, 12]
  computing cell sizes = [10.67, 10.67, 11.0] (lcell: 1)
  Total number of cells = 3468</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L353-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(unit_cell_matrix::AbstractMatrix, cutoff, lcell::Int=1, UnitCellType=TriclinicCell)</code></pre><p>Construct box structure given the cell matrix of lattice vectors. This  constructor will always return a <code>TriclinicCell</code> box type, unless the <code>UnitCellType</code> parameter is set manually to <code>OrthorhombicCell</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell = [ 100   50    0 
                       0  120    0
                       0    0  130 ];

julia&gt; box = Box(unit_cell,10)
Box{TriclinicCell, 3, Float64, 9}
  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]
  cutoff: 10.0
  number of computing cells on each dimension: [17, 14, 15]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 3570
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L164-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(sides::AbstractVector, cutoff, lcell::Int=1, UnitCellType=OrthorhombicCell)</code></pre><p>For orthorhombic unit cells, <code>Box</code> can be initialized with a vector of the length of each side. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([120,150,100],10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]
  cutoff: 10.0
  number of computing cells on each dimension: [14, 17, 12]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 2856
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L328-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Cell" href="#CellListMap.Cell"><code>CellListMap.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Cell{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>linear_index::Int64</code></p></li><li><p><code>cartesian_index::CartesianIndex</code></p></li><li><p><code>center::StaticArraysCore.SVector</code></p></li><li><p><code>contains_real::Bool</code></p></li><li><p><code>n_particles::Int64</code></p></li><li><p><code>particles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}</code></p></li></ul><p>This structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighboring cells need to be wrapped) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList" href="#CellListMap.CellList"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellList{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>n_real_particles::Int64</code>:  Number of real particles.</p></li><li><p><code>number_of_cells::Int64</code>:  Number of cells.</p></li><li><p><code>n_particles::Int64</code>:  <em>mutable</em> number of particles in the computing box.</p></li><li><p><code>n_cells_with_real_particles::Int64</code>:  <em>mutable</em> number of cells with real particles.</p></li><li><p><code>n_cells_with_particles::Int64</code>:  <em>mutable</em> number of cells with particles, real or images.</p></li><li><p><code>cell_indices::Vector{Int64}</code>:  Auxiliary array that contains the indexes in list of the cells with particles, real or images.</p></li><li><p><code>cell_indices_real::Vector{Int64}</code>:  Auxiliary array that contains the indexes in the cells with real particles.</p></li><li><p><code>cells::Array{CellListMap.Cell{N, T}, 1} where {N, T}</code>:  Vector containing cell lists of cells with particles.</p></li><li><p><code>nbatches::CellListMap.NumberOfBatches</code>:  Number of batches for the parallel calculations.</p></li><li><p><code>projected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}</code>:  Auxiliar array to store projected particles.</p></li></ul><p>Structure that contains the cell lists information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L125-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L599-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L490-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0),
    autoswap::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Function that will initialize a <code>CellListPair</code> structure from scratch, given two vectors of particle coordinates and a <code>Box</code>, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using <code>autoswap=false</code> the cell list is constructed for the second (<code>y</code>)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   10000 particles in the reference vector.
   961 cells with real particles of target vector.

julia&gt; cl = CellList(x,y,box,autoswap=false)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   7389 cells with real particles of target vector.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L540-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{&lt;:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0,0)
) where {UnitCellType,N,T}</code></pre><p>Function that will initialize a <code>CellList</code> structure from scratch, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a <code>Box</code>, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box)
CellList{3, Float64}
  100000 real particles.
  15600 cells with real particles.
  126276 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L446-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.CellListPair" href="#CellListMap.CellListPair"><code>CellListMap.CellListPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellListPair{V, N, T, Swap}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>ref::Any</code></p></li><li><p><code>target::CellList</code></p></li></ul><p>Structure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L178-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.InPlaceNeighborList" href="#CellListMap.InPlaceNeighborList"><code>CellListMap.InPlaceNeighborList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct InPlaceNeighborList{B, C, A, NB&lt;:CellListMap.NeighborList}</code></pre><p>Internal function or structure - interface may change.</p><p>Structure that containst the system information for neighborlist computations. All fields are internal.</p><p><strong>Extended help</strong></p><ul><li><p><code>box::Any</code></p></li><li><p><code>cl::Any</code></p></li><li><p><code>aux::Any</code></p></li><li><p><code>nb::CellListMap.NeighborList</code></p></li><li><p><code>nb_threaded::Vector{NB} where NB&lt;:CellListMap.NeighborList</code></p></li><li><p><code>parallel::Bool</code></p></li><li><p><code>show_progress::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/neighborlists.jl#L78-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.InPlaceNeighborList-Union{Tuple{}, Tuple{T}} where T" href="#CellListMap.InPlaceNeighborList-Union{Tuple{}, Tuple{T}} where T"><code>CellListMap.InPlaceNeighborList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InPlaceNeighborList(;
    x::AbstractVecOrMat,
    y::Union{AbstractVecOrMat,Nothing}=nothing,
    cutoff::T,
    unitcell::Union{AbstractVecOrMat,Nothing}=nothing,
    parallel::Bool=true,
    show_progress::Bool=false,
) where {T}</code></pre><p>Function that initializes the <code>InPlaceNeighborList</code> structure, to be used for in-place computation of neighbor lists.</p><ul><li>If only <code>x</code> is provided, the neighbor list of the set is computed. </li><li>If <code>x</code> and <code>y</code> are provided, the neighbor list between the sets is computed.</li><li>If <code>unitcell</code> is provided, periodic boundary conditions will be used. The <code>unitcell</code> can be a vector of Orthorhombic box sides, or an actual unitcell matrix for general cells. </li><li>If <code>unicell</code> is not provide (value <code>nothing</code>), no periodic boundary conditions will be considered. </li></ul><p><strong>Examples</strong></p><p>Here the neighborlist structure is constructed for the first time, and used to compute the neighbor lists with the mutating <code>neighborlist!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap, StaticArrays

julia&gt; x = rand(SVector{3,Float64}, 10^4);

julia&gt; system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]) 
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{OrthorhombicCell, 3, Float64, Float64, 9}
Current list buffer size: 0

julia&gt; neighborlist!(system)
210034-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 357, 0.09922225615002134)
 (1, 488, 0.043487074695938925)
 (1, 2209, 0.017779967072139684)
 ⋮
 (9596, 1653, 0.0897570322108541)
 (9596, 7927, 0.0898266280344037)</code></pre><p>The coordinates of the system, its unitcell, or the cutoff can be changed with the <code>update!</code> function. If the number of pairs of the list does not change  significantly, the new calculation is minimally allocating, or non-allocating  at all, in particular if the computation is run without parallelization:</p><p>If the structure is used repeatedly for similar systems, the allocations will vanish, except for minor allocations used in the threading computation (if a  non-parallel computation is executed, the allocations will vanish completely):</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{3,Float64}, 10^4);

julia&gt; system = InPlaceNeighborList(x=x, cutoff=0.1, unitcell=[1,1,1]);

julia&gt; @time neighborlist!(system);
  0.008004 seconds (228 allocations: 16.728 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.024811 seconds (167 allocations: 7.887 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.005213 seconds (164 allocations: 1.439 MiB)

julia&gt; update!(system, rand(SVector{3,Float64}, 10^4); cutoff = 0.1, unitcell = [1,1,1]);

julia&gt; @time neighborlist!(system);
  0.005276 seconds (162 allocations: 15.359 KiB)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/neighborlists.jl#L101-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Limits" href="#CellListMap.Limits"><code>CellListMap.Limits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Limits{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><code>limits::StaticArraysCore.SVector</code></li></ul><p>Structure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.NumberOfBatches" href="#CellListMap.NumberOfBatches"><code>CellListMap.NumberOfBatches</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NumberOfBatches</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>build_cell_lists::Int64</code></p></li><li><p><code>map_computation::Int64</code></p></li></ul><p>Structure to define the number of batches used in the parallel splitting of the calculations of the cell list construction and of the <code>map_pairwise</code> computation. It is initialized with a standard heuristic that returns at most the number of threads, but may return a smaller number if the system is small. The two parameters can be tunned for optimal performance of each step of the calculation (cell list construction and mapping of interactions). The construction of the cell lists require a larger number of particles for threading to be effective, Thus by default the system size that allows multi-threading is greater for this part of the calculation.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.ParticleWithIndex" href="#CellListMap.ParticleWithIndex"><code>CellListMap.ParticleWithIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParticleWithIndex{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>index::Int64</code></p></li><li><p><code>real::Bool</code></p></li><li><p><code>coordinates::StaticArraysCore.SVector</code></p></li></ul><p>Copies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.ProjectedParticle" href="#CellListMap.ProjectedParticle"><code>CellListMap.ProjectedParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProjectedParticle{N, T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><ul><li><p><code>index::Int64</code></p></li><li><p><code>xproj::Any</code></p></li><li><p><code>coordinates::StaticArraysCore.SVector</code></p></li></ul><p>Auxiliary structure to contain projected particles. Types of  scalars are chosen such that with a <code>SVector{3,Float64}</code> the complete struct has 32bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L104-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.Swapped" href="#CellListMap.Swapped"><code>CellListMap.Swapped</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal function or structure - interface may change.</p><p>Structures to control dispatch on swapped vs. not swapped cell list pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellListPair,
    parallel=true
)</code></pre><p>Function that will update a previously allocated <code>CellListPair</code> structure, given  new updated particle positions, for example. This method will allocate new  <code>aux</code> threaded auxiliary arrays. For a non-allocating version, see the  <code>UpdateCellList!(x,y,box,cl,aux)</code> method.</p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; cl = UpdateCellList!(x,y,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L1080-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}" href="#CellListMap.UpdateCellList!-Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellList,
    parallel=true
)</code></pre><p>Function that will update a previously allocated <code>CellList</code> structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the <code>UpdateCellList!(x,box,cl,aux)</code> method instead. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; box = Box([260,260,260],10);

julia&gt; x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = UpdateCellList!(x,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L615-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair, Union{Nothing, CellListMap.AuxThreaded}}} where {UnitCellType, N}" href="#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair, Union{Nothing, CellListMap.AuxThreaded}}} where {UnitCellType, N}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box,
    cl_pair::CellListPair,
    aux::Union{Nothing,AuxThreaded};
    parallel::Bool=true
) where {UnitCellType,N}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L1258-L1272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair}} where {UnitCellType, N}" href="#CellListMap.UpdateCellList!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N}, CellListMap.CellListPair}} where {UnitCellType, N}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N},
    cl_pair::CellListPair;
    parallel::Bool=true
) where {UnitCellType,N}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L1123-L1136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap&lt;:CellListMap.NotSwapped}" href="#CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap&lt;:CellListMap.NotSwapped}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl_pair::CellListPair,
    aux::Union{Nothing,AuxThreaded};
    parallel::Bool=true
)</code></pre><p>This function will update the <code>cl_pair</code> structure that contains the cell lists for disjoint sets of particles. It receives the preallocated <code>aux</code> structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7381 cells with real particles of target vector.

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = UpdateCellList!(x,y,box,cl,aux)
CellList{3, Float64}
  10000 real particles.
  7358 cells with real particles.
  12591 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux)
  715.661 μs (41 allocations: 3.88 KiB)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7414 cells with real particles of target vector.
   
julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)
   13.042 ms (0 allocations: 0 bytes)
 CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
    50000 particles in the reference vector.
    15031 cells with real particles of target vector.
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L1151-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T},
    aux::Union{Nothing,AuxThreaded{N,T}};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L798-L811">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L660-L672">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl::CellList{N,T},
    aux::Union{Nothing,AuxThreaded{N,T}};
    parallel::Bool=true
) where {N,T}</code></pre><p>Function that updates the cell list <code>cl</code> new coordinates <code>x</code> and possibly a new box <code>box</code>, and receives a preallocated <code>aux</code> structure of auxiliary vectors for threaded cell list construction. Given a preallocated <code>aux</code> vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux)
  16.384 ms (41 allocations: 3.88 KiB)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)
  20.882 ms (0 allocations: 0 bytes)
CellList{3, Float64}
  100000 real particles.
  15603 cells with real particles.
  125896 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L684-L745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap._promote_types-Tuple{Any, Any}" href="#CellListMap._promote_types-Tuple{Any, Any}"><code>CellListMap._promote_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_promote_types(cell,cutoff)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Promotes the types of the unit cell matrix (or sides) and cutoff to floats if one or both were input as integers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particle_to_celllist!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particle_to_celllist!(
    ip,
    x::SVector{N,T},
    box,
    cl::CellList{N,T};
    real_particle::Bool=true
) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Adds one particle to the cell lists, updating all necessary arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L981-L996">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Add all particles in vector <code>x</code> to the cell list <code>cl</code>. <code>ishift</code> is the shift in particle index, meaning that particle <code>i</code> of vector <code>x</code> corresponds to the particle with original index <code>i+ishift</code>. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L824-L836">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.align_cell" href="#CellListMap.align_cell"><code>CellListMap.align_cell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">align_cell(m::StaticMatrix)
align_cell!(m::AbstractMatrix)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>These functions rotate the unit cell matrix such that the largest lattice vector is oriented along the x-axis and, for 3D cells, also that the the plane formed by the largest and  second largest lattice vectors is oriented perpendicular to the z-axis. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L334-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.append_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append_particles!(cell1::Cell,cell2::Cell)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Add the particles of <code>cell2</code> to <code>cell1</code>, updating the cell data and, if necessary, resizing (increasing) the <code>particles</code> array of <code>cell1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L881-L891">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_cartesian_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Given the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}" href="#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}"><code>CellListMap.cell_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Computes the geometric center of a computing cell, to be used in the projection of points. Returns a <code>SVector{N,T}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L587-L597">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_limits-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#CellListMap.cell_limits-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>CellListMap.cell_limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_limits(m::AbstractMatrix)</code></pre><p>Internal function or structure - interface may change.</p><p>For 2D and 3D matrices, returns the maximum and minimum coordinates of all vertices. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L590-L597">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_linear_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_linear_index(nc::SVector{N,Int}, indices) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Returns the index of the cell, in the 1D representation, from its cartesian coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L248-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}" href="#CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}"><code>CellListMap.cell_matrix_from_sides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_matrix_from_sides(sides::AbstractVector)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the Orthorhombic unit cell matrix given a sides vector. This function is type-unstable if the input is not static.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; CellListMap.cell_matrix_from_sides([1,1,1])
3×3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)×SOneTo(3):
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L290-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.cell_vertices-Tuple{AbstractMatrix}" href="#CellListMap.cell_vertices-Tuple{AbstractMatrix}"><code>CellListMap.cell_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_vertices(m::AbstractMatrix)</code></pre><p>Internal function or structure - interface may change.</p><p>Function that returns the vertices of a unit cell in 2D or 3D, given the unit cell matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L483-L490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.check_unit_cell-Tuple{Box}" href="#CellListMap.check_unit_cell-Tuple{Box}"><code>CellListMap.check_unit_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_unit_cell(box::Box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Checks if the unit cell satisfies the conditions for using the minimum-image convention. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L653-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.copydata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copydata!(cell1::Cell,cell2::Cell)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Copies the data from <code>cell2</code> to <code>cell1</code>, meaning that particles are copied element-wise from <code>cell2</code> to <code>cell1</code>, with the <code>particles</code> array of <code>cell1</code> being resized (increased) if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L852-L863">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.current_and_neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}" href="#CellListMap.current_and_neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}"><code>CellListMap.current_and_neighbor_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_and_neighbor_cells(box::Box{UnitCellType,N}) where {UnitCellType,N}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Returns an iterator over all neighbor cells, including the center one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L549-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}" href="#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}"><code>CellListMap.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>LinearAlgebra.dot</code> is slower than this for standard arrays (likely more accurate, but that is not relevant here).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/linearalgebra.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.draw_cell-Tuple{AbstractMatrix}" href="#CellListMap.draw_cell-Tuple{AbstractMatrix}"><code>CellListMap.draw_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_cell(m::AbstractMatrix; aspect_ratio=:auto)</code></pre><p>Internal function or structure - interface may change.</p><p>Draw the unit cell in a 2D or 3D plot. Requires <code>using Plots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L644-L651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.draw_cell_vertices-Tuple{AbstractMatrix}" href="#CellListMap.draw_cell_vertices-Tuple{AbstractMatrix}"><code>CellListMap.draw_cell_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_cell_vertices(m::AbstractMatrix)</code></pre><p>Internal function or structure - interface may change.</p><p>Function that returns the vertices of a unit cell matrix in 2D or 3D, as a vector of static vectors, in a proper order for ploting the cell (the first vertex, in the origin, is repeated at the end of the list, to close the figure)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L522-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType
draw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType</code></pre><p>Internal function or structure - interface may change.</p><p>This function creates a plot of the computing cell, in two dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/testing.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType</code></pre><p>Internal function or structure - interface may change.</p><p>This function creates a plot of the computing cell, in three dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/testing.jl#L348-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.fastmod1-Tuple{Any}" href="#CellListMap.fastmod1-Tuple{Any}"><code>CellListMap.fastmod1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fastmod1(x)</code></pre><p>Internal function or structure - interface may change.</p><p>Computes <code>mod(x,1)</code>, quickly, using <code>x - floor(x)</code>. Maybe irrelevant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.in_computing_box-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N" href="#CellListMap.in_computing_box-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N"><code>CellListMap.in_computing_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in_computing_box(x::SVector{N},box::Box) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that evaluates if a particle is inside the computing bounding box, defined by the maximum and minimum unit aligned cell coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L608-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}}" href="#CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:AbstractVector}}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x,y)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code> and <code>y</code>, to used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L308-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}" href="#CellListMap.limits-Tuple{AbstractVector{&lt;:AbstractVector}}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x)</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code>,  to be used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_naive!-Tuple{Function, Any, AbstractVector, Box}" href="#CellListMap.map_naive!-Tuple{Function, Any, AbstractVector, Box}"><code>CellListMap.map_naive!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_naive!(f::Function, output, x::AbstractVector, box::Box)
map_naive!(f::Function, output, x::AbstractVector, y::AbstractVector, box::Box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that uses the naive pairwise mapping algorithm, for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/testing.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise" href="#CellListMap.map_pairwise"><code>CellListMap.map_pairwise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)</code></pre><p>is an alias for <code>map_pairwise!</code> which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through <code>juliacall</code> does not accept the  bang as a valid character. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellListMap.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F" href="#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(
    f::Function,
    output,
    box::Box,
    cl::CellList
    ;parallel::Bool=true,
    show_progress::Bool=false
)</code></pre><p>This function will run over every pair of particles which are closer than  <code>box.cutoff</code> and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the <code>Box</code> structure.  If the distance is smaller than the cutoff, a function <code>f</code> of the  coordinates of the two particles will be computed. </p><p>The function <code>f</code> receives six arguments as input: </p><pre><code class="nohighlight hljs">f(x,y,i,j,d2,output)</code></pre><p>Which are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the <code>output</code> variable.  It has also to return the same <code>output</code> variable. Thus, <code>f</code> may or not  mutate <code>output</code>, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance <code>d2</code> is computed  internally for comparison with the  <code>cutoff</code>, and is passed to the <code>f</code> because many times it is used for the  desired computation. </p><p><strong>Example</strong></p><p>Computing the mean absolute difference in <code>x</code> position between random particles,  remembering the number of pairs of <code>n</code> particles is <code>n(n-1)/2</code>. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 100_000;

julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];

julia&gt; cl = CellList(x,box);

julia&gt; f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])

julia&gt; normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

julia&gt; avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -&gt; f(x,y,sum_dx), 0.0, box, cl)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellListMap.jl#L34-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}" href="#CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function,output,box::Box,cl::CellListPair)</code></pre><p>The same but to evaluate some function between pairs of the particles of the vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellListMap.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.merge_cell_lists!-Tuple{CellList, CellList}" href="#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}"><code>CellListMap.merge_cell_lists!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_cell_lists!(cl::CellList,aux::CellList)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Merges an auxiliary <code>aux</code> cell list to <code>cl</code>, and returns the modified <code>cl</code>. Used to merge cell lists computed in parallel threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L907-L917">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.nbatches-Tuple{CellList}" href="#CellListMap.nbatches-Tuple{CellList}"><code>CellListMap.nbatches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nbatches(cl)</code></pre><p>Returns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list <code>cl</code>.  It returns the <code>cl.nbatches.map_computation</code> value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.</p><p>A second argument can be provided, which may be <code>:map</code> or <code>:build</code>, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(3,1000); box = Box([1,1,1],0.1);

julia&gt; cl = CellList(x,box,nbatches=(2,16));

julia&gt; nbatches(cl)
16

julia&gt; nbatches(cl,:map)
16

julia&gt; nbatches(cl,:build)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L277-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}" href="#CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, N}}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N}"><code>CellListMap.neighbor_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_cells(box::Box{UnitCellType,N}) where {UnitCellType,N}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the iterator of the cartesian indices of all neighboring cells of a cell where the computing cell index is <code>box.lcell</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L530-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType" href="#CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType"><code>CellListMap.neighbor_cells_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbor_cells_forward(box::Box{UnitCellType,N}) where UnitCellType</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length <code>box.cell_size</code>. <code>N</code> can be <code>2</code> or <code>3</code>, for two- or three-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L498-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(
    x, y, cutoff; 
    unitcell=nothing, 
    parallel=true, 
    show_progress=false, 
    autoswap=true,
    nbatches=(0,0)
)</code></pre><p>Computes the list of pairs of particles of <code>x</code> which are closer than <code>r</code> to the particles of <code>y</code>. The <code>autoswap</code> option will swap <code>x</code> and <code>y</code> to try to optimize the cost of the construction of the cell list. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; y = [ rand(3) for i in 1:1_000 ];

julia&gt; CellListMap.neighborlist(x,y,0.05)
5006-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 269, 0.04770884036497686)
 (25, 892, 0.03850515231540869)
 ⋮
 (9952, 749, 0.048875643578313456)
 (9984, 620, 0.04101242499363183)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/neighborlists.jl#L533-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.neighborlist-Tuple{Any, Any}" href="#CellListMap.neighborlist-Tuple{Any, Any}"><code>CellListMap.neighborlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborlist(x, cutoff; unitcell=nothing, parallel=true, show_progress=false)</code></pre><p>Computes the list of pairs of particles in <code>x</code> which are closer to each other than <code>cutoff</code>. If the keyword parameter <code>unitcell</code> is provided (as a vector of sides or a general unit cell matrix, periodic boundary conditions are considered). </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; neighborlist(x,0.05)
24848-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 1055, 0.022977369806392412)
 (1, 5086, 0.026650609138167428)
 ⋮
 (9989, 3379, 0.0467653507446483)
 (9989, 5935, 0.02432728985151653)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/neighborlists.jl#L491-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.norm-Tuple{Any}" href="#CellListMap.norm-Tuple{Any}"><code>CellListMap.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::AbstractVector{T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own <code>norm(x) = norm_sqr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/linearalgebra.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>CellListMap.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_sqr(v::AbstractVector{T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/linearalgebra.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.normalize-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#CellListMap.normalize-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>CellListMap.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(v::AbstractVector{T}) where T</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own <code>normalize(v)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/linearalgebra.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N" href="#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N"><code>CellListMap.particle_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particle_cell(x::SVector{N,T}, box::Box) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Returns the coordinates of the <em>computing cell</em> to which a particle belongs, given its coordinates and the <code>cell_size</code> vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes <code>Box.lcell + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L564-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.particles_per_cell-Tuple{CellList}" href="#CellListMap.particles_per_cell-Tuple{CellList}"><code>CellListMap.particles_per_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particles_per_cell(cl)</code></pre><p>Internal function or structure - interface may change.</p><p>Returns the average number of real particles per computing cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L1288-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.partition!-Tuple{Any, AbstractVector}" href="#CellListMap.partition!-Tuple{Any, AbstractVector}"><code>CellListMap.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition!(by, x::AbstractVector)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that reorders <code>x</code> vector by putting in the first positions the elements with values satisfying <code>by(el)</code>. Returns the number of elements that satisfy the condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CoreComputing.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.pathological_coordinates-Tuple{Any}" href="#CellListMap.pathological_coordinates-Tuple{Any}"><code>CellListMap.pathological_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathological_coordinates(N)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function to generate some coordinates with pathological properties, for testing. Returns <code>x</code>, <code>y</code>, <code>sides</code> and <code>cutoff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/testing.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}" href="#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}"><code>CellListMap.project_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Projects all particles of the cell <code>cellⱼ</code> into unnitary vector <code>Δc</code> with direction  connecting the centers of <code>cellⱼ</code> and <code>cellᵢ</code>. Modifies <code>projected_particles</code>, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CoreComputing.jl#L297-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T" href="#CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T"><code>CellListMap.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(output, output_threaded)</code></pre><p>Most common reduction function, which sums the elements of the output.  Here, <code>output_threaded</code> is a vector containing <code>nbatches(cl)</code> copies of the <code>output</code> variable (a scalar or an array). Custom reduction functions  must replace this one if the reduction operation is not a simple sum.  The <code>output_threaded</code> array is, by default, created automatically by copying the given <code>output</code> variable <code>nbatches(cl)</code> times. </p><p><strong>Examples</strong></p><p>Scalar reduction: </p><pre><code class="language-julia-repl hljs">julia&gt; output = 0.; output_threaded = [ 1, 2 ];

julia&gt; CellListMap.reduce(output,output_threaded)
3</code></pre><p>Array reduction:</p><pre><code class="language-julia-repl hljs">julia&gt; output = [0,0]; output_threaded = [ [1,1], [2,2] ];

julia&gt; CellListMap.reduce(output,output_threaded)
2-element Vector{Int64}:
 3
 3

julia&gt; output
2-element Vector{Int64}:
 3
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CoreComputing.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N}, Any, Any}} where N" href="#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N}, Any, Any}} where N"><code>CellListMap.replicate_particle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replicate_particle!(ip,p::SVector{N},box,cl) where N</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Replicates the particle as many times as necessary to fill the computing box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L631-L640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArraysCore.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}" href="#CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArraysCore.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}"><code>CellListMap.replicate_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replicate_system!(
    x::AbstractVector{SVector{N,T}},
    unit_cell_matrix::AbstractMatrix,
    ranges::Tuple
) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Replicate the system (modifying the original array of coordinates) in all directions defined by the periodic system and by the range of unitary cells  of interest. <code>x</code> can be a <code>(N,M)</code> matrix, and the unit cell matrix can be provided instead of the <code>box</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{2,Float64},100);

julia&gt; box = Box([1,1],0.1);

julia&gt; CellListMap.replicate_system!(x,box,(0:0,-1:1))
300-element Vector{SVector{2, Float64}}:
 [0.7119987163255118, 0.6788616154460262]
 [0.6188407316804118, 0.8497116428720384]
 [0.21328895963244354, 0.48932085643862977]
 ⋮
 [0.4114499470191678, 1.1034376619603892]
 [0.6094126258851252, 1.2328989485215263]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L173-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}" href="#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}"><code>CellListMap.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset!(cl::CellList{N,T},box,n_real_particles) where{N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Resets a cell list, by setting everything to zero, but retaining the allocated <code>particles</code> and <code>projected_particles</code> vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L504-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.set_idxs!-Tuple{Any, Any, Any}" href="#CellListMap.set_idxs!-Tuple{Any, Any, Any}"><code>CellListMap.set_idxs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_idxs!(idxs, n_particles, nbatches)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Sets the indexes of the particles that will be considered for each batch in parallel runs. Modifies the <code>idxs</code> array of ranges, which is usually the <code>aux.idxs</code> array of the the  corresponding <code>AuxThreaded</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L388-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}" href="#CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}"><code>CellListMap.set_number_of_batches!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_number_of_batches!(cl,nbatches::Tuple{Int,Int}=(0,0);parallel=true)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Functions that set the default number of batches for the construction of the cell lists,  and mapping computations. This is of course heuristic, and may not be the best choice for every problem. See the parameter <code>nbatches</code> of the construction of the cell lists for  tunning this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellLists.jl#L205-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}" href="#CellListMap.translation_image-Tuple{AbstractVector{&lt;:AbstractVector}, Any, Any}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::AbstractVector{&lt;:AbstractVector},unit_cell_matrix,indices)</code></pre><p>Translates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{2,Float64},100);

julia&gt; box = Box([1,1],0.1);

julia&gt; CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))
100-element Vector{SVector{2, Float64}}:
 [1.847791110439223, 1.5989103939725295]
 [1.3493293666090889, 1.4002971843576644]
 [1.4111736701313218, 1.3471780214994182]
 ⋮
 [1.1548437388991908, 1.7034501001177493]
 [1.4066300885242247, 1.2907398318754952]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L141-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any, Any}} where {N, T}" href="#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any, Any}} where {N, T}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Translate vector <code>x</code> according to the <code>unit_cell_matrix</code> lattice vectors and the <code>indices</code> provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L127-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.unitcelltype-Union{Tuple{Box{T}}, Tuple{T}} where T" href="#CellListMap.unitcelltype-Union{Tuple{Box{T}}, Tuple{T}} where T"><code>CellListMap.unitcelltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcelltype(::Box{T}) where T = T</code></pre><p>Returns the type of a unitcell from the <code>Box</code> structure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([1,1,1], 0.1)

julia&gt; unitcelltype(box)
OrthorhombicCell

julia&gt; box = Box([1 0 0; 0 1 0; 0 0 1], 0.1)

julia&gt; unitcelltype(box)
TriclinicCell</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L100-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.update!-Union{Tuple{C}, Tuple{UnitCellType}, Tuple{InPlaceNeighborList{&lt;:Box{UnitCellType}, C}, AbstractVecOrMat}} where {UnitCellType, C&lt;:CellList}" href="#CellListMap.update!-Union{Tuple{C}, Tuple{UnitCellType}, Tuple{InPlaceNeighborList{&lt;:Box{UnitCellType}, C}, AbstractVecOrMat}} where {UnitCellType, C&lt;:CellList}"><code>CellListMap.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update!(system::InPlaceNeighborList, x::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)
update!(system::InPlaceNeighborList, x::AbstractVecOrMat, y::AbstractVecOrMat; cutoff=nothing, unitcell=nothing)</code></pre><p>Updates a <code>InPlaceNeighborList</code> system, by updating the coordinates, cutoff, and unitcell.</p><p><strong>Examples</strong></p><p><strong>For self-pairs computations</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(SVector{3,Float64}, 10^3);

julia&gt; system = InPlaceNeighborList(x=x; cutoff=0.1)
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{NonPeriodicCell, 3, Float64, Float64, 9}
Current list buffer size: 0

julia&gt; neighborlist!(system);

julia&gt; new_x = rand(SVector{3,Float64}, 10^3);

julia&gt; update!(system, new_x; cutoff = 0.05)
InPlaceNeighborList with types: 
CellList{3, Float64}
Box{NonPeriodicCell, 3, Float64, Float64, 9}
Current list buffer size: 1826

julia&gt; neighborlist!(system)
224-element Vector{Tuple{Int64, Int64, Float64}}:
 (25, 486, 0.03897345036790646)
 ⋮
 (723, 533, 0.04795768478723409)
 (868, 920, 0.042087156715720137)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/neighborlists.jl#L212-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.update_box-Union{Tuple{Box{UnitCellType, N, T, TSQ, M}}, Tuple{M}, Tuple{TSQ}, Tuple{T}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N, T, TSQ, M}" href="#CellListMap.update_box-Union{Tuple{Box{UnitCellType, N, T, TSQ, M}}, Tuple{M}, Tuple{TSQ}, Tuple{T}, Tuple{N}, Tuple{UnitCellType}} where {UnitCellType, N, T, TSQ, M}"><code>CellListMap.update_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_box(
    box::Box{UnitCellType,N,T,TSQ,M};
    unitcell::Union{Nothing,AbstractVector{T},AbstractMatrix{T},Limits,Tuple}=nothing,
    cutoff::Union{Nothing,T}=nothing,
    lcell::Union{Nothing,Int}=nothing
)</code></pre><p>Internal function or structure - interface may change.</p><p>Function that returns an updated system box in a type-stable manner, given possible  variations in the <code>unitcell</code>, <code>cutoff</code>, or <code>lcell</code> parameters. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/Box.jl#L397-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.view_celllist_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_celllist_particles(cl::CellList)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Auxiliary function to view the particles of a computing box, including images created for computing purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/testing.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.wrap_cell_fraction-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix}} where T" href="#CellListMap.wrap_cell_fraction-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix}} where T"><code>CellListMap.wrap_cell_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_cell_fraction(x,unit_cell_matrix)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Obtaint the coordinates of <code>x</code> as a fraction of unit cell vectors, first positive cell. <code>x</code> is a vector of dimension <code>N</code> and <code>cell</code> a matrix of  dimension <code>NxN</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell_matrix = [ 10 0
                            0 10 ];

julia&gt; x = [ 15, 13 ];

julia&gt; wrap_cell_fraction(x,unit_cell_matrix)
2-element Vector{Float64}:
 0.5
 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L11-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}" href="#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,sides::AbstractVector)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, for an Orthorhombic cell of which only the side lengths are provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SMatrix{N, N, T}}} where {N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SMatrix{N, N, T}}} where {N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.wrap_to_first-Tuple{Any, Any}" href="#CellListMap.wrap_to_first-Tuple{Any, Any}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,unit_cell_matrix)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell_matrix = [ 10 0
                            0 10 ];

julia&gt; x = [ 15, 13 ];

julia&gt; wrap_to_first(x,unit_cell_matrix)
2-element Vector{Float64}:
 5.0
 3.0000000000000004</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/CellOperations.jl#L49-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.PeriodicSystem1" href="#CellListMap.PeriodicSystems.PeriodicSystem1"><code>CellListMap.PeriodicSystems.PeriodicSystem1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PeriodicSystem1{OutputName, V, O, B, C, A} &lt;: CellListMap.PeriodicSystems.AbstractPeriodicSystem{OutputName}</code></pre><ul><li><p><code>xpositions::Any</code></p></li><li><p><code>output::Any</code></p></li><li><p><code>_box::Any</code></p></li><li><p><code>_cell_list::Any</code></p></li><li><p><code>_output_threaded::Vector</code></p></li><li><p><code>_aux::Any</code></p></li><li><p><code>parallel::Bool</code></p></li></ul><p>Structure that carries the information necessary for <code>map_pairwise!</code> computations, for systems with one set of positions (thus, replacing the loops over <code>N(N-1)</code>  pairs of particles of the set). </p><p>The <code>xpositions</code>, <code>output</code>, and <code>parallel</code> fields are considered part of the API, and you can retrive or mutate <code>xpositions</code>, retrieve the <code>output</code> or its elements, and set the computation to use or not parallelization by directly accessing these elements.</p><p>The other fileds of the structure (starting with <code>_</code>) are internal and must not  be modified or accessed directly. The construction of the <code>PeriodicSystem1</code> structure is done through the <code>PeriodicSystem(;xpositions, unitcell, cutoff, output)</code>  auxiliary function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L269-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.PeriodicSystem2" href="#CellListMap.PeriodicSystems.PeriodicSystem2"><code>CellListMap.PeriodicSystems.PeriodicSystem2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PeriodicSystem2{OutputName, V, O, B, C, A} &lt;: CellListMap.PeriodicSystems.AbstractPeriodicSystem{OutputName}</code></pre><ul><li><p><code>xpositions::Any</code></p></li><li><p><code>ypositions::Any</code></p></li><li><p><code>output::Any</code></p></li><li><p><code>_box::Any</code></p></li><li><p><code>_cell_list::Any</code></p></li><li><p><code>_output_threaded::Vector</code></p></li><li><p><code>_aux::Any</code></p></li><li><p><code>parallel::Bool</code></p></li></ul><p>Structure that carries the information necessary for <code>map_pairwise!</code> computations, for systems with two set of positions (thus, replacing the loops over <code>N×M</code>  pairs of particles, being <code>N</code> and <code>M</code> the number of particles of each set).</p><p>The <code>xpositions</code>, <code>ypositions</code>, <code>output</code>, and <code>parallel</code> fields are considered part of the API, and you can retrive or mutate positions, retrieve the <code>output</code> or its elements, and set the computation to use or not parallelization by directly accessing these elements.</p><p>The other fileds of the structure (starting with <code>_</code>) are internal and must not  be modified or accessed directly. The construction of the <code>PeriodicSystem1</code> structure is done through the <code>PeriodicSystem(;xpositions, ypositions, unitcell, cutoff, output)</code>  auxiliary function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L303-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.PeriodicSystem-Tuple{}" href="#CellListMap.PeriodicSystems.PeriodicSystem-Tuple{}"><code>CellListMap.PeriodicSystems.PeriodicSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeriodicSystem( 
    xpositions::AbstractVector{&lt;:AbstractVector},
    #or
    xpositions::AbstractVector{&lt;:AbstractVector},
    ypositions::AbstractVector{&lt;:AbstractVector},
    # and
    unitcell::AbstractVecOrMat,
    cutoff::Number,
    output::Any;
    output_name::Symbol,
    parallel::Bool=true,
    nbatches::Tuple{Int,Int}=(0, 0),
    autoswap::Bool = true
)</code></pre><p>Function that sets up the <code>PeriodicSystem</code> type given the positions of the particles.</p><ul><li><p>Positions can be provided as vectors of 2D or 3D vectors  (preferentially static vectors from <code>StaticArrays</code>).</p></li><li><p>If only the <code>xpositions</code> array is provided, a single set of coordinates  is considered, and the computation will be mapped for the <code>N(N-1)</code>  pairs of this set. </p></li><li><p>If the <code>xpositions</code> and <code>ypositions</code> arrays of coordinates are provided,  the computation will be mapped to the <code>N×M</code> pairs of particles,  being <code>N</code> and <code>M</code> the number of particles of each set of coordinates.</p></li></ul><p>The unit cell (either a vector for <code>Orthorhombic</code> cells or a  full unit cell matrix for <code>Triclinic</code> cells), the cutoff used for the construction of the cell lists and the output variable of the calculations.</p><p><code>output_name</code> can be set to a symbol that best identifies the output variable. For instance, if <code>output_name=:forces</code>, the forces can be retrieved from the structure using the <code>system.forces</code> notation.</p><p>The <code>parallel</code> and <code>nbatches</code> flags control the parallelization scheme of computations (see https://m3g.github.io/CellListMap.jl/stable/parallelization/#Number-of-batches)). By default the parallelization is turned on and <code>nbatches</code> is set with heuristics that may provide good efficiency in most cases. <code>autoswap = false</code> will guarantee that the cell lists will be buitl for the <code>ypositions</code> (by default they are constructed for the smallest set, which is faster).</p><p><strong>Example</strong></p><p>In these examples, we compute the sum of the squared distances between the particles that are within the cutoff:</p><p><strong>Single set of particles</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; positions = rand(SVector{3,Float64}, 100)
       unitcell = [1,1,1]
       cutoff = 0.1
       output = 0.0;

julia&gt; sys = PeriodicSystem(xpositions = positions, unitcell= [1.0,1.0,1.0], cutoff = 0.1, output = 0.0)
PeriodicSystem1 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.1
      number of computing cells on each dimension = [12, 12, 12]
      computing cell sizes = [0.1, 0.1, 0.1] (lcell: 1)
      Total number of cells = 1728
    CellListMap.CellList{3, Float64}
      100 real particles.
      96 cells with real particles.
      164 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 8
    Type of output variable: Float64

julia&gt; map_pairwise!((x,y,i,j,d2,output) -&gt; output += d2, sys)
0.14556244865996287</code></pre><p><strong>Two sets of particles</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; xpositions = rand(SVector{3,Float64}, 100)
       ypositions = rand(SVector{3,Float64}, 1000)
       unitcell = [1,1,1]
       cutoff = 0.1
       output = 0.0;

julia&gt; sys = PeriodicSystem(
           xpositions = xpositions, 
           ypositions = ypositions,
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           )
PeriodicSystem2 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.1
      number of computing cells on each dimension = [12, 12, 12]
      computing cell sizes = [0.1, 0.1, 0.1] (lcell: 1)
      Total number of cells = 1728
    CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64, CellListMap.Swapped}
       1000 particles in the reference vector.
       97 cells with real particles of target vector.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 8
    Type of output variable: Float64

julia&gt; map_pairwise!((x,y,i,j,d2,output) -&gt; output += d2, sys)
2.3568143238242314
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L27-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.UpdatePeriodicSystem!" href="#CellListMap.PeriodicSystems.UpdatePeriodicSystem!"><code>CellListMap.PeriodicSystems.UpdatePeriodicSystem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">UpdatePeriodicSystem!</code></pre><p>Internal function or structure - interface may change.</p><p>Updates the cell lists for periodic systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L776-L783">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems._reset_all_output!-Tuple{Any, Any}" href="#CellListMap.PeriodicSystems._reset_all_output!-Tuple{Any, Any}"><code>CellListMap.PeriodicSystems._reset_all_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_reset_all_output!(output, output_threaded)</code></pre><p>Internal function or structure - interface may change.</p><p>Function that resets the output variable and the threaded copies of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L456-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.copy_output-Tuple{Any}" href="#CellListMap.PeriodicSystems.copy_output-Tuple{Any}"><code>CellListMap.PeriodicSystems.copy_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_output(x)</code></pre><p>Function that defines how the <code>output</code> variable is copied. Identical to <code>Base.copy(x)</code> and implemented for the types in <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code>.</p><p>Other custom output types must have their <code>copy_output</code> method implemented.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems
# Custom data type
struct A x::Int end
# Custom output type (array of A)
output = [ A(0) for _ in 1:100 ]
# How to copy an array of `A`
PeriodicSystems.copy_output(v::Vector{A}) = [ x for x in v ]

# Alternativelly, in this case, one could have defined:
Base.copy(a::A) = a
PeriodicSystems.copy_output(v::Vector{A}) = copy(v)</code></pre><p>The user must guarantee that the copy is independent of the original array. For many custom types it is possible to define  <code>PeriodicSystems.copy_output(v::Vector{T}) where {T&lt;:CustomType} = deepcopy(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L368-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.get_computing_box-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem}" href="#CellListMap.PeriodicSystems.get_computing_box-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem}"><code>CellListMap.PeriodicSystems.get_computing_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_computing_box(sys::AbstractPeriodicSystem)</code></pre><p>Internal function or structure - interface may change.</p><p>Retrieves the computing box of the system. The computing box is large enough to contain all coordinates of the particles, plus the cutoff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L758-L766">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.map_pairwise!-Union{Tuple{F}, Tuple{F, CellListMap.PeriodicSystems.AbstractPeriodicSystem}} where F&lt;:Function" href="#CellListMap.PeriodicSystems.map_pairwise!-Union{Tuple{F}, Tuple{F, CellListMap.PeriodicSystems.AbstractPeriodicSystem}} where F&lt;:Function"><code>CellListMap.PeriodicSystems.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function, system; show_progress = true, update_lists = true)</code></pre><p>Function that maps the <code>f</code> function into all pairs of particles of <code>system</code> that are found to be within the <code>cutoff</code>. </p><p>The function <code>f</code> must be of the general form:</p><pre><code class="nohighlight hljs">function f(x,y,i,j,d2,output)
    # operate on particle coordinates, distance and indexes
    # update output
    return output
end</code></pre><p>where <code>x</code> and <code>y</code> are the coordinates (adjusted for the minimum image) of the two particles involved, <code>i</code> and <code>j</code> their indices in the original arrays of positions, <code>d2</code> their squared Euclidean distance, and <code>output</code> the current value of the <code>output</code> variable. The <code>output</code> variable must be updated within this function with the contribution of the two particles involved. </p><p>Thread-safety is taken care automatically in parallel executions.</p><p><code>map_pairwise</code> is an alias to <code>map_pairwise!</code> for syntax consistency when the <code>output</code> variable is immutable.</p><p>If <code>update_lists</code> is <code>false</code>, the cell lists will not be recomputed, this may be useful for computing a different function from the same coordinates.</p><p><strong>Example</strong></p><p>In this example we compute the sum of <code>1/(1+d)</code> where <code>d</code> is the distance between particles of a set, for <code>d &lt; cutoff</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; sys = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           );

julia&gt; map_pairwise((x,y,i,j,d2,output) -&gt; output += 1 / (1 + sqrt(d2)), sys)
1870.0274887950268</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L853-L900">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.reduce_output!-Union{Tuple{T}, Tuple{Function, T, Vector{T}}} where T" href="#CellListMap.PeriodicSystems.reduce_output!-Union{Tuple{T}, Tuple{Function, T, Vector{T}}} where T"><code>CellListMap.PeriodicSystems.reduce_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_output!(reducer::Function, output, output_threaded)</code></pre><p>Internal function or structure - interface may change.</p><p><strong>Extended help</strong></p><p>Function that defines how to reduce the vector of <code>output</code> variables, after a threaded computation. This function is implemented for <code>output</code> variables that are numbers,  and vectors or arrays of number of static arrays, as the sum of the values of the  threaded computations, which is the most common application, found in computing forces, energies, etc. </p><p>It may be interesting to implement custom <code>PeriodicSystems.reduce_output!</code> function for other types  of output variables, considering:</p><ul><li><p>The arguments of the function must be the return <code>output</code> value and a vector  <code>output_threaded</code> of <code>output</code> variables, which is created (automatically) by copying the output the number of times necessary for the multi-threaded computation. </p></li><li><p>The function <em>must</em> return the <code>output</code> variable, independently of it being mutable or immutable.</p></li></ul><p><code>reduce_output</code> is an alias to <code>reduce_output!</code> that can be used for consistency if the <code>output</code> variable is immutable.</p><p><strong>Example</strong></p><p>In this example we show how to obtain the minimum distance between two sets of particles. This requires a custom reduction function.</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems, StaticArrays
# Custom output type
struct MinimumDistance
    d::Float64
end
# Custom copy function for `Out`
PeriodicSystems.copy_output(d::MinimumDistance) = MinimumDistance(d.d)
# How to reset an array with elements of type `MinimumDistance`
PeriodicSystems.reset_output!(d::MinimumDistance) = MinimumDistance(+Inf)
# Custom reduction function (keep the minimum distance)
function PeriodicSystems.reduce_output!(
    output::MinimumDistance, 
    output_threaded::Vector{MinimumDistance}
)
    output = reset_output!(output)
    for i in eachindex(output_threaded)
        if output_threaded[i].d &lt; output.d
            output = output_threaded[i]
        end
    end
    return output
end
# Construct the system
sys = PeriodicSystem(;
    xpositions = rand(SVector{3,Float64}, 1000),
    ypositions = rand(SVector{3,Float64}, 1000),
    unitcell = [1,1,1],
    cutoff = 0.1,
    output = MinimumDistance(+Inf),
)

# Obtain the minimum distance between the sets
map_pairwise!((x,y,i,j,d2,output) -&gt; sqrt(d2) &lt; output.d ? MinimumDistance(sqrt(d2)) : output, sys)
# will output something like: MinimumDistance(0.00956913034767034)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L519-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.reducer!-Tuple{Any, Any}" href="#CellListMap.PeriodicSystems.reducer!-Tuple{Any, Any}"><code>CellListMap.PeriodicSystems.reducer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducer!(x,y)</code></pre><p>Function that defines how to reduce (combine, or merge) to variables computed in parallel to obtain a single instance of the variable with the reduced result.</p><p>The most commont <code>reducer</code> is the sum, and this is how it is implemented for <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code>. For example, when computin energies, or forces, the total energy is the sum of the energies. The force on one particle is the sum of the forces between the particle and every other particle. Thus, the implemented reducer is the sum: </p><pre><code class="nohighlight hljs">reducer(x,y) = +(x,y)</code></pre><p>However, in  many cases, reduction must be done differently. For instance, if the minimum distance between particles is to be computed, it is interesting to define a custom type and associated reducer. For example:</p><pre><code class="nohighlight hljs">struct MinimumDistance d::Float64 end
reducer(x::MinimumDistance, y::MinimumDistance) = MinimumDistance(min(x.d, y.d))</code></pre><p>The overloading of <code>reducer</code> allows the use of parallel computations for custom,  complex data types, containing different types of variables, fields, or sizes.</p><p>The appropriate behavior of the reducer should be carefuly inspected by the user to avoid spurious results. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L472-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.reset_output!-Tuple{Any}" href="#CellListMap.PeriodicSystems.reset_output!-Tuple{Any}"><code>CellListMap.PeriodicSystems.reset_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_output!(x)</code></pre><p>Function that defines how to reset (or zero) the <code>output</code> variable. For <code>Union{Number, StaticArraysCore.FieldVector, StaticArraysCore.SVector}</code> it is  implemented as <code>zero(x)</code>, and for <code>AbstractVecOrMat</code> containers of <code>Number</code>s or <code>SVector</code>s it is implemented as <code>fill!(x, zero(eltype(x))</code>.</p><p>Other custom output types must have their <code>reset_output!</code> method implemented.</p><p>The <code>reset_output!</code> function <em>must</em> return the <code>output</code> variable, being it mutable or immutable. <code>reset_output</code> is an alias for <code>reset_output!</code> that can be used for consistency if the <code>output</code> variable is immutable.</p><p><strong>Example</strong></p><p>In this example, we define a <code>reset_output</code> function that will set to <code>+Inf</code> the minimum distance between particles (not always resetting means zeroing).</p><pre><code class="language-julia hljs"># Custom data type
struct MinimumDistance d::Float64 end
# How to reset the minimum distance
PeriodicSystems.reset_output!(x::MinimumDistance) = MinimumDistance(+Inf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L412-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.resize_output!-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem, Int64}" href="#CellListMap.PeriodicSystems.resize_output!-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem, Int64}"><code>CellListMap.PeriodicSystems.resize_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_output!(sys::AbstractPeriodicSystem, n::Int)</code></pre><p>Resizes the output array and the auxiliary output arrays used for multithreading, if needed because of the system change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L609-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.update_cutoff!-Tuple{Any, Any}" href="#CellListMap.PeriodicSystems.update_cutoff!-Tuple{Any, Any}"><code>CellListMap.PeriodicSystems.update_cutoff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_cutoff!(system, cutoff)</code></pre><p>Function to update the <code>cutoff</code>` of the system. </p><p>This function can be used to update the system geometry in iterative schemes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; sys = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           );

julia&gt; update_cutoff!(sys, 0.2)
PeriodicSystem1 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.2
      number of computing cells on each dimension = [7, 7, 7]
      computing cell sizes = [0.2, 0.2, 0.2] (lcell: 1)
      Total number of cells = 343
    CellListMap.CellList{3, Float64}
      1000 real particles.
      620 cells with real particles.
      1746 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 12
    Type of output variable: Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L695-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.PeriodicSystems.update_unitcell!-Tuple{Any, Any}" href="#CellListMap.PeriodicSystems.update_unitcell!-Tuple{Any, Any}"><code>CellListMap.PeriodicSystems.update_unitcell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_unitcell!(system, unitcell)</code></pre><p>Function to update the unit cell of the system. The <code>unicell</code> must be of the  same type (<code>OrthorhombicCell</code> or <code>TriclinicCell</code>) of the original <code>system</code>  (changing the type of unit cell requires reconstructing the system).</p><p>The <code>unitcell</code> can be a <code>N×N</code> matrix or a vector of dimension <code>N</code>, where <code>N</code> is the dimension of the sytem (2D or 3D).</p><p>This function can be used to update the system geometry in iterative schemes, where the size of the simulation box changes during the simulation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; sys = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0
           );

julia&gt; update_unitcell!(sys, [1.2, 1.1, 1.0])
PeriodicSystem1 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.2, 0.0, 0.0; 0.0, 1.1, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.1
      number of computing cells on each dimension = [13, 13, 12]
      computing cell sizes = [0.11, 0.1, 0.1] (lcell: 1)
      Total number of cells = 2028
    CellListMap.CellList{3, Float64}
      1000 real particles.
      633 cells with real particles.
      1703 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 12
    Type of output variable: Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L627-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CellListMap.unitcelltype-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem}" href="#CellListMap.unitcelltype-Tuple{CellListMap.PeriodicSystems.AbstractPeriodicSystem}"><code>CellListMap.unitcelltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitcelltype(sys::AbstractPeriodicSystem)</code></pre><p>Returns the type of a unitcell from the <code>PeriodicSystem</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/8eaee37548cf68321a05d5ed6d2a077767726e2e/src/PeriodicSystems.jl#L215-L220">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../python/">« From Python</a><a class="docs-footer-nextpage" href="../citation/">Citation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 8 February 2024 11:35">Thursday 8 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
