<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PeriodicSystems interface · CellListMap.jl</title><meta name="title" content="PeriodicSystems interface · CellListMap.jl"/><meta property="og:title" content="PeriodicSystems interface · CellListMap.jl"/><meta property="twitter:title" content="PeriodicSystems interface · CellListMap.jl"/><meta name="description" content="Documentation for CellListMap.jl."/><meta property="og:description" content="Documentation for CellListMap.jl."/><meta property="twitter:description" content="Documentation for CellListMap.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="CellListMap.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>PeriodicSystems interface</a><ul class="internal"><li><a class="tocitem" href="#The-mapped-function"><span>The mapped function</span></a></li><li><a class="tocitem" href="#Potential-energy-example"><span>Potential energy example</span></a></li><li><a class="tocitem" href="#Computing-forces"><span>Computing forces</span></a></li><li><a class="tocitem" href="#Computing-both-energy-and-forces"><span>Computing both energy and forces</span></a></li><li><a class="tocitem" href="#Updating-coordinates,-unit-cell,-and-cutoff"><span>Updating coordinates, unit cell, and cutoff</span></a></li><li><a class="tocitem" href="#Computations-for-two-sets-of-particles"><span>Computations for two sets of particles</span></a></li><li><a class="tocitem" href="#Additional-execution-options"><span>Additional execution options</span></a></li><li><a class="tocitem" href="#Complete-example-codes"><span>Complete example codes</span></a></li></ul></li><li><a class="tocitem" href="../neighborlists/">Neighbor lists</a></li><li><a class="tocitem" href="../LowLevel/">Low level interface</a></li><li><a class="tocitem" href="../ecosystem/">Ecosystem integration</a></li><li><a class="tocitem" href="../python/">From Python</a></li><li><a class="tocitem" href="../help/">Help entries</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>PeriodicSystems interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PeriodicSystems interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/CellListMap.jl/blob/main/docs/src/PeriodicSystems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PeriodicSystems-interface"><a class="docs-heading-anchor" href="#PeriodicSystems-interface">PeriodicSystems interface</a><a id="PeriodicSystems-interface-1"></a><a class="docs-heading-anchor-permalink" href="#PeriodicSystems-interface" title="Permalink"></a></h1><p>The <code>PeriodicSystems</code> interface facilitates the use of <code>CellListMap</code> for the majority of cases. To use it, load the <code>PeriodicSystems</code> module directly, with:</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>This interface requires <code>CellListMap.jl</code> version <code>0.7.22</code> or greater.</li><li>The complete codes of the examples are at the end of this page, with examples of:<ul><li><a href="#Simple-energy-computation">Simple energy computation</a></li><li><a href="#Force-computation">Force computation</a></li><li><a href="#Energy-and-forces">Energy and forces</a></li><li><a href="#Two-sets-of-particles">Two sets of particles</a></li><li><a href="#Particle-simulation">Particle simulation</a></li></ul></li></ul></div></div><h2 id="The-mapped-function"><a class="docs-heading-anchor" href="#The-mapped-function">The mapped function</a><a id="The-mapped-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-mapped-function" title="Permalink"></a></h2><p>The function to be mapped for every pair of particles within the cutoff follows the same interface as the standard interface. It must be of the form</p><pre><code class="language-julia hljs">function f(x, y, i, j, d2, output)
    # update output variable
    return output
end</code></pre><p>where <code>x</code> and <code>y</code> are the positions of the particles, already wrapped relative to each other according to the periodic boundary conditions (a minimum-image set of positions), <code>i</code> and <code>j</code> are the indexes of the particles in the arrays of coordinates, <code>d2</code> is the squared distance between the particles, and <code>output</code> is the variable to be computed. </p><p>For example, computing the energy, as the sum of the inverse of the distance between particles, can be done with a function like:</p><pre><code class="language-julia hljs">function energy(d2,u)
    u += 1 / sqrt(d2)
    return u
end</code></pre><p>and the additional parameters required by the interface can be eliminated by the use of an anonymous function, directly on the call to the <code>map_pairwise</code> function:</p><pre><code class="language-julia hljs">u = map_pairwise((x,y,i,j,d2,u) -&gt; energy(d2,u), system)</code></pre><p>(what <code>system</code> is will be explained in the examples below).</p><p>Alternatively, the function might require additional parameters, such as the masses of the particles. In this case, we can use a closure to provide such data:</p><pre><code class="language-julia hljs">function energy(i,j,d2,u,masses)
    u += masses[i]*masses[j] / sqrt(d2)
    return u
end
const masses = # ... some masses
u = map_pairwise((x,y,i,j,d2,u) -&gt; energy(d2,u,masses), system)</code></pre><h2 id="Potential-energy-example"><a class="docs-heading-anchor" href="#Potential-energy-example">Potential energy example</a><a id="Potential-energy-example-1"></a><a class="docs-heading-anchor-permalink" href="#Potential-energy-example" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>output</code> of the <code>CellListMap</code> computation may be of any kind. Most commonly, it is an energy, a set of forces, or other data type that can be represented either as a number, an array of numbers, or an array of vectors (<code>SVectors</code> in particular), such as an arrays of forces.  </p><p>Additionally, the properties are frequently additive (the energy is the sum of the energy of the particles, or the forces are added by summation). </p><p>For these types of <code>output</code> data the usage of <code>CellListMap.PeriodicSystems</code> is the simplest, and does not require the implementation of any data-type dependent function. </p></div></div><p>For example, let us build a system of random particles in a cubic box, and compute an &quot;energy&quot;, which in this case is simply the sum of <code>1/d</code> over all pair of particles, within a cutoff.</p><p>The <code>PeriodicSystem</code> constructor receives the properties of the system and sets up automatically the most commonly used data structures necessary. </p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; system = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1.0,1.0,1.0], 
           cutoff = 0.1, 
           output = 0.0,
           output_name = :energy
       );</code></pre><p>Now, directly, let us compute a putative energy of the particles, assuming a simple formula which depends on the inverse of the distance between pairs:</p><pre><code class="language-julia-repl hljs">julia&gt; map_pairwise!((x,y,i,j,d2,energy) -&gt; energy += 1 / sqrt(d2), system)
30679.386366872823</code></pre><p>The <code>system.energy</code> field accesses the resulting value of the computation:</p><pre><code class="language-julia-repl hljs">julia&gt; system.energy
30679.386366872823</code></pre><p>because the <code>output_name</code> field was provided. If it is not provided, you can access the output value from the <code>system.output</code> field.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>Systems can be 2 or 3-dimensional. </li><li>The <code>unitcell</code> parameter may be either a vector, as in the example, or a unit cell matrix, for general boundary conditions.</li><li><code>Unitful</code> quantities can be provided, given appropriate types for all input parameters. </li></ul></div></div><h2 id="Computing-forces"><a class="docs-heading-anchor" href="#Computing-forces">Computing forces</a><a id="Computing-forces-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-forces" title="Permalink"></a></h2><p>Following the example above, let us compute the forces between the particles. We have to define the function that computes the force between a pair of particles and updates the array of forces:</p><pre><code class="language-julia hljs">function update_forces!(x,y,i,j,d2,forces)
    d = sqrt(d2)
    df = (1/d2)*(1/d)*(y - x)
    forces[i] += df
    forces[j] -= df
    return forces
end</code></pre><p>Importantly, the function <em>must</em> return the <code>forces</code> array to follow the API. </p><p>Now, let us setup the system with the new type of output variable, which will be now an array of forces with the same type as the positions:</p><pre><code class="language-julia-repl hljs">julia&gt; positions = rand(SVector{3,Float64},1000);

julia&gt; system = PeriodicSystem(
           xpositions = positions,
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = similar(positions),
           output_name = :forces
       );</code></pre><p>Let us note that the <code>forces</code> where reset upon the construction of the system:</p><pre><code class="language-julia-repl hljs">julia&gt; system.forces
1000-element Vector{SVector{3, Float64}}:
 [0.0, 0.0, 0.0]
 [0.0, 0.0, 0.0]
 ⋮
 [0.0, 0.0, 0.0]</code></pre><p>A call to <code>map_pairwise!</code> with the appropriate function definition will update the forces:</p><pre><code class="language-julia-repl hljs">julia&gt; map_pairwise!((x,y,i,j,d2,forces) -&gt; update_forces!(x,y,i,j,d2,forces), system)
1000-element Vector{SVector{3, Float64}}:
 [-151.19529230407284, 159.33819000196905, -261.3055111242796]
 [-173.02442398784672, -178.782819965489, 4.570607952876692]
 ⋮
 [-722.5400961501635, 182.65287417718935, 380.0394926753039]</code></pre><h2 id="Computing-both-energy-and-forces"><a class="docs-heading-anchor" href="#Computing-both-energy-and-forces">Computing both energy and forces</a><a id="Computing-both-energy-and-forces-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-both-energy-and-forces" title="Permalink"></a></h2><p>In this example we define a general type of <code>output</code> variable, for which custom copy, reset, and reduction functions must be defined. It can be followed for the computation of other general properties from the particle positions.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Interface to be implemented:</p><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Return</th><th style="text-align: left">What it does</th></tr><tr><td style="text-align: left"><code>copy_output(x::T)</code></td><td style="text-align: center">new instance of type <code>T</code></td><td style="text-align: left">Copies an element of the output type <code>T</code>.</td></tr><tr><td style="text-align: left"><code>reset_output!(x::T)</code></td><td style="text-align: center">mutated <code>x</code></td><td style="text-align: left">Resets (usually zero) the value of x to the initial value it must assume before mapping.  If <code>x</code> is immutable, the function can return a new instance of <code>T</code>.</td></tr><tr><td style="text-align: left"><code>reducer(x::T,y::T)</code></td><td style="text-align: center"><code>mutated x</code></td><td style="text-align: left">Reduces <code>x</code> and <code>y</code> into <code>x</code> (for example <code>x = x + y</code>). If <code>x</code> is immutable, returns a new instance of type <code>T</code>.</td></tr></table><p><strong>Remark:</strong> if the output is an array of an immutable type <code>T</code>, the methods above can be defined for single <em>instances</em> of <code>T</code>, which is simpler than for the arrays.</p></div></div><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems, StaticArrays</code></pre><p>The computation of energies and forces in a single call is an interesting example for the definition of a custom <code>output</code> type and the required interface functions.  Let us first define an output variable containing both quantities:</p><pre><code class="language-julia hljs">mutable struct EnergyAndForces
    energy::Float64
    forces::Vector{SVector{3,Float64}}
end</code></pre><p>Now we need to define what it means to copy, reset, and reduce this new type of output. We overload the default corresponding functions, for our new output type:</p><p>The copy method creates a new instance of the <code>EnergyAndForces</code> type, with copied data:</p><pre><code class="language-julia hljs">import CellListMap.PeriodicSystems: copy_output
copy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))</code></pre><p>The reset method will zero both the energy and all forces:</p><pre><code class="language-julia hljs">import CellListMap.PeriodicSystems: reset_output!
function reset_output!(output::EnergyAndForces)
    output.energy = 0.0
    for i in eachindex(output.forces)
        output.forces[i] = SVector(0.0, 0.0, 0.0)
    end
    return output
end</code></pre><p>The reduction function defines what it means to combine two output variables obtained on independent threads. In this case, we sum the energies and forces. Different reduction functions might be necessary for other custom types (for example if computing minimum distances).</p><pre><code class="language-julia hljs">import CellListMap.PeriodicSystems: reducer
function reducer(x::EnergyAndForces, y::EnergyAndForces)
    e_tot = x.energy + y.energy
    x.forces .+= y.forces
    return EnergyAndForces(e_tot, x.forces)
end</code></pre><p>Note that in the above example, we reuse the <code>x.forces</code> array in the return instance of <code>EnergyAndForces</code>. You must always reduce from right to left, and reuse the possible buffers of the first argument of the reducer (in this case, <code>x</code>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><ul><li>All these functions <strong>must</strong> return the modified <code>output</code> variable, to adhere to the interface.</li><li>The proper definition of a reduction function is crucial for correctness. Please verify your results if using the default reducer function, which sums the elements.</li></ul></div></div><p>Now we can proceed as before, defining a function that updates the output variable appropriately:</p><pre><code class="language-julia hljs">function energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)
    d = sqrt(d2)
    output.energy += 1/d
    df = (1/d2)*(1/d)*(y - x)
    output.forces[i] += df
    output.forces[j] -= df
    return output
end</code></pre><p>To finally define the system and compute the properties:</p><pre><code class="language-julia-repl hljs">positions = rand(SVector{3,Float64},1000);

system = PeriodicSystem(
    xpositions = positions,
    unitcell=[1.0,1.0,1.0], 
    cutoff = 0.1, 
    output = EnergyAndForces(0.0, similar(positions)),
    output_name = :energy_and_forces
);

map_pairwise((x,y,i,j,d2,output) -&gt; energy_and_forces!(x,y,i,j,d2,output), system);</code></pre><p>The output can be seen with the aliases of the <code>system.output</code> variable:</p><pre><code class="language-julia-repl hljs">julia&gt; system.energy_and_forces.energy
31696.94766439311

julia&gt; system.energy_and_forces.forces
1000-element Vector{SVector{3, Float64}}:
 [-338.1909601911842, 7.7663690656924445, 202.25889647151405]
 [33.67299655756128, 282.7581453168999, -79.09639223837306]
 ⋮
 [38.83014327604529, -204.45236278342745, 249.307871211616]</code></pre><h2 id="Updating-coordinates,-unit-cell,-and-cutoff"><a class="docs-heading-anchor" href="#Updating-coordinates,-unit-cell,-and-cutoff">Updating coordinates, unit cell, and cutoff</a><a id="Updating-coordinates,-unit-cell,-and-cutoff-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-coordinates,-unit-cell,-and-cutoff" title="Permalink"></a></h2><p>If the <code>map_pairwise!</code> function will compute energy and/or forces in a iterative procedure (a simulation, for instance), we need to update the coordinates, and perhaps the unit cell and the cutoff.</p><ul><li><a href="#Updating-coordinates">Updating coordinates</a></li><li><a href="#Updating-the-unit-cell">Updating the unit cell</a></li><li><a href="#Updating-the-cutoff">Updating the cutoff</a></li></ul><h3 id="Updating-coordinates"><a class="docs-heading-anchor" href="#Updating-coordinates">Updating coordinates</a><a id="Updating-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-coordinates" title="Permalink"></a></h3><p>The coordinates can be updated (mutated, or the array of coordinates can change in size by pushing or deleting particles), simply by directly accessing the <code>xpositions</code> field of the system. The <code>xpositions</code> array is a <code>Vector</code> of <code>SVector</code> (from <code>StaticArrays</code>), with coordinates copied from the input array provided. Thus, the coordinates in the <code>PeriodicSystem</code> structure must be updated independently of updates in the original array of coordinates. </p><p>Let us exemplify the interface with the computation of forces:</p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap.PeriodicSystems, StaticArrays

julia&gt; positions = rand(SVector{3,Float64}, 1000);

julia&gt; system = PeriodicSystem(
           xpositions = positions,
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = similar(positions),
           output_name = :forces
       );

julia&gt; system.xpositions[1]
3-element SVector{3, Float64} with indices SOneTo(3):
 0.6391290709055079
 0.43679325975360894
 0.8231829019768698

julia&gt; system.xpositions[1] = zeros(SVector{3,Float64})
3-element SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.0
 0.0

julia&gt; push!(system.xpositions, SVector(0.5, 0.5, 0.5))
1001-element Vector{SVector{3, Float64}}:
 [0.0, 0.0, 0.0]
 [0.5491373098208292, 0.23899915605319244, 0.49058287555218516]
 ⋮
 [0.4700394061063937, 0.5440026379397457, 0.7411235688716618]
 [0.5, 0.5, 0.5]</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>output</code> variable may have to be resized accordingly, depending on the calculation being performed. Use the <code>resize_output!</code> function  (do <strong>not</strong> use <code>Base.resize!</code> on your output array directly).</p></div></div><p>If the <code>output</code> array has to be resized, that has to be done with the  <code>resize_output!</code> function, which will keep the consistency of the auxiliary multi-threading buffers. This is, for instance, the case  in the example of computation of forces, as the <code>forces</code> array must be of the same length as the array of positions:</p><pre><code class="language-julia-repl hljs">julia&gt; resize_output!(system, length(system.xpositions));

julia&gt; map_pairwise!((x,y,i,j,d2,forces) -&gt; update_forces!(x,y,i,j,d2,forces), system)
1001-element Vector{SVector{3, Float64}}:
 [756.2076075886971, -335.1637545330828, 541.8627090466914]
 [-173.02442398784672, -178.782819965489, 4.570607952876692]
 ⋮
 [-722.5400961501635, 182.65287417718935, 380.0394926753039]
 [20.27985502389337, -193.77607810950286, -155.28968519541544]</code></pre><p>In this case, if the <code>output</code> is not resized, a <code>BoundsError:</code> is be obtained, because updates of forces at unavailable positions will be attempted. </p><h3 id="Updating-the-unit-cell"><a class="docs-heading-anchor" href="#Updating-the-unit-cell">Updating the unit cell</a><a id="Updating-the-unit-cell-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-unit-cell" title="Permalink"></a></h3><p>The unit cell can be updated to new dimensions at any moment, with the <code>update_unitcell!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; update_unitcell!(system, SVector(1.2, 1.2, 1.2))
PeriodicSystem1 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.2, 0.0, 0.0; 0.0, 1.2, 0.0; 0.0, 0.0, 1.2 ]
      cutoff = 0.1
      number of computing cells on each dimension = [13, 13, 13]
      computing cell sizes = [0.11, 0.11, 0.11] (lcell: 1)
      Total number of cells = 2197
    CellListMap.CellList{3, Float64}
      1000 real particles.
      623 cells with real particles.
      1719 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 12
    Type of output variable (forces): Vector{SVector{3, Float64}}</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li><p>The unit cell can be set initially using a vector or a unit cell matrix. If a vector is provided the system is considered Orthorhombic, if a matrix is provided, a Triclinic system is built.  Unit cells updates must preserve the system type. </p></li><li><p>It is recommended (but not mandatory) to use static arrays (or Tuples) to update the unitcell,  as in this case the update will be non-allocating. </p></li></ul></div></div><h3 id="Updating-the-cutoff"><a class="docs-heading-anchor" href="#Updating-the-cutoff">Updating the cutoff</a><a id="Updating-the-cutoff-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-cutoff" title="Permalink"></a></h3><p>The cutoff can also be updated, using the <code>update_cutoff!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; update_cutoff!(system, 0.2)
PeriodicSystem1 of dimension 3, composed of:
    Box{CellListMap.OrthorhombicCell, 3}
      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]
      cutoff = 0.2
      number of computing cells on each dimension = [7, 7, 7]
      computing cell sizes = [0.2, 0.2, 0.2] (lcell: 1)
      Total number of cells = 343
    CellListMap.CellList{3, Float64}
      1000 real particles.
      125 cells with real particles.
      2792 particles in computing box, including images.
    Parallelization auxiliary data set for: 
      Number of batches for cell list construction: 8
      Number of batches for function mapping: 8
    Type of output variable (forces): Vector{SVector{3, Float64}}

julia&gt; map_pairwise!((x,y,i,j,d2,forces) -&gt; update_forces!(x,y,i,j,d2,forces), system)
1000-element Vector{SVector{3, Float64}}:
 [306.9612911344924, -618.7375562535321, -607.1449767066479]
 [224.0803003775478, -241.05319348787023, 67.53780411933884]
 ⋮
 [2114.4873184508524, -3186.265279868732, -6777.748445712408]
 [-25.306486853608945, 119.69319481834582, 104.1501577339471]</code></pre><h2 id="Computations-for-two-sets-of-particles"><a class="docs-heading-anchor" href="#Computations-for-two-sets-of-particles">Computations for two sets of particles</a><a id="Computations-for-two-sets-of-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Computations-for-two-sets-of-particles" title="Permalink"></a></h2><p>If the computation involves two sets of particle, a similar interface is available.  The only difference is that the coordinates of the two sets must be provided to the <code>PeriodicSystem</code> constructor as the <code>xpositions</code> and <code>ypositions</code> arrays.</p><p>We will illustrate this interface by computing the minimum distance between two sets of particles, which allows us to showcase further the definition of custom type interfaces:</p><p>First, we define a variable type that will carry the indexes and  the distance of the closest pair of particles:</p><pre><code class="language-julia-repl hljs">julia&gt; struct MinimumDistance
           i::Int
           j::Int
           d::Float64
       end</code></pre><p>The function that, given two particles, retains the minimum distance, is:</p><pre><code class="language-julia-repl hljs">julia&gt; function minimum_distance(i, j, d2, md)
           d = sqrt(d2)
           if d &lt; md.d
               md = MinimumDistance(i, j, d)
           end
           return md
       end
minimum_distance (generic function with 1 method)</code></pre><p>We overload copy, reset, and reduce functions, accordingly:</p><pre><code class="language-julia-repl hljs">julia&gt; import CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!

julia&gt; copy_output(md::MinimumDistance) = md
copy_output (generic function with 5 methods)

julia&gt; reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)
reset_output! (generic function with 5 methods)

julia&gt; reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d &lt; md2.d ? md1 : md2
reducer! (generic function with 2 methods)</code></pre><p>Note that since <code>MinimumDistance</code> is immutable, copying it is the same as returning the value.  Also, resetting the minimum distance consists of setting its <code>d</code> field to <code>+Inf</code>. And, finally, reducing the threaded distances consists of keeping the pair with the shortest distance. </p><p>Next, we build the system</p><pre><code class="language-julia-repl hljs">julia&gt; xpositions = rand(SVector{3,Float64},1000);

julia&gt; ypositions = rand(SVector{3,Float64},1000);

julia&gt; system = PeriodicSystem(
           xpositions = xpositions,
           ypositions = ypositions, 
           unitcell=[1.0,1.0,1.0], 
           cutoff = 0.1, 
           output = MinimumDistance(0,0,+Inf),
           output_name = :minimum_distance,
        )</code></pre><p>And finally we can obtain the minimum distance between the sets: </p><pre><code class="language-julia-repl hljs">julia&gt; map_pairwise((x,y,i,j,d2,md) -&gt; minimum_distance(i,j,d2,md), system)
MinimumDistance(276, 617, 0.006009804808785543)</code></pre><h2 id="Additional-execution-options"><a class="docs-heading-anchor" href="#Additional-execution-options">Additional execution options</a><a id="Additional-execution-options-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-execution-options" title="Permalink"></a></h2><ul><li><a href="#Turn-parallelization-on-and-off">Turn parallelization on and off</a></li><li><a href="#Displaying-a-progress-bar">Displaying a progress bar</a></li><li><a href="#Fine-control-of-the-paralellization">Fine control of the paralellization</a></li><li><a href="#Avoid-cell-list-updating">Avoid cell list updating</a></li><li><a href="#Control-CellList-cell-size">Control CellList cell size</a></li></ul><h3 id="Turn-parallelization-on-and-off"><a class="docs-heading-anchor" href="#Turn-parallelization-on-and-off">Turn parallelization on and off</a><a id="Turn-parallelization-on-and-off-1"></a><a class="docs-heading-anchor-permalink" href="#Turn-parallelization-on-and-off" title="Permalink"></a></h3><p>The use of parallel computations can be tunned on and of by the <code>system.parallel</code> boolean flag. For example, using 6 cores (12 threads) for the calculation of the minimum-distance example: </p><pre><code class="language-julia-repl hljs">julia&gt; f(system) = map_pairwise((x,y,i,j,d2,md) -&gt; minimum_distance(i,j,d2,md), system)
f (generic function with 1 method)

julia&gt; Threads.nthreads()
8

julia&gt; system.parallel = true
true

julia&gt; @btime f($system)
  268.265 μs (144 allocations: 16.91 KiB)
MinimumDistance(783, 497, 0.007213710914619913)

julia&gt; system.parallel = false
false

julia&gt; @btime f($system)
  720.304 μs (0 allocations: 0 bytes)
MinimumDistance(783, 497, 0.007213710914619913)</code></pre><h3 id="Displaying-a-progress-bar"><a class="docs-heading-anchor" href="#Displaying-a-progress-bar">Displaying a progress bar</a><a id="Displaying-a-progress-bar-1"></a><a class="docs-heading-anchor-permalink" href="#Displaying-a-progress-bar" title="Permalink"></a></h3><p>Displaying a progress bar: for very long runs, the user might want to see the progress of the computation. Use the <code>show_progress</code> keyword parameter of the <code>map_pairwise!</code>  function for that.</p><p>For example, we execute the computation above, but with much more particles:</p><pre><code class="language-julia-repl hljs">julia&gt; xpositions = rand(SVector{3,Float64},10^6);

julia&gt; ypositions = rand(SVector{3,Float64},10^6);

julia&gt; system = PeriodicSystem(
                  xpositions = xpositions,
                  ypositions = ypositions, 
                  unitcell=[1.0,1.0,1.0], 
                  cutoff = 0.1, 
                  output = MinimumDistance(0,0,+Inf),
                  output_name = :minimum_distance,
               );

julia&gt; map_pairwise(
           (x,y,i,j,d2,md) -&gt; minimum_distance(i,j,d2,md), system; 
           show_progress = true
       )
Progress:  24%|██████████▏                               |  ETA: 0:00:29</code></pre><p>By activating the <code>show_progress</code> flag, a nice progress bar is shown. </p><h3 id="Fine-control-of-the-paralellization"><a class="docs-heading-anchor" href="#Fine-control-of-the-paralellization">Fine control of the paralellization</a><a id="Fine-control-of-the-paralellization-1"></a><a class="docs-heading-anchor-permalink" href="#Fine-control-of-the-paralellization" title="Permalink"></a></h3><p>The number of batches launched in parallel runs can be tunned by the  <code>nbatches</code> keyword parameter of the <code>PeriodicSystem</code> constructor.  By default, the number of batches is defined as heuristic function  dependent on the number of particles, and possibly returns optimal values in most cases. For a detailed discussion about this parameter,  see <a href="../LowLevel/#Number-of-batches">Number of batches</a>.</p><p>For example, to set the number of batches for cell list calculation to 4 and the number of batches for mapping to 8, we can do:</p><pre><code class="language-julia-repl hljs">julia&gt; system = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0,
           output_name = :energy,
           nbatches=(4,8), # use this keyword 
       );</code></pre><p>Most times it is expected that the default parameters are optimal. But particularly for  inhomogeneous systems increasing the number of batches of the mapping phase (second parameter of the tuple) may improve the performance by reducing the idle time of  threads.</p><h3 id="Avoid-cell-list-updating"><a class="docs-heading-anchor" href="#Avoid-cell-list-updating">Avoid cell list updating</a><a id="Avoid-cell-list-updating-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-cell-list-updating" title="Permalink"></a></h3><p>To compute different properties without recomputing cell lists, use <code>update_lists=false</code> in  the call of <code>map_pairwise</code> methods, for example,</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems, StaticArrays
system = PeriodicSystem(xpositions=rand(SVector{3,Float64},1000), output=0.0, cutoff=0.1, unitcell=[1,1,1])
# First call, will compute the cell lists
map_pairwise((x,y,i,j,d2,u) -&gt; u += d2, system)
# Second run: do not update the cell lists but compute a different property
map_pairwise((x,y,i,j,d2,u) -&gt; u += sqrt(d2), system; update_lists = false)</code></pre><p>in which case we are computing the sum of distances from the same cell lists used to compute the energy in the previous example (requires version 0.8.9). Specifically, this will skip the updating of the cell lists, thus be careful to not use this option if the cutoff, unitcell, or any other property of the system changed. </p><p>For systems with two sets of particles, the  coordinates of the <code>xpositions</code> set can be updated, preserving the cell lists computed for the <code>ypositions</code>, but this requires setting <code>autoswap=false</code> in the construction of the <code>PeriodicSystem</code>: </p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems, StaticArrays
system = PeriodicSystem(
    xpositions=rand(SVector{3,Float64},1000), 
    ypositions=rand(SVector{3,Float64},2000),
    output=0.0, cutoff=0.1, unitcell=[1,1,1],
    autoswap=false # Cell lists are constructred for ypositions
)
map_pairwise((x,y,i,j,d2,u) -&gt; u += d2, system)
# Second run: preserve the cell lists but compute a different property
map_pairwise((x,y,i,j,d2,u) -&gt; u += sqrt(d2), system; update_lists = false)</code></pre><h3 id="Control-CellList-cell-size"><a class="docs-heading-anchor" href="#Control-CellList-cell-size">Control CellList cell size</a><a id="Control-CellList-cell-size-1"></a><a class="docs-heading-anchor-permalink" href="#Control-CellList-cell-size" title="Permalink"></a></h3><p>The cell sizes of the construction of the cell lists can be controled with the keyword <code>lcell</code> of the <code>PeriodicSystem</code> constructor. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; system = PeriodicSystem(
           xpositions = rand(SVector{3,Float64},1000), 
           unitcell=[1,1,1], 
           cutoff = 0.1, 
           output = 0.0,
           output_name = :energy,
           lcell=2,
       );</code></pre><p>Most times using <code>lcell=1</code> (default) or <code>lcell=2</code> will provide the optimal performance. For very dense systems, or systems for which the number of particles within the cutoff is very large, larger values of <code>lcell</code> may improve the performance. To be tested by the user.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The number of cells in which the particles will be classified is, for each dimension <code>lcell*length/cutoff</code>.  Thus if the <code>length</code> of the box is too large relative to the <code>cutoff</code>, many cells will be created, and this imposes a perhaps large memory requirement. Usually, it is a good practice to limit the number of cells to be not greater than the number of particles, and for that the cutoff may have to be increased, if there is a memory bottleneck. A reasonable choice is to use <code>cutoff = max(real_cutoff, length/n^(1/D))</code> where <code>n</code> is the  number of particles and <code>D</code> is the dimension (2 or 3). With that the number of cells will be close to <code>n</code> in the worst case.  </p></div></div><h2 id="Complete-example-codes"><a class="docs-heading-anchor" href="#Complete-example-codes">Complete example codes</a><a id="Complete-example-codes-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-example-codes" title="Permalink"></a></h2><ul><li><a href="#Simple-energy-computation">Simple energy computation</a></li><li><a href="#Force-computation">Force computation</a></li><li><a href="#Energy-and-forces">Energy and forces</a></li><li><a href="#Two-sets-of-particles">Two sets of particles</a></li><li><a href="#Particle-simulation">Particle simulation</a></li></ul><h3 id="Simple-energy-computation"><a class="docs-heading-anchor" href="#Simple-energy-computation">Simple energy computation</a><a id="Simple-energy-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-energy-computation" title="Permalink"></a></h3><p>In this example, a simple potential energy defined as the sum of the  inverse of the distance between the particles is computed.</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems
using StaticArrays
system = PeriodicSystem(
    xpositions = rand(SVector{3,Float64},1000), 
    unitcell=[1.0,1.0,1.0], 
    cutoff = 0.1, 
    output = 0.0,
    output_name = :energy
)
map_pairwise!((x,y,i,j,d2,energy) -&gt; energy += 1 / sqrt(d2), system)</code></pre><h3 id="Force-computation"><a class="docs-heading-anchor" href="#Force-computation">Force computation</a><a id="Force-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Force-computation" title="Permalink"></a></h3><p>Here we compute the force vector associated to the potential energy function of the previous example.</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems
using StaticArrays
positions = rand(SVector{3,Float64},1000) 
system = PeriodicSystem(
    xpositions = positions, 
    unitcell=[1.0,1.0,1.0], 
    cutoff = 0.1, 
    output = similar(positions),
    output_name = :forces
)
function update_forces!(x,y,i,j,d2,forces)
    d = sqrt(d2)
    df = (1/d2)*(1/d)*(y - x)
    forces[i] += df
    forces[j] -= df
    return forces
end
map_pairwise!((x,y,i,j,d2,forces) -&gt; update_forces!(x,y,i,j,d2,forces), system)</code></pre><h3 id="Energy-and-forces"><a class="docs-heading-anchor" href="#Energy-and-forces">Energy and forces</a><a id="Energy-and-forces-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-and-forces" title="Permalink"></a></h3><p>In this example, the potential energy and the forces are computed in a single run, and a custom data structure is defined to store both values.</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems
using StaticArrays
# Define custom type
mutable struct EnergyAndForces
    energy::Float64
    forces::Vector{SVector{3,Float64}}
end
# Custom copy, reset and reducer functions
import CellListMap.PeriodicSystems: copy_output, reset_output!, reducer
copy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))
function reset_output!(output::EnergyAndForces)
    output.energy = 0.0
    for i in eachindex(output.forces)
        output.forces[i] = SVector(0.0, 0.0, 0.0)
    end
    return output
end
function reducer(x::EnergyAndForces, y::EnergyAndForces)
    e_tot = x.energy + y.energy
    x.forces .+= y.forces
    return EnergyAndForces(e_tot, x.forces)
end
# Function that updates energy and forces for each pair
function energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)
    d = sqrt(d2)
    output.energy += 1/d
    df = (1/d2)*(1/d)*(y - x)
    output.forces[i] += df
    output.forces[j] -= df
    return output
end
# Initialize system
positions = rand(SVector{3,Float64},1000);
system = PeriodicSystem(
    xpositions = positions,
    unitcell=[1.0,1.0,1.0], 
    cutoff = 0.1, 
    output = EnergyAndForces(0.0, similar(positions)),
    output_name = :energy_and_forces
)
# Compute energy and forces
map_pairwise((x,y,i,j,d2,output) -&gt; energy_and_forces!(x,y,i,j,d2,output), system)</code></pre><h3 id="Two-sets-of-particles"><a class="docs-heading-anchor" href="#Two-sets-of-particles">Two sets of particles</a><a id="Two-sets-of-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Two-sets-of-particles" title="Permalink"></a></h3><p>In this example we illustrate the interface for the computation of properties of two sets of particles, by computing the minimum distance between the two sets.</p><pre><code class="language-julia hljs">using CellListMap.PeriodicSystems
using StaticArrays
# Custom structure to store the minimum distance pair
struct MinimumDistance
    i::Int
    j::Int
    d::Float64
end
# Function that updates the minimum distance found
function minimum_distance(i, j, d2, md)
    d = sqrt(d2)
    if d &lt; md.d
        md = MinimumDistance(i, j, d)
    end
    return md
end
# Define appropriate methods for copy, reset and reduce 
import CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!
copy_output(md::MinimumDistance) = md
reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)
reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d &lt; md2.d ? md1 : md2
# Build system 
xpositions = rand(SVector{3,Float64},1000);
ypositions = rand(SVector{3,Float64},1000);
system = PeriodicSystem(
       xpositions = xpositions,
       ypositions = ypositions, 
       unitcell=[1.0,1.0,1.0], 
       cutoff = 0.1, 
       output = MinimumDistance(0,0,+Inf),
       output_name = :minimum_distance,
)
# Compute the minimum distance
map_pairwise((x,y,i,j,d2,md) -&gt; minimum_distance(i,j,d2,md), system)</code></pre><h3 id="Particle-simulation"><a class="docs-heading-anchor" href="#Particle-simulation">Particle simulation</a><a id="Particle-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-simulation" title="Permalink"></a></h3><p>In this example, a complete particle simulation is illustrated, with a simple potential.  This example can illustrate how particle positions and forces can be updated. Run this simulation with:</p><pre><code class="language-julia-repl hljs">julia&gt; system = init_system(N=200); # number of particles

julia&gt; trajectory = simulate(system);

julia&gt; animate(trajectory)</code></pre><p>One important characteristic of this example is that the <code>system</code> is built outside the function that performs the simulation. This is done because the construction of the system is type-unstable (it is dimension, geometry and output-type dependent). Adding a function barrier avoids type-instabilities to propagate to the simulation causing possible performance problems. </p><pre><code class="language-julia hljs">using StaticArrays
using CellListMap.PeriodicSystems
import CellListMap.wrap_relative_to
# Function that updates the forces, for potential of the form:
# if d &lt; cutoff k*(d^2-cutoff^2)^2 else 0.0 with k = 10^6
function update_forces!(x, y, i, j, d2, forces, cutoff)
    r = y - x
    dudr = 10^6 * 4 * r * (d2 - cutoff^2)
    forces[i] += dudr
    forces[j] -= dudr
    return forces
end
# Function that initializes the system: it is preferable to initialize
# the system outside the function that performs the simulation, because
# the system (data)type is defined on initialization. Initializing it outside
# the simulation function avoids possible type-instabilities. 
function init_system(;N::Int=200)
    Vec2D = SVector{2,Float64}
    positions = rand(Vec2D, N)
    unitcell = [1.0, 1.0]
    cutoff = 0.1
    system = PeriodicSystem(
        positions=positions,
        cutoff=cutoff,
        unitcell=unitcell,
        output=similar(positions),
        output_name=:forces,
    )
    return system
end
function simulate(system=init_system(); nsteps::Int=100, isave=1)
    # initial velocities
    velocities = [ randn(eltype(system.positions)) for _ in 1:length(system.positions) ]
    dt = 1e-3
    trajectory = typeof(system.positions)[]
    for step in 1:nsteps
        # compute forces at this step
        map_pairwise!(
            (x,y,i,j,d2,forces) -&gt; update_forces!(x,y,i,j,d2,forces,system.cutoff),
            system
        )
        # Update positions and velocities
        for i in eachindex(system.positions, system.forces)
            f = system.forces[i]
            x = system.positions[i]
            v = velocities[i]
            x = x + v * dt + (f / 2) * dt^2
            v = v + f * dt
            # wrapping to origin for obtaining a pretty animation
            x = wrap_relative_to(x, SVector(0.0, 0.0), system.unitcell)
            # !!! IMPORTANT: Update arrays of positions and velocities
            system.positions[i] = x
            velocities[i] = v
        end
        # Save step for printing
        if step % isave == 0
            push!(trajectory, copy(system.positions))
        end
    end
    return trajectory
end

using Plots
function animate(trajectory)
    anim = @animate for step in trajectory
        scatter(
            Tuple.(step),
            label=nothing,
            lims=(-0.5, 0.5),
            aspect_ratio=1,
            framestyle=:box,
        )
    end
    gif(anim, &quot;simulation.gif&quot;, fps=10)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../neighborlists/">Neighbor lists »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 8 February 2024 14:32">Thursday 8 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
