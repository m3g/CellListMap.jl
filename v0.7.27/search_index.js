var documenterSearchIndex = {"docs":
[{"location":"PeriodicSystems/#PeriodicSystems-interface","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The PeriodicSystems interface facilitates the use of CellListMap for the majority of cases. To use it, load the PeriodicSystems module directly, with:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThis interface requires CellListMap.jl version 0.7.22 or greater.\nThe complete codes of the examples are at the end of this page, with examples of:\nSimple energy computation\nForce computation\nEnergy and forces\nTwo sets of particles\nParticle simulation","category":"page"},{"location":"PeriodicSystems/#The-mapped-function","page":"PeriodicSystems interface","title":"The mapped function","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The function to be mapped for every pair of particles within the cutoff follows the same interface as the standard interface. It must be of the form","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function f(x, y, i, j, d2, output)\n    # update output variable\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"where x and y are the positions of the particles, already wrapped relative to each other according to the periodic boundary conditions (a minimum-image set of positions), i and j are the indexes of the particles in the arrays of coordinates, d2 is the squared distance between the particles, and output is the variable to be computed. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, computing the energy, as the sum of the inverse of the distance between particles, can be done with a function like:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy(d2,u)\n    u += 1 / sqrt(d2)\n    return u\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"and the additional parameters required by the interface can be eliminated by the use of an anonymous function, directly on the call to the `map_pairwise!  function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"u = map_pairwise((x,y,i,j,d2,u) -> energy(d2,u), system)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"(what system is will be explained in the examples below).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Alternatively, the function might require additional parameters, such as the masses of the particles. In this case, we can use a closure to provide such data:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy(i,j,d2,u,masses)\n    u += masses[i]*masses[j] / sqrt(d2)\n    return u\nend\nconst masses = # ... some masses\nu = map_pairwise((x,y,i,j,d2,u) -> energy(d2,u,masses), system)","category":"page"},{"location":"PeriodicSystems/#Potential-energy-example","page":"PeriodicSystems interface","title":"Potential energy example","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThe output of the CellListMap computation may be of any kind. Most commonly, it is an energy, a set of forces, or other data type that can be represented either as a number, an array of numbers, or an array of vectors (SVectors in particular), such as arrays of forces.  Additionally, the properties are frequently additive (the energy is the sum of the energy of the particles, or the forces are added by summation). For these types of output data the usage of CellListMap.PeriodicSystems is the simplest, and does not require the implementation of any data-type dependent function. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, let us build a system of random particles in a cubic box, and compute an \"energy\", which in this case is simply the sum of 1/d over all pair of particles, within a cutoff.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The PeriodicSystem constructor receives the properties of the system and sets up automatically the most commonly used data structures necessary. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> using CellListMap.PeriodicSystems, StaticArrays\n\njulia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1.0,1.0,1.0], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now, directly, let us compute a putative energy of the particles, assuming a simple formula which depends on the inverse of the distance between pairs:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise!((x,y,i,j,d2,energy) -> energy += 1 / sqrt(d2), system)\n30679.386366872823","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The system.energy field accesses the resulting value of the computation:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.energy\n30679.386366872823","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"because the output_name field was provided. If it is not provided, you can access the output value from the system.output field.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nSystems can be 2 or 3-dimensional. \nThe unitcell parameter may be either a vector, as in the example, or a unit cell matrix, for general boundary conditions.\nUnitful quantities can be provided, given appropriate types for all input parameters. ","category":"page"},{"location":"PeriodicSystems/#Computing-forces","page":"PeriodicSystems interface","title":"Computing forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Following the example above, let us compute the forces between the particles. We have to define the function that computes the force between a pair of particles and updates the array of forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function update_forces!(x,y,i,j,d2,forces)\n    d = sqrt(d2)\n    df = (1/d2)*(1/d)*(y - x)\n    forces[i] += df\n    forces[j] -= df\n    return forces\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Importantly, the function must return the forces array to follow the API. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now, let us setup the system with the new type of output variable, which will be now an array of forces with the same type as the positions:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> positions = rand(SVector{3,Float64},1000);\n\njulia> system = PeriodicSystem(\n           xpositions = positions,\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = similar(positions),\n           output_name = :forces\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Let us note that the forces where reset upon the construction of the system:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.forces\n1000-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n ‚ãÆ\n [0.0, 0.0, 0.0]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"A call to map_pairwise! with the appropriate function definition will update the forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1000-element Vector{SVector{3, Float64}}:\n [-151.19529230407284, 159.33819000196905, -261.3055111242796]\n [-173.02442398784672, -178.782819965489, 4.570607952876692]\n ‚ãÆ\n [-722.5400961501635, 182.65287417718935, 380.0394926753039]","category":"page"},{"location":"PeriodicSystems/#Computing-both-energy-and-forces","page":"PeriodicSystems interface","title":"Computing both energy and forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nIn this example we define a general type of output variable, for which custom copy, reset, and reduction functions must be defined. It can be followed for the computation of other general properties from the particle positions.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems, StaticArrays","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The computation of energies and forces in a single call is an interesting example for the definition of a custom output type and the required interface functions.  Let us first define an output variable containing both quantities:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"mutable struct EnergyAndForces\n    energy::Float64\n    forces::Vector{SVector{3,Float64}}\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now we need to define what it means to copy, reset, and reduce this new type of output. We overload the default corresponding functions, for our new output type:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The copy method creates a new instance of the EnergyAndForces type, with copied data:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: copy_output\ncopy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The reset method will zero both the energy and all forces: import CellListMap.PeriodicSystems: copyoutput, resetoutput!, reducer","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: reset_output!\nfunction reset_output!(output::EnergyAndForces)\n    output.energy = 0.0\n    for i in eachindex(output.forces)\n        output.forces[i] = SVector(0.0, 0.0, 0.0)\n    end\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The reduction function defines what it means to combine two output variables obtained on independent threads. In this case, we sum the energies and forces. Different reduction functions might be necessary for other custom types (for example if computing minimum distances).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"import CellListMap.PeriodicSystems: reducer\nfunction reducer(x::EnergyAndForces, y::EnergyAndForces)\n    e_tot = x.energy + y.energy\n    x.forces .+= y.forces\n    return EnergyAndForces(e_tot, x.forces)\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Note that in the above example, we reuse the x.forces array in the return instance of EnergyAndForces. You must always reduce from right to left, and reuse the possible buffers of the first argument of the reducer (in this case, x).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"warning: Warning\nAll these functions must return the modified output variable, to adhere to the interface.\nThe proper definition of a reduction function is crucial for correctness. Please verify your results if using the default reducer function, which sums the elements.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Now we can proceed as before, defining a function that updates the output variable appropriately:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"function energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)\n    d = sqrt(d2)\n    output.energy += 1/d\n    df = (1/d2)*(1/d)*(y - x)\n    output.forces[i] += df\n    output.forces[j] -= df\n    return output\nend","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"To finally define the system and compute the properties:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"positions = rand(SVector{3,Float64},1000);\n\nsystem = PeriodicSystem(\n    xpositions = positions,\n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = EnergyAndForces(0.0, similar(positions)),\n    output_name = :energy_and_forces\n);\n\nmap_pairwise((x,y,i,j,d2,output) -> energy_and_forces!(x,y,i,j,d2,output), system);","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The output can be seen with the aliases of the system.output variable:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system.energy_and_forces.energy\n31696.94766439311\n\njulia> system.energy_and_forces.forces\n1000-element Vector{SVector{3, Float64}}:\n [-338.1909601911842, 7.7663690656924445, 202.25889647151405]\n [33.67299655756128, 282.7581453168999, -79.09639223837306]\n ‚ãÆ\n [38.83014327604529, -204.45236278342745, 249.307871211616]","category":"page"},{"location":"PeriodicSystems/#Updating-coordinates,-unit-cell,-and-cutoff","page":"PeriodicSystems interface","title":"Updating coordinates, unit cell, and cutoff","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the map_pairwise! function will compute energy and/or forces in a iterative procedure (a simulation, for instance), we need to update the coordinates, and perhaps the unit cell and the cutoff.","category":"page"},{"location":"PeriodicSystems/#Updating-coordinates","page":"PeriodicSystems interface","title":"Updating coordinates","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The coordinates can be updated (mutated, or the array of coordinates can change in size by pushing or deleting particles), simply by directly acessing the xpositions field of the system. Let us exemplify the interface with the computation of forces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> using CellListMap.PeriodicSystems, StaticArrays\n\njulia> positions = rand(SVector{3,Float64}, 1000);\n\njulia> system = PeriodicSystem(\n           xpositions = positions,\n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = similar(positions),\n           output_name = :forces\n       );\n\njulia> system.xpositions[1]\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.6391290709055079\n 0.43679325975360894\n 0.8231829019768698\n\njulia> system.xpositions[1] = zeros(SVector{3,Float64})\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.0\n 0.0\n\njulia> push!(system.xpositions, SVector(0.5, 0.5, 0.5))\n1001-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, 0.0]\n [0.5491373098208292, 0.23899915605319244, 0.49058287555218516]\n ‚ãÆ\n [0.4700394061063937, 0.5440026379397457, 0.7411235688716618]\n [0.5, 0.5, 0.5]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"warning: Warning\nThe output variable may have to be resized accordingly, depending on the calculation being performed. Use the resize_output! function  (do not use Base.resize! on your output array directly).","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the output array has to be resized, that has to be done with the  resize_output! function, which will keep the consistency of the auxiliary multi-threading buffers. This is, for instance, the case  in the example of computation of forces, as the forces array must be of the same length as the array of positions:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> resize_output!(system, length(system.xpositions));\n\njulia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1001-element Vector{SVector{3, Float64}}:\n [756.2076075886971, -335.1637545330828, 541.8627090466914]\n [-173.02442398784672, -178.782819965489, 4.570607952876692]\n ‚ãÆ\n [-722.5400961501635, 182.65287417718935, 380.0394926753039]\n [20.27985502389337, -193.77607810950286, -155.28968519541544]","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this case, if the output is not resized, a BoundsError: is be obtained, because updates of forces at unavailable positions will be attempted. ","category":"page"},{"location":"PeriodicSystems/#Updating-the-unit-cell","page":"PeriodicSystems interface","title":"Updating the unit cell","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The unit cell can be updated to new dimensions at any moment, with the update_unitcell! function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> update_unitcell!(system, [1.2, 1.2, 1.2])\nPeriodicSystem1 of dimension 3, composed of:\n    Box{CellListMap.OrthorhombicCell, 3}\n      unit cell matrix = [ 1.2, 0.0, 0.0; 0.0, 1.2, 0.0; 0.0, 0.0, 1.2 ]\n      cutoff = 0.1\n      number of computing cells on each dimension = [13, 13, 13]\n      computing cell sizes = [0.11, 0.11, 0.11] (lcell: 1)\n      Total number of cells = 2197\n    CellListMap.CellList{3, Float64}\n      1000 real particles.\n      623 cells with real particles.\n      1719 particles in computing box, including images.\n    Parallelization auxiliary data set for: \n      Number of batches for cell list construction: 8\n      Number of batches for function mapping: 12\n    Type of output variable (forces): Vector{SVector{3, Float64}}","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"note: Note\nThe unit cell can be set initially using a vector or a unit cell matrix. If a vector is provided the system is considered Orthorhombic, if a matrix is provided, a Triclinic system is built.  Unit cells updates must preserve the system type. ","category":"page"},{"location":"PeriodicSystems/#Updating-the-cutoff","page":"PeriodicSystems interface","title":"Updating the cutoff","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The cutoff can also be updated, using the update_cutoff! function:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> update_cutoff!(system, 0.2)\nPeriodicSystem1 of dimension 3, composed of:\n    Box{CellListMap.OrthorhombicCell, 3}\n      unit cell matrix = [ 1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0 ]\n      cutoff = 0.2\n      number of computing cells on each dimension = [7, 7, 7]\n      computing cell sizes = [0.2, 0.2, 0.2] (lcell: 1)\n      Total number of cells = 343\n    CellListMap.CellList{3, Float64}\n      1000 real particles.\n      125 cells with real particles.\n      2792 particles in computing box, including images.\n    Parallelization auxiliary data set for: \n      Number of batches for cell list construction: 8\n      Number of batches for function mapping: 8\n    Type of output variable (forces): Vector{SVector{3, Float64}}\n\njulia> map_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)\n1000-element Vector{SVector{3, Float64}}:\n [306.9612911344924, -618.7375562535321, -607.1449767066479]\n [224.0803003775478, -241.05319348787023, 67.53780411933884]\n ‚ãÆ\n [2114.4873184508524, -3186.265279868732, -6777.748445712408]\n [-25.306486853608945, 119.69319481834582, 104.1501577339471]","category":"page"},{"location":"PeriodicSystems/#Computations-for-two-sets-of-particles","page":"PeriodicSystems interface","title":"Computations for two sets of particles","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"If the computation involves two sets of particle, a similar interface is available.  The only difference is that the coordinates of the two sets must be provided to the PeriodicSystem constructor as the xpositions and ypositions arrays.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"We will illustrate this interface by computing the minimum distance between two sets of particles, which allows us to showcase further the definition of custom type interfaces:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"First, we define a variable type that will carry the indexes and  the distance of the closest pair of particles:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> struct MinimumDistance\n           i::Int\n           j::Int\n           d::Float64\n       end","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The function that, given two particles, retains the minimum distance, is:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> function minimum_distance(i, j, d2, md)\n           d = sqrt(d2)\n           if d < md.d\n               md = MinimumDistance(i, j, d)\n           end\n           return md\n       end\nminimum_distance (generic function with 1 method)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"We overload copy, reset, and reduce functions, accordingly:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> import CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!\n\njulia> copy_output(md::MinimumDistance) = md\ncopy_output (generic function with 5 methods)\n\njulia> reset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)\nreset_output! (generic function with 5 methods)\n\njulia> reducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d < md2.d ? md1 : md2\nreducer! (generic function with 2 methods)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Note that since MinimumDistance is immutable, copying it is the same as returning the value.  Also, resetting the minimum distance consists of setting its d field to +Inf. And, finally, reducing the threaded distances consists of keeping the pair with the shortest distance. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Next, we build the system","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> xpositions = rand(SVector{3,Float64},1000);\n\njulia> ypositions = rand(SVector{3,Float64},1000);\n\njulia> system = PeriodicSystem(\n           xpositions = xpositions,\n           ypositions = ypositions, \n           unitcell=[1.0,1.0,1.0], \n           cutoff = 0.1, \n           output = MinimumDistance(0,0,+Inf),\n           output_name = :minimum_distance,\n        )","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"And finally we can obtain the minimum distance between the sets: ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> map_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)\nMinimumDistance(276, 617, 0.006009804808785543)","category":"page"},{"location":"PeriodicSystems/#Additional-execution-options","page":"PeriodicSystems interface","title":"Additional execution options","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Turn parallelization on and off\nDisplaying a progress bar\nFine control of the paralellization\nControl CellList cell size","category":"page"},{"location":"PeriodicSystems/#Turn-parallelization-on-and-off","page":"PeriodicSystems interface","title":"Turn parallelization on and off","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The use of parallel computations can be tunned on and of by the system.parallel boolean flag. For example, using 6 cores (12 threads) for the calculation of the minimum-distance example: ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> f(system) = map_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)\nf (generic function with 1 method)\n\njulia> Threads.nthreads()\n8\n\njulia> system.parallel = true\ntrue\n\njulia> @btime f($system)\n  268.265 Œºs (144 allocations: 16.91 KiB)\nMinimumDistance(783, 497, 0.007213710914619913)\n\njulia> system.parallel = false\nfalse\n\njulia> @btime f($system)\n  720.304 Œºs (0 allocations: 0 bytes)\nMinimumDistance(783, 497, 0.007213710914619913)","category":"page"},{"location":"PeriodicSystems/#Displaying-a-progress-bar","page":"PeriodicSystems interface","title":"Displaying a progress bar","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Displaying a progress bar: for very long runs, the user might want to see the progress of the computation. Use the show_progress keyword parameter of the map_pairwise!  function for that.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, we execute the computation above, but with much more particles:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> xpositions = rand(SVector{3,Float64},10^6);\n\njulia> ypositions = rand(SVector{3,Float64},10^6);\n\njulia> system = PeriodicSystem(\n                  xpositions = xpositions,\n                  ypositions = ypositions, \n                  unitcell=[1.0,1.0,1.0], \n                  cutoff = 0.1, \n                  output = MinimumDistance(0,0,+Inf),\n                  output_name = :minimum_distance,\n               );\n\njulia> map_pairwise(\n           (x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system; \n           show_progress = true\n       )\nProgress:  24%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñè                               |  ETA: 0:00:29","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"By activating the show_progress flag, a nice progress bar is shown. ","category":"page"},{"location":"PeriodicSystems/#Fine-control-of-the-paralellization","page":"PeriodicSystems interface","title":"Fine control of the paralellization","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The number of batches launched in parallel runs can be tunned by the  nbatches keyword parameter of the PeriodicSystem constructor.  By default, the number of batches is defined as heuristic function  dependent on the number of particles, and possibly returns optimal values in most cases. For a detailed dicussion about this parameter,  see Number of batches.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"For example, to set the number of batches for cell list calculation to 4 and the number of batches for mapping to 8, we can do:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy,\n           nbatches=(4,8), # use this keyword \n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Most times it is expected that the default parameters are optimal. But particularly for  inhomogeneous systems increasing the number of batches of the mapping phase (second parameter of the tuple) may improve the performance by reducing the idle time of  threads.","category":"page"},{"location":"PeriodicSystems/#Control-CellList-cell-size","page":"PeriodicSystems interface","title":"Control CellList cell size","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"The cell sizes of the construction of the cell lists can be controled with the keyword lcell of the PeriodicSystem constructor. For example:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = PeriodicSystem(\n           xpositions = rand(SVector{3,Float64},1000), \n           unitcell=[1,1,1], \n           cutoff = 0.1, \n           output = 0.0,\n           output_name = :energy,\n           lcell=2,\n       );","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Most times using lcell=1 (default) or lcell=2 will provide the optimal performance. For very dense systems, or systems for which the number of particles within the cutoff is very large, larger values of lcell may improve the performance. To be tested by the user.","category":"page"},{"location":"PeriodicSystems/#Complete-example-codes","page":"PeriodicSystems interface","title":"Complete example codes","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Simple energy computation\nForce computation\nEnergy and forces\nTwo sets of particles\nParticle simulation","category":"page"},{"location":"PeriodicSystems/#Simple-energy-computation","page":"PeriodicSystems interface","title":"Simple energy computation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, a simple potential energy defined as the sum of the  inverse of the distance between the particles is computed.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\nsystem = PeriodicSystem(\n    xpositions = rand(SVector{3,Float64},1000), \n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = 0.0,\n    output_name = :energy\n)\nmap_pairwise!((x,y,i,j,d2,energy) -> energy += 1 / sqrt(d2), system)","category":"page"},{"location":"PeriodicSystems/#Force-computation","page":"PeriodicSystems interface","title":"Force computation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"Here we compute the force vector associated to the potential energy function of the previous example.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\npositions = rand(SVector{3,Float64},1000) \nsystem = PeriodicSystem(\n    xpositions = positions, \n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = similar(positions),\n    output_name = :forces\n)\nfunction update_forces!(x,y,i,j,d2,forces)\n    d = sqrt(d2)\n    df = (1/d2)*(1/d)*(y - x)\n    forces[i] += df\n    forces[j] -= df\n    return forces\nend\nmap_pairwise!((x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces), system)","category":"page"},{"location":"PeriodicSystems/#Energy-and-forces","page":"PeriodicSystems interface","title":"Energy and forces","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, the potential energy and the forces are computed in a single run, and a custom data structure is defined to store both values.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\n# Define custom type\nmutable struct EnergyAndForces\n    energy::Float64\n    forces::Vector{SVector{3,Float64}}\nend\n# Custom copy, reset and reducer functions\nimport CellListMap.PeriodicSystems: copy_output, reset_output!, reducer\ncopy_output(x::EnergyAndForces) = EnergyAndForces(copy(x.energy), copy(x.forces))\nfunction reset_output!(output::EnergyAndForces)\n    output.energy = 0.0\n    for i in eachindex(output.forces)\n        output.forces[i] = SVector(0.0, 0.0, 0.0)\n    end\n    return output\nend\nfunction reducer(x::EnergyAndForces, y::EnergyAndForces)\n    e_tot = x.energy + y.energy\n    x.forces .+= y.forces\n    return EnergyAndForces(e_tot, x.forces)\nend\n# Function that updates energy and forces for each pair\nfunction energy_and_forces!(x,y,i,j,d2,output::EnergyAndForces)\n    d = sqrt(d2)\n    output.energy += 1/d\n    df = (1/d2)*(1/d)*(y - x)\n    output.forces[i] += df\n    output.forces[j] -= df\n    return output\nend\n# Initialize system\npositions = rand(SVector{3,Float64},1000);\nsystem = PeriodicSystem(\n    xpositions = positions,\n    unitcell=[1.0,1.0,1.0], \n    cutoff = 0.1, \n    output = EnergyAndForces(0.0, similar(positions)),\n    output_name = :energy_and_forces\n)\n# Compute energy and forces\nmap_pairwise((x,y,i,j,d2,output) -> energy_and_forces!(x,y,i,j,d2,output), system)","category":"page"},{"location":"PeriodicSystems/#Two-sets-of-particles","page":"PeriodicSystems interface","title":"Two sets of particles","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example we illustrate the interface for the computation of properties of two sets of particles, by computing the minimum distance between the two sets.","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using CellListMap.PeriodicSystems\nusing StaticArrays\n# Custom structure to store the minimum distance pair\nstruct MinimumDistance\n    i::Int\n    j::Int\n    d::Float64\nend\n# Function that updates the minimum distance found\nfunction minimum_distance(i, j, d2, md)\n    d = sqrt(d2)\n    if d < md.d\n        md = MinimumDistance(i, j, d)\n    end\n    return md\nend\n# Define appropriate methods for copy, reset and reduce \nimport CellListMap.PeriodicSystems: copy_output, reset_output!, reducer!\ncopy_output(md::MinimumDistance) = md\nreset_output!(md::MinimumDistance) = MinimumDistance(0, 0, +Inf)\nreducer!(md1::MinimumDistance, md2::MinimumDistance) = md1.d < md2.d ? md1 : md2\n# Build system \nxpositions = rand(SVector{3,Float64},1000);\nypositions = rand(SVector{3,Float64},1000);\nsystem = PeriodicSystem(\n       xpositions = xpositions,\n       ypositions = ypositions, \n       unitcell=[1.0,1.0,1.0], \n       cutoff = 0.1, \n       output = MinimumDistance(0,0,+Inf),\n       output_name = :minimum_distance,\n)\n# Compute the minimum distance\nmap_pairwise((x,y,i,j,d2,md) -> minimum_distance(i,j,d2,md), system)","category":"page"},{"location":"PeriodicSystems/#Particle-simulation","page":"PeriodicSystems interface","title":"Particle simulation","text":"","category":"section"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"In this example, a complete particle simulation is illustrated, with a simple potential.  This example can illustrate how particle positions and forces can be updated. Run this simulation with:","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"julia> system = init_system(N=200); # number of particles\n\njulia> trajectory = simulate(system);\n\njulia> animate(trajectory)","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"One important characteristic of this example is that the system is built outside the function that performs the simulation. This is done because the construction of the system is type-unstable (it is dimension, geometry and output-type dependent). Adding a function barrier avoids type-instabilities to propagate to the simulation causing possible performance problems. ","category":"page"},{"location":"PeriodicSystems/","page":"PeriodicSystems interface","title":"PeriodicSystems interface","text":"using StaticArrays\nusing CellListMap.PeriodicSystems\nimport CellListMap.wrap_relative_to\n# Function that updates the forces, for potential of the form:\n# if d < cutoff k*(d^2-cutoff^2)^2 else 0.0 with k = 10^6\nfunction update_forces!(x, y, i, j, d2, forces, cutoff)\n    r = y - x\n    dudr = 10^6 * 4 * r * (d2 - cutoff^2)\n    forces[i] += dudr\n    forces[j] -= dudr\n    return forces\nend\n# Function that initializes the system: it is preferrable to initialize\n# the system outside the function that performs the simulation, because\n# the system (data)type is defined on initialization. Initializing it outside\n# the simulation function avoids possible type-instabilities. \nfunction init_system(;N::Int=200)\n    Vec2D = SVector{2,Float64}\n    positions = rand(Vec2D, N)\n    unitcell = [1.0, 1.0]\n    cutoff = 0.1\n    system = PeriodicSystem(\n        positions=positions,\n        cutoff=cutoff,\n        unitcell=unitcell,\n        output=similar(positions),\n        output_name=:forces,\n    )\n    return system\nend\nfunction simulate(system=init_system(); nsteps::Int=100, isave=1)\n    # initial velocities\n    velocities = [ randn(eltype(system.positions)) for _ in 1:length(system.positions) ]\n    dt = 1e-3\n    trajectory = typeof(system.positions)[]\n    for step in 1:nsteps\n        # compute forces at this step\n        map_pairwise!(\n            (x,y,i,j,d2,forces) -> update_forces!(x,y,i,j,d2,forces,system.cutoff),\n            system\n        )\n        # Update positions and velocities\n        for i in eachindex(system.positions, system.forces)\n            f = system.forces[i]\n            x = system.positions[i]\n            v = velocities[i]\n            x = x + v * dt + (f / 2) * dt^2\n            v = v + f * dt\n            # wrapping to origin for obtaining a pretty animation\n            x = wrap_relative_to(x, SVector(0.0, 0.0), system.unitcell)\n            # !!! IMPORTANT: Update arrays of positions and velocities\n            system.positions[i] = x\n            velocities[i] = v\n        end\n        # Save step for printing\n        if step % isave == 0\n            push!(trajectory, copy(system.positions))\n        end\n    end\n    return trajectory\nend\n\nusing Plots\nfunction animate(trajectory)\n    anim = @animate for step in trajectory\n        scatter(\n            Tuple.(step),\n            label=nothing,\n            lims=(-0.5, 0.5),\n            aspect_ratio=1,\n            framestyle=:box,\n        )\n    end\n    gif(anim, \"simulation.gif\", fps=10)\nend","category":"page"},{"location":"neighborlists/#Neighbor-lists","page":"Neighbor lists","title":"Neighbor lists","text":"","category":"section"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"The package provides a neighborlist function that implements this calculation. Without periodic boundary conditions, just do:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> x = [ rand(2) for _ in 1:10_000 ];\n\njulia> CellListMap.neighborlist(x,0.05)\n24777-element Vector{Tuple{Int64, Int64, Float64}}:\n (0, 62, 0.028481068525796384)\n ‚ãÆ\n (9953, 1749, 0.04887502372299809)\n (9973, 124, 0.040110356034451795)","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"or CellListMap.neighborlist(x,y,r) for computing the lists of pairs of two sets closer than r.","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"The returning array contains tuples with the index of the particle in the first vector, the index of the particle in the second vector, and their distance.","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"If periodic boundary conditions are used, the Box and CellList must be constructed in advance:","category":"page"},{"location":"neighborlists/","page":"Neighbor lists","title":"Neighbor lists","text":"julia> x = [ rand(2) for _ in 1:10_000 ]; \n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box);\n\njulia> CellListMap.neighborlist(box,cl)\n\njulia> CellListMap.neighborlist(box,cl)\n209505-element Vector{Tuple{Int64, Int64, Float64}}:\n (0, 121, 0.05553035041478053)\n (0, 1589, 0.051415489701932444)\n ‚ãÆ\n (7468, 7946, 0.09760096646331885)","category":"page"},{"location":"ecosystem/#Ecosystem-integration","page":"Ecosystem integration","title":"Ecosystem integration","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Agents.jl\nUnitful and units\nAutomatic differentiation\nMeasurements","category":"page"},{"location":"ecosystem/#Agents.jl","page":"Ecosystem integration","title":"Agents.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Agents.jl provides a comprehensive framework for simulation, analysis and visualization of agent-based systems. CellListMap can be used to accelerate these simulations, and the integration of the packages is rather simple, particularly using the PeriodicSystems interface. A complete integration example can be obtained in the Agents documentation (currently at the development branch). ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The example will produce the following animation:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"https://juliadynamics.github.io/Agents.jl/dev/examples/celllistmap.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"ecosystem/#Unitful-and-units","page":"Ecosystem integration","title":"Unitful and units","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The functions of CellListMap.jl support the propagation of generic (isbits) types, and thus units and thus automatic differentiation and the use of Unitful. A set of working examples can be found in the generic_types.jl file.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"We start illustrating the support for unit propagation. We need to define all involved quantities in the same units:","category":"page"},{"location":"ecosystem/#Using-the-PeriodicSystems-interface","page":"Ecosystem integration","title":"Using the PeriodicSystems interface","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The only requirement is to attach proper units to all quantities (positions, cutoff, unitcell, and output variables). Here we compute the square of the distances of the particles within the cutoff:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using CellListMap.PeriodicSystems, Unitful, StaticArrays\n\njulia> system = PeriodicSystem(\n           positions = rand(SVector{3,Float64}, 1000)u\"nm\",\n           cutoff = 0.1u\"nm\",\n           unitcell = [1.0,1.0,1.0]u\"nm\",\n           output = 0.0u\"nm^2\",\n           output_name = :sum_sqr\n       );\n\njulia> map_pairwise((x,y,i,j,d2,out) -> out += d2, system)\n12.467455105066907 nm^2","category":"page"},{"location":"ecosystem/#Units-in-neighbor-lists","page":"Ecosystem integration","title":"Units in neighbor lists","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"CellListMap.neighborlist propagates units correctly:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> import CellListMap\n\njulia> positions = rand(SVector{3,Float64}, 1000)u\"nm\";\n\njulia> cutoff = 0.1u\"nm\";\n\njulia> CellListMap.neighborlist(positions, cutoff)\n1842-element Vector{Tuple{Int64, Int64, Quantity{Float64, ùêã, Unitful.FreeUnits{(nm,), ùêã, nothing}}}}:\n (1, 89, 0.09181950064928723 nm)\n (1, 820, 0.0862244300739942 nm)\n ‚ãÆ\n (998, 782, 0.07772327062692863 nm)","category":"page"},{"location":"ecosystem/#Automatic-differentiation","page":"Ecosystem integration","title":"Automatic differentiation","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Allowing automatic differentiation follows the same principles, meaning that we only need to allow the propagation of dual types through the computation by proper initialization of the input data. However, it is easier to work with the low level interface, which accepts matrices as the input for positions and a more fine control of the types of the variables. Matrices are easier input types for auto diff packages.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The variables are each component of each vector, thus the easiest way to represent the points such that automatic differentiation packages understand is by creating a matrix:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> x = rand(3,1000)\n3√ó1000 Matrix{Float64}:\n 0.186744  0.328719  0.874102  0.503535   ‚Ä¶  0.328161  0.0895699  0.917338\n 0.176157  0.972954  0.80729   0.624724      0.655268  0.470754   0.327578\n 0.648482  0.537362  0.599624  0.0688776     0.92333   0.497984   0.208924","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The key here is allow all the types of the parameters to follow the type propagation of the elements of x inside the differentiation routine. The function we define to compute the derivative is, then:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> function sum_sqr(x,sides,cutoff)\n           cutoff = eltype(x)(cutoff)\n           sides = eltype(x).(sides)\n           box = Box(sides,cutoff)\n           cl = CellList(x,box)\n           sum_sqr = zero(eltype(x))\n           sum_sqr = map_pairwise!(\n               (x,y,i,j,d2,sum_sqr) -> sum_sqr += d2,\n               sum_sqr, box, cl\n           )\n           return sum_sqr\n       end\nsum_sqr (generic function with 1 method)","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Note that we allow cutoff  and sides  to be converted to the same type of the input x  of the function. For a simple call to the function this is inconsequential:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cutoff = 0.1; sides = [1,1,1];\n\njulia> sum_sqr(x,sides,cutoff)\n12.897650398753228","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"but the conversion is required to allow the differentiation to take place:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> ForwardDiff.gradient(x -> sum_sqr(x,sides,cutoff),x)\n3√ó1000 Matrix{Float64}:\n -0.132567   0.029865  -0.101301  ‚Ä¶   0.249267    0.0486424  -0.0400487\n  0.122421   0.207495  -0.184366     -0.201648   -0.105031    0.218342\n  0.0856502  0.288924   0.122445     -0.0147022  -0.103314   -0.0862264","category":"page"},{"location":"ecosystem/#Measurements","page":"Ecosystem integration","title":"Measurements","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"Propagating uncertainties through the Measurements  and other similar packages requires a different strategy, because within CellListMap only isbits types can be used, which is not the case of the type Measurement type. ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"In cases like this, it is better to bypass all the internals of CellListMap  and provide the data to the function that computes pairwise properties directly as a closure. For example:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"A vector of particles with uncertainties in their coordinates can be created with: ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using StaticArrays \n\njulia> x_input = [ SVector{3}(measurement(rand(),0.01*rand()) for i in 1:3) for j in 1:1000 ]\n1000-element Vector{SVector{3, Measurement{Float64}}}:\n [0.1658 ¬± 0.003, 0.9951 ¬± 0.0054, 0.5067 ¬± 0.0035]\n [0.2295 ¬± 0.0074, 0.2987 ¬± 0.0021, 0.42828 ¬± 0.00099]\n ‚ãÆ\n [0.1362 ¬± 0.0034, 0.2219 ¬± 0.0048, 0.2119 ¬± 0.0072]\n [0.2521 ¬± 0.0038, 0.4988 ¬± 0.00013, 0.856046 ¬± 4.3e-5]","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The variables within the CellListMap functions will be stripped from the uncertainties. We do:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cutoff = 0.1; box = Box([1,1,1],cutoff);\n\njulia> x_strip = [ getproperty.(v,:val) for v in x_input ]\n1000-element Vector{SVector{3, Float64}}:\n [0.08441931492362276, 0.9911530546181084, 0.07408559584648788]\n [0.12084764467339837, 0.8284551316333133, 0.9021906852432111]\n ‚ãÆ\n [0.2418752113326077, 0.4429225751775432, 0.13576355747772784]\n [0.24440380524702654, 0.07148275176890073, 0.26722687487212315]","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The cell list is built with the stripped values:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> cl = CellList(x_strip,box)\nCellList{3, Float64}\n  1000 real particles.\n  637 cells with real particles.\n  1695 particles in computing box, including images.","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"The result is initialized with the proper type,","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> sum_sqr = measurement(0.,0.)\n0.0 ¬± 0.0","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"and the mapping is performed with the stripped coordinates, but passing the values with uncertainties to the mapped function, which will perform the computation on the pairs with those values:","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"julia> using LinearAlgebra: norm_sqr\n\njulia> sum_sqr = map_pairwise!(\n           (x·µ¢,x‚±º,i,j,d2,sum_sqr) -> begin\n               x1 = x_input[i]\n               x2 = CellListMap.wrap_relative_to(x_input[j],x1,box)\n               sum_sqr += norm_sqr(x2-x1)\n               return sum_sqr\n           end, \n           sum_sqr, box, cl\n       )\n13.14 ¬± 0.061","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"In the function above, the x·µ¢ and x‚±º coordinates, which correspond to the coordinates in x_input[i] and x_input[j], but already wrapped relative to each other, are ignored, because they don't carry the uncertainties. We use only the indexes i and j to recompute the relative position of the particles according to the periodic boundary conditions (using the CellListMap.wrap_relative_to function) and their (squared) distance. Since the x_input  array carries the uncertainties, the computation of sum_sqr will propagate them.   ","category":"page"},{"location":"ecosystem/","page":"Ecosystem integration","title":"Ecosystem integration","text":"note: Note\nAll these computations should be performed inside the scope of a function for optimal performance. The examples here can be followed by copying and pasting the code into the REPL, but this is not the recommended practice for critical code. The strategy of bypassing the internal computations of CellListMap may be useful for improving performance even if the previous and simpler method is possible. ","category":"page"},{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"These entries can be viewed at the Julia REPL Julia using ","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? \nhelp?> function_name","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"Modules=[CellListMap]","category":"page"},{"location":"help/#CellListMap.AuxThreaded","page":"Help entries","title":"CellListMap.AuxThreaded","text":"struct AuxThreaded{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nparticles_per_batch::Int64\nidxs::Vector{UnitRange{Int64}}\nDefault: Vector{UnitRange{Int}}(undef, 0)\nlists::Array{CellList{N, T}, 1} where {N, T}\nDefault: Vector{CellList{N, T}}(undef, 0)\n\nAuxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.AuxThreaded-Tuple{CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellListPair{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type for lists of disjoint particle sets,  to be passed to UpdateCellList! for in-place update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.AuxThreaded","text":"AuxThreaded(cl::CellList{N,T}) where {N,T}\n\nConstructor for the AuxThreaded type, to be passed to UpdateCellList! for in-place  update of cell lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for _ in 1:100_000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> cl = UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  31190 cells with real particles.\n  1134378 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box","page":"Help entries","title":"CellListMap.Box","text":"struct Box{UnitCellType, N, T, TSQ, M}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nunit_cell::CellListMap.UnitCell\nlcell::Int64\nnc::StaticArraysCore.SVector{N, Int64} where N\ncutoff::Any\ncutoff_sq::Any\nranges::StaticArraysCore.SVector{N, UnitRange{Int64}} where N\ncell_size::StaticArraysCore.SVector\nunit_cell_max::StaticArraysCore.SVector\n\nStructure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. \n\nExamples\n\njulia> using CellListMap\n\njulia> sides = [250,250,250];\n\njulia> cutoff = 10;\n\njulia> box = Box(sides,cutoff)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [27, 27, 27]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 19683\n\n\njulia> box = Box([ 10  0  0 \n                    0 10  5\n                    0  0 10 ], 1)\nBox{TriclinicCell, 3, Float64, 9}\nunit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]\ncutoff: 1.0\nnumber of computing cells on each dimension: [12, 17, 12]\ncomputing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)\nTotal number of cells: 2448\n\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Box-Union{Tuple{T}, Tuple{CellListMap.Limits, T}} where T","page":"Help entries","title":"CellListMap.Box","text":"Box(\n    limits::Limits,\n    cutoff;\n    lcell::Int=1\n)\n\nThis constructor receives the output of limits(x) or limits(x,y) where x and y are the coordinates of the particles involved, and constructs a Box with size larger than the maximum coordinates ranges of all particles plus twice the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is always an Orthorhombic cell.\n\nExamples\n\njulia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),10)\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\n  unit cell matrix = [ 119.99907193208746, 0.0, 0.0; 0.0, 119.99968623301143, 0.0; 0.0, 0.0, 119.99539603156498 ]\n  cutoff = 10.0\n  number of computing cells on each dimension = [13, 13, 13]\n  computing cell sizes = [10.909006539280679, 10.90906238481922, 10.908672366505908] (lcell: 1)\n  Total number of cells = 2197\n\njulia> y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),10)\nBox{OrthorhombicCell, 3, Float64, Float64, 9}\n  unit cell matrix = [ 169.99914503548962, 0.0, 0.0; 0.0, 169.9990736881799, 0.0; 0.0, 0.0, 119.99726063023918 ]\n  cutoff = 10.0\n  number of computing cells on each dimension = [18, 18, 13]\n  computing cell sizes = [10.624946564718101, 10.624942105511243, 10.90884187547629] (lcell: 1)\n  Total number of cells = 4212\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractMatrix, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  unit_cell_matrix::AbstractMatrix, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=TriclinicCell\n)\n\nConstruct box structure given the cell matrix of lattice vectors. This  constructor will always return a TriclinicCell box type, unless the UnitCellType parameter is set manually to OrthorhombicCell\n\nExample\n\njulia> unit_cell = [ 100   50    0 \n                       0  120    0\n                       0    0  130 ];\n\njulia> box = Box(unit_cell,10)\nBox{TriclinicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [17, 14, 15]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 3570\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{AbstractVector, Any, Int64, Type{UnitCellType}}} where UnitCellType","page":"Help entries","title":"CellListMap.Box","text":"Box(\n  sides::AbstractVector, \n  cutoff, \n  lcell::Int=1,\n  UnitCellType=OrthorhombicCell\n)\n\nFor orthorhombic unit cells, Box can be initialized with a vector of the  length of each side. \n\nExample\n\njulia> box = Box([120,150,100],10)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]\n  cutoff: 10.0\n  number of computing cells on each dimension: [14, 17, 12]\n  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)\n  Total number of cells: 2856\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.Cell","page":"Help entries","title":"CellListMap.Cell","text":"struct Cell{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlinear_index::Int64\ncartesian_index::CartesianIndex\ncenter::StaticArraysCore.SVector\ncontains_real::Bool\nn_particles::Int64\nparticles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}\n\nThis structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighboring cells need to be wrapped) \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList","page":"Help entries","title":"CellListMap.CellList","text":"struct CellList{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nn_real_particles::Int64\nNumber of real particles.\nnumber_of_cells::Int64\nNumber of cells.\nn_particles::Int64\nmutable number of particles in the computing box.\nn_cells_with_real_particles::Int64\nmutable number of cells with real particles.\nn_cells_with_particles::Int64\nmutable number of cells with particles, real or images.\ncell_indices::Vector{Int64}\nAuxiliary array that contains the indexes in list of the cells with particles, real or images.\ncell_indices_real::Vector{Int64}\nAuxiliary array that contains the indexes in the cells with real particles.\ncells::Array{CellListMap.Cell{N, T}, 1} where {N, T}\nVector containing cell lists of cells with particles.\nnbatches::CellListMap.NumberOfBatches\nNumber of batches for the parallel calculations.\nprojected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}\nAuxiliar array to store projected particles.\n\nStructure that contains the cell lists information.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(x::AbstractMatrix, y::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} \n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"function CellList(x::AbstractMatrix, box::Box{UnitCellType,N,T}; kargs...) where {UnitCellType,N,T} \n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0),\n    autoswap::Bool=true\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellListPair structure from scracth, given two vectors of particle coordinates and a Box, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using autoswap=false the cell list is constructed for the second (y)\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   10000 particles in the reference vector.\n   961 cells with real particles of target vector.\n\njulia> cl = CellList(x,y,box,autoswap=false)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   7389 cells with real particles of target vector.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{<:AbstractVector}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.CellList","text":"CellList(\n    x::AbstractVector{AbstractVector},\n    box::Box{UnitCellType,N,T};\n    parallel::Bool=true,\n    nbatches::Tuple{Int,Int}=(0,0)\n) where {UnitCellType,N,T} \n\nFunction that will initialize a CellList structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a Box, which contain the size ofthe system, cutoff, etc. Except for small systems, the number of parallel batches is equal to the number of threads, but it can be tunned for optimal performance in some cases.\n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100000 real particles.\n  15600 cells with real particles.\n  126276 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.CellListPair","page":"Help entries","title":"CellListMap.CellListPair","text":"struct CellListPair{V, N, T, Swap}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nref::Any\ntarget::CellList\n\nStructure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Limits","page":"Help entries","title":"CellListMap.Limits","text":"struct Limits{T<:(AbstractVector)}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nlimits::AbstractVector\n\nStructure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.NumberOfBatches","page":"Help entries","title":"CellListMap.NumberOfBatches","text":"struct NumberOfBatches\n\nInternal function or structure - interface may change.\n\nExtended help\n\nbuild_cell_lists::Int64\nmap_computation::Int64\n\nStructure to define the number of batches used in the parallel splitting of the calculations of the cell list construction and of the map_pairwise computation. It is initialized with a standard heuristic that returns at most the number of threads, but may return a smaller number if the system is small. The two parameters can be tunned for optimal performance of each step of the calculation (cell list construction and mapping of interactions). The construction of the cell lists require a larger number of particles for threading to be effective, Thus by default the system size that allows multi-threading is greater for this part of the calculation.  \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ParticleWithIndex","page":"Help entries","title":"CellListMap.ParticleWithIndex","text":"struct ParticleWithIndex{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nreal::Bool\ncoordinates::StaticArraysCore.SVector\n\nCopies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. \n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.ProjectedParticle","page":"Help entries","title":"CellListMap.ProjectedParticle","text":"struct ProjectedParticle{N, T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nindex::Int64\nxproj::Any\ncoordinates::StaticArraysCore.SVector\n\nAuxiliary structure to contain projected particles. Types of  scalars are chosen such that with a SVector{3,Float64} the complete struct has 32bytes.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.Swapped","page":"Help entries","title":"CellListMap.Swapped","text":"Internal function or structure - interface may change.\n\nStructures to control dispatch on swapped vs. not swapped cell list pairs.\n\n\n\n\n\n","category":"type"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n  x::AbstractVector{<:AbstractVector},\n  y::AbstractVector{<:AbstractVector},\n  box::Box,\n  cl:CellListPair,\n  parallel=true\n)\n\nFunction that will update a previously allocated CellListPair structure, given  new updated particle positions, for example. This method will allocate new  aux threaded auxiliary arrays. For a non-allocating version, see the  UpdateCellList!(x,y,box,cl,aux) method.\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];\n\njulia> cl = CellList(x,y,box);\n\njulia> cl = UpdateCellList!(x,y,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Tuple{AbstractVector{<:AbstractVector}, Box, CellList}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl:CellList,\n    parallel=true\n) \n\nFunction that will update a previously allocated CellList structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the UpdateCellList!(x,box,cl,aux) method instead. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> box = Box([260,260,260],10);\n\njulia> x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];\n\njulia> cl = UpdateCellList!(x,box,cl); # update lists\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:AbstractVector}, Box, CellListMap.CellListPair{V, N, T, Swap}, Union{Nothing, CellListMap.AuxThreaded}}} where {V, N, T, Swap<:CellListMap.NotSwapped}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    y::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl_pair::CellListPair,\n    aux::Union{Nothing,AuxThreaded};\n    parallel::Bool=true\n)\n\nThis function will update the cl_pair structure that contains the cell lists for disjoint sets of particles. It receives the preallocated aux structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7381 cells with real particles of target vector.\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(3) for i in 1:50_000 ];\n\njulia> y = [ 250*rand(3) for i in 1:10_000 ];\n\njulia> cl = UpdateCellList!(x,y,box,cl,aux)\nCellList{3, Float64}\n  10000 real particles.\n  7358 cells with real particles.\n  12591 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux)\n  715.661 Œºs (41 allocations: 3.88 KiB)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   50000 particles in the reference vector.\n   7414 cells with real particles of target vector.\n   \njulia> @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)\n   13.042 ms (0 allocations: 0 bytes)\n CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n    50000 particles in the reference vector.\n    15031 cells with real particles of target vector.\n \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T},\n    aux::Union{Nothing,AuxThreaded{N,T}};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix, Box, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    box::Box,\n    cl::CellList{N,T};\n    parallel::Bool=true\n) where {N,T}\n\nReinterprets the matrix x as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{<:AbstractVector}, Box, CellList{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractVector{<:AbstractVector},\n    box::Box,\n    cl::CellList{N,T},\n    aux::Union{Nothing,AuxThreaded{N,T}};\n    parallel::Bool=true\n) where {N,T}\n\nFunction that updates the cell list cl new coordinates x and possibly a new box box, and receives a preallocated aux structure of auxiliary vectors for threaded cell list construction. Given a preallocated aux vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. \n\nExample\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> cl = CellList(x,box);\n\njulia> aux = CellListMap.AuxThreaded(cl)\nCellListMap.AuxThreaded{3, Float64}\n Auxiliary arrays for nthreads = 8\n\njulia> x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];\n\njulia> UpdateCellList!(x,box,cl,aux)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\n\nTo illustrate the expected ammount of allocations, which are a consequence of thread spawning only:\n\njulia> using BenchmarkTools\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux)\n  16.384 ms (41 allocations: 3.88 KiB)\nCellList{3, Float64}\n  100000 real particles.\n  15599 cells with real particles.\n  125699 particles in computing box, including images.\n\njulia> @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)\n  20.882 ms (0 allocations: 0 bytes)\nCellList{3, Float64}\n  100000 real particles.\n  15603 cells with real particles.\n  125896 particles in computing box, including images.\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair{N, T}, Union{Nothing, CellListMap.AuxThreaded{N, T}}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box,\n    cl_pair::CellListPair,\n    aux::Union{Nothing,AuxThreaded};\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix, AbstractMatrix, Box{UnitCellType, N, T}, CellListMap.CellListPair}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.UpdateCellList!","text":"function UpdateCellList!(\n    x::AbstractMatrix,\n    y::AbstractMatrix,\n    box::Box{UnitCellType,N,T},\n    cl_pair::CellListPair;\n    parallel::Bool=true\n) where {UnitCellType,N,T}\n\nReinterprets the matrices x and y as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (2 or 3).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap._promote_types-Tuple{Any, Any}","page":"Help entries","title":"CellListMap._promote_types","text":"_promote_types(cell,cutoff)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nPromotes the types of the unit cell matrix (or sides) and cutoff to floats if one or both were input as integers. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particle_to_celllist!","text":"add_particle_to_celllist!(\n    ip,\n    x::SVector{N,T},\n    box,\n    cl::CellList{N,T};\n    real_particle::Bool=true\n) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdds one particle to the cell lists, updating all necessary arrays.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.add_particles!","text":"add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd all particles in vector x to the cell list cl. ishift is the shift in particle index, meaning that particle i of vector x corresponds to the particle with original index i+ishift. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.append_particles!","text":"append_particles!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAdd the particles of cell2 to cell1, updating the cell data and, if necessary, resizing (increasing) the particles array of cell1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_cartesian_indices","text":"cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nGiven the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.cell_center","text":"cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nComputes the geometric center of a computing cell, to be used in the projection of points. Returns a SVector{N,T}\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N, Int64}, Any}} where N","page":"Help entries","title":"CellListMap.cell_linear_index","text":"cell_linear_index(nc::SVector{N,Int}, indices) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the index of the cell, in the 1D representation, from its cartesian coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.cell_matrix_from_sides-Tuple{AbstractVector}","page":"Help entries","title":"CellListMap.cell_matrix_from_sides","text":"cell_matrix_from_sides(sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the Orthorhombic unit cell matrix given a sides vector.\n\nExample\n\njulia> CellListMap.cell_matrix_from_sides([1,1,1])\n3√ó3 SMatrix{3, 3, Int64, 9} with indices SOneTo(3)√óSOneTo(3):\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.check_unit_cell-Tuple{Box}","page":"Help entries","title":"CellListMap.check_unit_cell","text":"check_unit_cell(box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nChecks if the unit cell satisfies the conditions for using the minimum-image convention. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}","page":"Help entries","title":"CellListMap.copydata!","text":"copydata!(cell1::Cell,cell2::Cell)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nCopies the data from cell2 to cell1, meaning that particles are copied element-wise from cell2 to cell1, with the particles array of cell1 being resized (increased) if necessary.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}","page":"Help entries","title":"CellListMap.dot","text":"dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2} \n\nInternal function or structure - interface may change.\n\nExtended help\n\nLinearAlgebra.dot is slower than this for standard arrays (likely more accurate, but that is not relevant here).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType\n\ndraw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType\n\nInternal function or structure - interface may change.\n\nThis function creates a plot of the computing cell, in two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3}}} where UnitCellType","page":"Help entries","title":"CellListMap.draw_computing_cell","text":"draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType\n\nInternal function or structure - interface may change.\n\nThis function creates a plot of the computing cell, in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.fastmod1-Tuple{Any}","page":"Help entries","title":"CellListMap.fastmod1","text":"fastmod1(x)\n\nInternal function or structure - interface may change.\n\nComputes mod(x,1), quickly, using x - floor(x). Maybe irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Help entries","title":"CellListMap.fix_upper_boundary","text":"fix_upper_boundary(x::T,side) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nMove x to x -side if x == side, because we use the convention that the upper boundary belongs to current cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Tuple{AbstractVector{<:AbstractVector}}","page":"Help entries","title":"CellListMap.limits","text":"limits(x)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x,  to be used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractVector{<:AbstractVector})","page":"Help entries","title":"CellListMap.limits","text":"limits(x,y)\n\nReturns the lengths of a orthorhombic box that encompasses all the particles defined in x and y, to used to set a box without effective periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_naive!-Tuple{Any, Any, Any, Box}","page":"Help entries","title":"CellListMap.map_naive!","text":"map_naive!(f,output,x,box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that uses the naive pairwise mapping algorithm, for testing.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise","page":"Help entries","title":"CellListMap.map_pairwise","text":"map_pairwise(args...;kargs...) = map_pairwise!(args...;kargs...)`\n\nis an alias for map_pairwise! which is defined for two reasons: first, if the output of the funciton is immutable, it may be  clearer to call this version, from a coding perspective. Second, the python interface through juliacall does not accept the  bang as a valid character. \n\n\n\n\n\n","category":"function"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, CellList}} where F","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(\n  f::Function,\n  output,\n  box::Box,\n  cl::CellList\n  ;parallel::Bool=true,\n  show_progress::Bool=false\n)\n\nThis function will run over every pair of particles which are closer than  box.cutoff and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the Box structure.  If the distance is smaller than the cutoff, a function f of the  coordinates of the two particles will be computed. \n\nThe function f receives six arguments as input: \n\nf(x,y,i,j,d2,output)\n\nWhich are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the output variable.  It has also to return the same output variable. Thus, f may or not  mutate output, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance d2 is computed  internally for comparison with the  cutoff, and is passed to the f because many times it is used for the  desired computation. \n\nExample\n\nComputing the mean absolute difference in x position between random particles,  remembering the number of pairs of n particles is n(n-1)/2. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.\n\njulia> n = 100_000;\n\njulia> box = Box([250,250,250],10);\n\njulia> x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];\n\njulia> cl = CellList(x,box);\n\njulia> f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\n\njulia> normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\njulia> avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.map_pairwise!-Union{Tuple{Swap}, Tuple{T}, Tuple{N}, Tuple{V}, Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair{V, N, T, Swap}}} where {F1, F2, V, N, T, Swap}","page":"Help entries","title":"CellListMap.map_pairwise!","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)\n\nThe same but to evaluate some function between pairs of the particles of the vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}","page":"Help entries","title":"CellListMap.merge_cell_lists!","text":"merge_cell_lists!(cl::CellList,aux::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nMerges an auxiliary aux cell list to cl, and returns the modified cl. Used to merge cell lists computed in parallel threads.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.nbatches-Tuple{CellList}","page":"Help entries","title":"CellListMap.nbatches","text":"nbatches(cl)\n\nReturns the number of batches for parallel processing that will be used in the pairwise function mappings associated to cell list cl.  It returns the cl.nbatches.map_computation value. This function is important because it must be used to set the number of copies of custom preallocated output arrays.\n\nA second argument can be provided, which may be :map or :build, in which case the function returns either the number of batches used  for pairwise mapping or for the construction of the cell lists. Since this second value is internal and does not affect the interface,  it can be usually ignored. \n\nExample\n\njulia> x = rand(3,1000); box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box,nbatches=(2,16));\n\njulia> nbatches(cl)\n16\n\njulia> nbatches(cl,:map)\n16\n\njulia> nbatches(cl,:build)\n2\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbor_cells","text":"neighbor_cells(box::Box{UnitCellType,N}) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of all neighboring cells of a cell if the cells have sides of box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighbor_cells_forward-Union{Tuple{Box{UnitCellType, 3}}, Tuple{UnitCellType}} where UnitCellType","page":"Help entries","title":"CellListMap.neighbor_cells_forward","text":"neighbor_cells_forward(box::Box{UnitCellType,N}) where UnitCellType \n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length box.cell_size. N can be 2 or 3, for two- or three-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(x,y,r;parallel=true,autoswap=true)\n\nComputes the list of pairs of particles of x which are closer than r to the particles of y. The autoswap option will swap x and y to try to optimize the cost of the construction of the cell list. \n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> y = [ rand(3) for i in 1:1_000 ];\n\njulia> CellListMap.neighborlist(x,y,0.05)\n5006-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 269, 0.04770884036497686)\n (25, 892, 0.03850515231540869)\n ‚ãÆ\n (9952, 749, 0.048875643578313456)\n (9984, 620, 0.04101242499363183)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(x,r;parallel=true)\n\nComputes the list of pairs of particles in x which are closer to each other than r.\n\nExample\n\njulia> x = [ rand(3) for i in 1:10_000 ];\n\njulia> CellListMap.neighborlist(x,0.05)\n24848-element Vector{Tuple{Int64, Int64, Float64}}:\n (1, 1055, 0.022977369806392412)\n (1, 5086, 0.026650609138167428)\n ‚ãÆ\n (9989, 3379, 0.0467653507446483)\n (9989, 5935, 0.02432728985151653)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.neighborlist-Tuple{Box, Any}","page":"Help entries","title":"CellListMap.neighborlist","text":"neighborlist(box, cl; parallel=true)\n\nCompute the neighbor list of a single set or set pairs of particles. Returns a vector of tuples with all indices of the particles that are within box.cutoff, and the distances.  \n\nExample\n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02) \nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n  cutoff: 0.02\n  number of computing cells on each dimension: [52, 52, 52]\n  computing cell sizes: [0.02, 0.02, 0.02] (lcell: 1)\n  Total number of cells: 140608\n\njulia> cl = CellList(x,box) # single set\nCellList{3, Float64}\n  999 cells with real particles.\n  1126 particles in computing box, including images.\n\n\njulia> CellListMap.neighborlist(box,cl,parallel=false)\n15-element Vector{Tuple{Int64, Int64, Float64}}:\n (187, 511, 0.010346860078531755)\n (203, 708, 0.010777737363239403)\n (296, 579, 0.018124283912224655)\n ‚ãÆ\n (584, 4, 0.016935844769524398)\n (725, 749, 0.019971874892397875)\n (773, 119, 0.01835233336121765)\n (927, 8, 0.011234110402648743)\n\n\nTo obtain the neighbor list (within the cutoff) between two sets of  particles, initialize the cell lists with the two sets: \n\njulia> x = [ rand(3) for i in 1:1000 ];\n\njulia> y = [ rand(3) for i in 1:1000 ];\n\njulia> box = Box([1,1,1],0.02);\n\njulia> cl = CellList(x,y,box)\n\njulia> cl = CellList(x,y,box)\nCellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}\n   1000 particles in the reference vector.\n   997 cells with real particles of target vector.\n\njulia> CellListMap.neighborlist(box,cl)\n35-element Vector{Tuple{Int64, Int64, Float64}}:\n (409, 982, 0.01634641594779082)\n (521, 422, 0.00919026348035512)\n (625, 731, 0.012986301890746663)\n ‚ãÆ\n (647, 730, 0.01565763971458105)\n (296, 668, 0.016556686306217868)\n (992, 589, 0.018392993428289553)\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm-Tuple{Any}","page":"Help entries","title":"CellListMap.norm","text":"norm(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own norm(x) = norm_sqr(x).\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Help entries","title":"CellListMap.norm_sqr","text":"norm_sqr(v::AbstractVector{T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nnorm_sqr from LinearAlgebra is not documented and is slower than this for standard arrays. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.out_of_bounding_box","text":"out_of_bounding_box(x::SVector{N},box::Box) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that evaluates if a particle is outside the computing bounding box, defined by the maximum and minimum unit cell coordinates. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArraysCore.SVector{N}, Box}} where N","page":"Help entries","title":"CellListMap.particle_cell","text":"particle_cell(x::SVector{N,T}, box::Box) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReturns the coordinates of the computing cell to which a particle belongs, given its coordinates and the cell_size vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes Box.lcell + 1.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.particles_per_cell-Tuple{CellList}","page":"Help entries","title":"CellListMap.particles_per_cell","text":"particles_per_cell(cl)\n\nReturns the average number of real particles per computing cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.partition!-Tuple{Any, AbstractVector}","page":"Help entries","title":"CellListMap.partition!","text":"partition!(x::AbstractVector,by)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that reorders x vector by putting in the first positions the elements with values satisfying by(el). Returns the number of elements that satisfy the condition.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.pathological_coordinates-Tuple{Any}","page":"Help entries","title":"CellListMap.pathological_coordinates","text":"pathological_coordinates(N)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction to generate some coordinates with pathological properties, for testing. Returns x, y, sides and cutoff.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N}}} where {UnitCellType, N}","page":"Help entries","title":"CellListMap.project_particles!","text":"project_particles!(projected_particles,cell‚±º,cell·µ¢,Œîc,Œîc_norm,box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nProjects all particles of the cell cell‚±º into unnitary vector Œîc with direction  connecting the centers of cell‚±º and cell·µ¢. Modifies projected_particles, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArraysCore.SMatrix{2, 2, T}}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{2,2,T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 2D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArraysCore.SMatrix{3, 3, T}}} where T","page":"Help entries","title":"CellListMap.ranges_of_replicas","text":"ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T\n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunction that sets which is the range of periodic images necessary to fill the computing box, in 3D.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T","page":"Help entries","title":"CellListMap.reduce","text":"reduce(output, output_threaded)\n\nMost common reduction function, which sums the elements of the output.  Here, output_threaded is a vector containing nbatches(cl) copies of the output variable (a scalar or an array). Custom reduction functions  must replace this one if the reduction operation is not a simple sum.  The output_threaded array is, by default, created automatically by copying the given output variable nbatches(cl) times. \n\nExamples\n\nScalar reduction: \n\njulia> output = 0.; output_threaded = [ 1, 2 ];\n\njulia> CellListMap.reduce(output,output_threaded)\n3\n\nArray reduction:\n\njulia> output = [0,0]; output_threaded = [ [1,1], [2,2] ];\n\njulia> CellListMap.reduce(output,output_threaded)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> output\n2-element Vector{Int64}:\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N}, Any, Any}} where N","page":"Help entries","title":"CellListMap.replicate_particle!","text":"replicate_particle!(ip,p::SVector{N},box,cl) where N\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicates the particle as many times as necessary to fill the computing box.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.replicate_system!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{StaticArraysCore.SVector{N, T}, 1}, AbstractMatrix, Tuple}} where {N, T}","page":"Help entries","title":"CellListMap.replicate_system!","text":"replicate_system!(x::AbstractVector,box::Box,ranges::Tuple)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nReplicate the system (modifying the original array of coordinates) in all directions defined by the periodic system and by the range of unitary cells  of interest. x can be a (N,M) matrix, and the unit cell matrix can be provided instead of the box.\n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.replicate_system!(x,box,(0:0,-1:1))\n300-element Vector{SVector{2, Float64}}:\n [0.7119987163255118, 0.6788616154460262]\n [0.6188407316804118, 0.8497116428720384]\n [0.21328895963244354, 0.48932085643862977]\n ‚ãÆ\n [0.4114499470191678, 1.1034376619603892]\n [0.6094126258851252, 1.2328989485215263]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.reset!","text":"reset!(cl::CellList{N,T},box,n_real_particles) where{N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nResets a cell list, by setting everything to zero, but retaining the allocated particles and projected_particles vectors.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_idxs!-Tuple{Any, Any, Any}","page":"Help entries","title":"CellListMap.set_idxs!","text":"set_idxs!(idxs, n_particles, nbatches)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nSets the indexes of the particles that will be considered for each batch in parallel runs. Modifies the idxs array of ranges, which is usually the aux.idxs array of the the  corresponding AuxThreaded structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.set_number_of_batches!-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Tuple{Int64, Int64}}} where {N, T}","page":"Help entries","title":"CellListMap.set_number_of_batches!","text":"set_number_of_batches!(cl,nbatches::Tuple{Int,Int}=(0,0);parallel=true)  \n\nInternal function or structure - interface may change.\n\nExtended help\n\nFunctions that set the default number of batches for the construction of the cell lists,  and mapping computations. This is of course heuristic, and may not be the best choice for every problem. See the parameter nbatches of the construction of the cell lists for  tunning this.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Tuple{AbstractVector{<:AbstractVector}, Any, Any}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::AbstractVector{<:AbstractVector},unit_cell_matrix,indices)\n\nTranslates a complete set of coordinates given a set of indexes of unit-cells. Returns a new set of coordinates. \n\nExample\n\njulia> x = rand(SVector{2,Float64},100);\n\njulia> box = Box([1,1],0.1);\n\njulia> CellListMap.translation_image(x,box.unit_cell.matrix,(1,1))\n100-element Vector{SVector{2, Float64}}:\n [1.847791110439223, 1.5989103939725295]\n [1.3493293666090889, 1.4002971843576644]\n [1.4111736701313218, 1.3471780214994182]\n ‚ãÆ\n [1.1548437388991908, 1.7034501001177493]\n [1.4066300885242247, 1.2907398318754952]\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any, Any}} where {N, T}","page":"Help entries","title":"CellListMap.translation_image","text":"translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nTranslate vector x according to the unit_cell_matrix lattice vectors and the indices provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Help entries","title":"CellListMap.view_celllist_particles","text":"view_celllist_particles(cl::CellList)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nAuxiliary function to view the particles of a computing box, including images created for computing purposes.\n\nExample\n\njulia> box = Box([ 100 50; 50 100 ],10);\n\njulia> x = [ box.unit_cell_max .* rand(SVector{2,Float64}) for i in 1:1000 ];\n\njulia> cl = CellList(x,box);\n\njulia> p = CellListMap.view_celllist_particles(cl);\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),label=nothing,xlims=(-10,180),ylims=(-10,180))\n\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_cell_fraction-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_cell_fraction","text":"wrap_cell_fraction(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nObtaint the coordinates of x as a fraction of unit cell vectors, first positive cell. x is a vector of dimension N and cell a matrix of  dimension NxN\n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_cell_fraction(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 0.5\n 0.3\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,sides::AbstractVector)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, for an Orthorhombic cell of which only the side lengths are provided.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given an Orthorhombic cell. This is slightly cheaper than for general cells.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArraysCore.SMatrix{N, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref. \n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T}}} where {UnitCellType, N, T}","page":"Help entries","title":"CellListMap.wrap_relative_to","text":"wrap_relative_to(x,xref,box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that it is the minimum image relative to xref, given a general Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Any}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,unit_cell_matrix)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates. \n\nExample\n\njulia> unit_cell_matrix = [ 10 0\n                            0 10 ];\n\njulia> x = [ 15, 13 ];\n\njulia> wrap_to_first(x,unit_cell_matrix)\n2-element Vector{Float64}:\n 5.0\n 3.0000000000000004\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Tuple{Any, Box}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box)\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given the Box structure.\n\n\n\n\n\n","category":"method"},{"location":"help/#CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T}}} where {N, T}","page":"Help entries","title":"CellListMap.wrap_to_first","text":"wrap_to_first(x,box::Box{OrthorhombicCell,N,T}) where {N,T}\n\nInternal function or structure - interface may change.\n\nExtended help\n\nWraps the coordinates of point x such that the returning coordinates are in the first unit cell with all-positive coordinates, given an Orthorhombic cell.  This is slightly cheaper than for general cells.  \n\n\n\n\n\n","category":"method"},{"location":"python/#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"Callling CellListMap from python can be useful if lists of neighbors or other properties have to be computed many times, making the overhead of initializing Julia negligible. As the example and benchmark below demonstrates, the current implementation of cell lists in this package is faster than common alternatives available in the python ecosystem. ","category":"page"},{"location":"python/#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"First, install juliacall using the pip package manager, with","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% pip install juliacall","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Using ipython3 (only Python geq 3 is supported), do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: from juliacall import Main as jl","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which, on the first call only, will install the latest stable version of Julia. Then, install CellListMap, with:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [2]: jl.Pkg.add(\"CellListMap\")","category":"page"},{"location":"python/#Calling-neighborlist","page":"From Python","title":"Calling neighborlist","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The typical input coordinates, in python, are a numpy array with shape (N,dim) where N is the number of particles and dim is the dimension of the space (2 or 3 for CellListMap). Here, we generate a set of 50,000 particles in three dimensions:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [1]: import numpy as np\n\nIn [2]: coords = np.random.random((50_000,3))","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Julia is column-major, and python is row-major, thus if we want to use the functions from CellListMap we need to transpose the coordinates:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [3]: coords_t = coords.transpose()","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"These transposed coordinates can be used in the CellListMap.neighborlist function. For example:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [4]: from juliacall import Main as jl\n\nIn [5]: jl.seval(\"using CellListMap\")\n\nIn [6]: neighbor_list = jl.CellListMap.neighborlist(coords_t,0.05)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"which will return a list of tuples, containing all pairs of coordinates withing the cutoff (remember that the first call to a Julia function will always take longer than subsequent calls, because the function is JIT compiled):","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [12]: neighbor_list.shape\nOut[12]: (618774,)\n\nIn [13]: neighbor_list[1]\nOut[13]: (1, 37197, 0.047189685889846615)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Note that the third element of the tuple is the distance between the points.","category":"page"},{"location":"python/#Benchmark","page":"From Python","title":"Benchmark","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"To properly benchmark the neighborlist function from CellListMap, let us first define a simple wrapper that will include the transposition of the coordinates in the time:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [14]: def neighborlist(x,cutoff):\n    ...:     y = x.transpose()\n    ...:     nn = jl.CellListMap.neighborlist(y,cutoff)\n    ...:     return nn\n    ...:\n\nIn [15]: %timeit neighborlist(coords,0.05)\n61.7 ms ¬± 707 ¬µs per loop (mean ¬± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Let us compare this with the performance of a inrange neighborlist algorithm from scipy:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [29]: from scipy.spatial import cKDTree\n\nIn [30]: def neighborlist_scipy(x,cutoff) : \n    ...:     kd_tree = cKDTree(x)  \n    ...:     pairs = kd_tree.query_pairs(r=0.05)  \n    ...:     return pairs \n    ...:\n\nIn [31]: %timeit neighborlist_scipy(coords,0.05)\n206 ms ¬± 2.07 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"Just to confirm, this is the number of pairs that is being output in this test","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [32]: len(neighborlist_scipy(x,cutoff)) # using Scipy\nOut[32]: 618475\n\nIn [20]: len(neighborlist(coords,0.05)) # using CellListMap\nOut[20]: 618475","category":"page"},{"location":"python/#Multi-threading","page":"From Python","title":"Multi-threading","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"These examples were run single-threaded. To run multi-threaded, an environment variable for Julia needs to be set. For example, in bash, do:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"% export JULIA_NUM_THREADS=8","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"For the current example, this provides a small additional speedup:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [11]: %timeit neighborlist(coords,0.05)\n31.3 ms ¬± 1.22 ms per loop (mean ¬± std. dev. of 7 runs, 10 loops each)","category":"page"},{"location":"python/#Overhead","page":"From Python","title":"Overhead","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"The overhead of calling the function through juliacall  is small. From within Julia, the timings of a similar execution would be:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"julia> using BenchmarkTools\n\njulia> using CellListMap\n\njulia> x = rand(3,50_000);\n\njulia> @btime CellListMap.neighborlist($x,0.05);\n  27.294 ms (35935 allocations: 58.39 MiB)\n\njulia> @btime CellListMap.neighborlist($x,0.05,parallel=false);\n  51.299 ms (17687 allocations: 37.43 MiB)","category":"page"},{"location":"python/#General-mappings","page":"From Python","title":"General mappings","text":"","category":"section"},{"location":"python/","page":"From Python","title":"From Python","text":"A greater flexibility on the use of CellListMap from python can be obtained by defining custom Julia functions. The construction of the systems and of the cell lists can be performed without modification. For example:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [28]: box = jl.Box(np.array([1,1,1]),0.05)\n\nIn [29]: box\n\nOut[29]: \nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]\n  cutoff: 0.05\n  number of computing cells on each dimension: [22, 22, 22]\n  computing cell sizes: [0.05, 0.05, 0.05] (lcell: 1)\n  Total number of cells: 10648","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [30]: x = np.random.random((50_000,3))\n\nIn [31]: x_t = x.transpose()\n\nIn [32]: cl = jl.CellList(x_t,box)\n\nIn [33]: cl\nOut[33]: \nCellList{3, Float64}\n  50000 real particles.\n  7982 cells with real particles.\n  66532 particles in computing box, including images.","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"The function to be mapped, however, has to be defined in Julia, using seval. For example, here we define a function that computes the histogram of the distances within the cutoff. ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [34]: jl.seval(\"\"\"  \n    ...: function histogram(x,y,i,j,d2,hist) \n    ...:     cutoff = 0.05 \n    ...:     dc = sqrt(d2)/cutoff # in [0,1] \n    ...:     ibin = floor(Int,dc*10) + 1 # in [0,10] \n    ...:     hist[ibin] += 1 \n    ...:     return hist \n    ...: end \n    ...: \"\"\")\nOut[34]: histogram (generic function with 1 method)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"We can initialize the output variable (the histogram) using a regular numpy array: ","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [8]: hist = np.zeros(10)","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"and call the map_pairwise function to obtain the histogram of the distances within the cutoff:","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"In [37]: jl.map_pairwise(jl.histogram, hist, box, cl)\nOut[37]: \n10-element PythonCall.PyArray{Float64, 1, true, true, Float64}:\n 153344.0\n      1.151744e6\n      3.066624e6\n      5.787392e6\n      9.220608e6\n      1.3175552e7\n      1.7414912e7\n      2.1817088e7\n      2.6189312e7\n      3.0583808e7","category":"page"},{"location":"python/","page":"From Python","title":"From Python","text":"With this interface, however, it is not possible to pass additional parameters to the mapped function, and thus the additional parameters have to defined inside the called function (as the cutoff in the current example). This is not ideal, for example, for computing accelerations, which depend on the masses of the particles. In this case, currently, either just use Julia from start and closures, or use the neighborlist  function to obtain the list of neighbors to then compute whatever property is desired from the list of pairs, although this is suboptimal in terms of performance.  ","category":"page"},{"location":"reference/#Citation","page":"Reference","title":"Citation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"If you use this software and need to cite it, please use the following reference:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"L. Mart√≠nez, CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff. Computer Physics Communications, 279, 108452, (2022). DOI: 10.1016/j.cpc.2022.108452","category":"page"},{"location":"LowLevel/#Low-level-interface","page":"Low level interface","title":"Low level interface","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Since version 0.7.22 we strongly encourage the use of the PeriodicSystems interface. Yet,  the low level interface is still available. To use it, load the package as usual:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"using CellListMap","category":"page"},{"location":"LowLevel/#Examples","page":"Low level interface","title":"Examples","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full code of the examples described here is available at the examples directory. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Mean difference of coordinates\nHistogram of distances\nGravitational potential\nGravitational force\nNearest neighbor\nImplementing Neighbor lists","category":"page"},{"location":"LowLevel/#Mean-difference-of-coordinates","page":"Low level interface","title":"Mean difference of coordinates","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Computing the mean difference in x position between random particles. The closure is used to remove the indexes and the distance of the particles from the parameters of the input function, as they are not needed in this case.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"using CellListMap\n\n# System properties\nN = 100_000\nsides = [250,250,250]\ncutoff = 10\n\n# Particle positions\nx = [ sides .* rand(3) for i in 1:N ]\n\n# Initialize linked lists and box structures\nbox = Box(sides,cutoff)\ncl = CellList(x,box)\n\n# Function to be evaluated from positions \nf(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])\nnormalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)\n\n# Run calculation (0.0 is the initial value)\navg_dx = normalization * map_pairwise(\n    (x,y,i,j,d2,sum_dx) -> f(x,y,sum_dx), 0.0, box, cl \n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.average_displacement() and is available in the average_displacement.jl file.","category":"page"},{"location":"LowLevel/#Histogram-of-distances","page":"Low level interface","title":"Histogram of distances","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Computing the histogram of the distances between particles (considering the same particles as in the above example). Again, we use a closure to remove the positions and indexes of the particles from the function arguments, because they are not needed. The distance, on the other side, is needed in this example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Function that accumulates the histogram of distances\nfunction build_histogram!(d2,hist)\n    d = sqrt(d2)\n    ibin = floor(Int,d) + 1\n    hist[ibin] += 1\n    return hist\nend;\n\n# Initialize (and preallocate) the histogram\nhist = zeros(Int,10);\n\n# Run calculation\nmap_pairwise!(\n    (x,y,i,j,d2,hist) -> build_histogram!(d2,hist),\n    hist,box,cl\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Note that, since hist is mutable, there is no need to assign the output of map_pairwise! to it. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.distance_histogram() and is available in the distance_histogram.jl file.","category":"page"},{"location":"LowLevel/#Gravitational-potential","page":"Low level interface","title":"Gravitational potential","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In this test we compute the \"gravitational potential\", assigning to each particle a different mass. In this case, the closure is used to pass the masses to the function that computes the potential.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair \nfunction potential(i,j,d2,mass,u)\n    d = sqrt(d2)\n    u = u - 9.8*mass[i]*mass[j]/d\n    return u\nend\n\n# Run pairwise computation\nu = map_pairwise((x,y,i,j,d2,u) -> potential(i,j,d2,mass,u),0.0,box,cl)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.gravitational_potential() and is available in the gravitational_potential.jl file.","category":"page"},{"location":"LowLevel/#Gravitational-force","page":"Low level interface","title":"Gravitational force","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In the following example, we update a force vector of for all particles.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# masses\nconst mass = rand(N)\n\n# Function to be evaluated for each pair: update force vector\nfunction calc_forces!(x,y,i,j,d2,mass,forces)\n    G = 9.8*mass[i]*mass[j]/d2\n    d = sqrt(d2)\n    df = (G/d)*(x - y)\n    forces[i] = forces[i] - df\n    forces[j] = forces[j] + df\n    return forces\nend\n\n# Initialize and preallocate forces\nforces = [ zeros(SVector{3,Float64}) for i in 1:N ]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,forces) -> calc_forces!(x,y,i,j,d2,mass,forces),\n    forces,box,cl\n)\n","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.gravitational_force() and is available in the gravitational_force.jl file.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"note: Note\nThe parallelization works by splitting the forces vector in as many tasks as necessary, and each task will update an independent forces array, which will be reduced at the end. Therefore, there is no need to deal with atomic operations or blocks in the calc_forces! function above for the update of forces, which is implemented as if the code was running serially. The same applies to other examples in this section.","category":"page"},{"location":"LowLevel/#Nearest-neighbor","page":"Low level interface","title":"Nearest neighbor","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Here we compute the indexes of the particles that satisfy the minimum distance between two sets of points, using the linked lists. The distance and the indexes are stored in a tuple, and a reducing method has to be defined for that tuple to run the calculation.  The function does not need the coordinates of the points, only their distance and indexes.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Number of particles, sides and cutoff\nN1=1_500\nN2=1_500_000\nsides = [250,250,250]\ncutoff = 10.\nbox = Box(sides,cutoff)\n\n# Particle positions\nx = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N1 ]\ny = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:N2 ]\n\n# Initialize auxiliary linked lists\ncl = CellList(x,y,box)\n\n# Function that keeps the minimum distance\nf(i,j,d2,mind) = d2 < mind[3] ? (i,j,d2) : mind\n\n# We have to define our own reduce function here\nfunction reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend\n\n# Initial value\nmind = ( 0, 0, +Inf )\n\n# Run pairwise computation\nmind = map_pairwise( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind),\n    mind,box,cl;reduce=reduce_mind\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example above can be run with CellListMap.Examples.nearest_neighbor() and is available in the nearest_neighbor.jl file.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The example CellListMap.Examples.nearest_neighbor_nopbc() of nearest_neighbor_nopbc.jl describes a similar problem but without periodic boundary conditions. Depending on the distribution of points and size it is a faster method than usual ball-tree methods. ","category":"page"},{"location":"LowLevel/#Implementing-Neighbor-lists","page":"Low level interface","title":"Implementing Neighbor lists","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The implementation of the CellLIstMap.neighborlist (see Neighbor lists) is as follows: The empty pairs output array will be split in one vector for each thread, and reduced with a custom reduction function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Function to be evaluated for each pair: push pair\nfunction push_pair!(i,j,d2,pairs)\n    d = sqrt(d2)\n    push!(pairs,(i,j,d))\n    return pairs\nend\n\n# Reduction function\nfunction reduce_pairs(pairs,pairs_threaded)\n    for i in eachindex(pairs_threaded)\n        append!(pairs,pairs_threaded[i])\n    end\n    return pairs\nend\n\n# Initialize output\npairs = Tuple{Int,Int,Float64}[]\n\n# Run pairwise computation\nmap_pairwise!(\n    (x,y,i,j,d2,pairs) -> push_pair!(i,j,d2,pairs),\n    pairs,box,cl,\n    reduce=reduce_pairs\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full example can be run with CellListMap.Examples.neighborlist(), available in the file  neighborlist.jl.","category":"page"},{"location":"LowLevel/#Periodic-boundary-conditions","page":"Low level interface","title":"Periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Orthorhombic periodic boundary conditions\nTriclinic periodic boundary conditions\nWithout periodic boundary conditions","category":"page"},{"location":"LowLevel/#Orthorhombic-periodic-boundary-conditions","page":"Low level interface","title":"Orthorhombic periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Orthorhombic periodic boundary conditions allow some special methods that are faster than those for general cells. To initialize an Orthorhombic cell, just provide the length of the cell on each side, and the cutoff. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([100,70,130],12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [100.0 0.0 0.0; 0.0 70.0 0.0; 0.0 0.0 130.0]\n  cutoff: 12.0\n  number of computing cells on each dimension: [10, 7, 12]\n  computing cell sizes: [12.5, 14.0, 13.0] (lcell: 1)\n  Total number of cells: 840","category":"page"},{"location":"LowLevel/#Triclinic-periodic-boundary-conditions","page":"Low level interface","title":"Triclinic periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Triclinic periodic boundary conditions of any kind can be used. However, the input has some limitations for the moment. The lattice vectors must have strictly positive coordinates, and the smallest distance within the cell cannot be smaller than twice the size of the cutoff. An error will be produced if the cell does not satisfy these conditions. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Let us illustrate building a two-dimensional cell, for easier visualization. A matrix of column-wise lattice vectors is provided in the construction of the box, and that is all. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Here, the lattice vectors are [1,0] and [0.5,1] (and we illustrate with cutoff=0.1): ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([ 1.0  0.5\n                     0  1.0 ], 0.1);\n\njulia> x = 10*rand(SVector{2,Float64},1000);","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"We have created random coordinates for 1000 particles, that are not necessarily wrapped according to the periodic boundary conditions. We can see the coordinates in the minimum image cell with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> using Plots\n\njulia> CellListMap.draw_computing_cell(x,box)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/lattice.png>","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell list is, as always, done with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box)\nCellList{2, Float64}\n  109 cells with real particles.\n  2041 particles in computing box, including images.\n","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Upon construction of the cell lists, the particles are replicated to fill a rectangular box (or orthorhombic box, in three-dimensions), with boundaries that exceed the actual system size. This improves the performance of the pairwise computations by avoiding the necessity of wrapping coordinates on the main loop (this is an implementation detail only). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In summary, to use arbitrary periodic boundary conditions, just initialize the box with the matrix of lattice vectors. In three dimensions, for example, one could use:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> box = Box([ 50.  0. 00. \n                    0. 30. 30.          \n                    0. 00. 50. ],  2.)\n\njulia> x = 100*rand(SVector{3,Float64},10000);\n\njulia> p = [ CellListMap.wrap_to_first(x,box) for x in x ];\n\njulia> using Plots\n\njulia> scatter(Tuple.(p),aspect_ratio=1,framestyle=:box,label=:none)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"to work with an arbitrary 3D lattice, Which in this case looks like:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<img src=https://raw.githubusercontent.com/m3g/CellListMap.jl/main/docs/src/assets/3Dlattice.png>","category":"page"},{"location":"LowLevel/#Without-periodic-boundary-conditions","page":"Low level interface","title":"Without periodic boundary conditions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To avoid the use of periodic boundary conditions it is enough to define an Orthorhombic box with lengths in each direction that are larger than the limits of the coordinates of the particles plus the cutoff. This can be done automatically with the limits function. The box must be constructed with:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [111.99749159163106 0.0 0.0; 0.0 111.99757156637344 0.0; 0.0 0.0 111.99910298572958]\n  cutoff: 12.0\n  number of computing cells on each dimension: [11, 11, 11]\n  computing cell sizes: [12.444165732403452, 12.444174618485938, 12.444344776192175] (lcell: 1)\n  Total number of cells: 1331","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"or, for computing the interaction between two disjoint sets of particles, call the limits function with two arguments:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];\n\njulia> y = [ [120,180,100] .* rand(3) for i in 1:100_000 ];\n\njulia> box = Box(limits(x,y),12)\nBox{OrthorhombicCell, 3, Float64, 9}\n  unit cell matrix: [131.9978650409108 0.0 0.0; 0.0 191.99730748624336 0.0; 0.0 0.0 111.99917288242698]\n  cutoff: 12.0\n  number of computing cells on each dimension: [12, 17, 11]\n  computing cell sizes: [13.19978650409108, 12.799820499082891, 12.444352542491886] (lcell: 1)\n  Total number of cells: 2244","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Note that the unit cell length is, on each direction, the maximum coordinates of all particles plus the cutoff. This will avoid the computation of pairs of periodic images. The algorithms used for computing interactions in Orthorhombic cells will then be used.","category":"page"},{"location":"LowLevel/#Parallelization-splitting-and-reduction","page":"Low level interface","title":"Parallelization splitting and reduction","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"How output is updated thread-safely\nCustom reduction functions\nNumber of batches","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The parallel execution requires the splitting of the computation among tasks. ","category":"page"},{"location":"LowLevel/#How-output-is-updated-thread-safely","page":"Low level interface","title":"How output is updated thread-safely","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To allow general output types, the approach of CellListMap is to copy the output variable the number of times necessary for each parallel task to update an independent output variables, which are reduced at the end. This, of course, requires some additional memory, particularly if the output being updated is formed by arrays. These copies can be preallocated, and custom reduction functions can be defined. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"To control these steps, set manually the output_threaded and reduce optional input parameters of the map_pairwise! function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By default, we define:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"output_threaded = [ deepcopy(output) for i in 1:nbatches(cl) ]","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"where nbatches(cl) is the number of batches into which the computation will be divided. The number of batches is not necessarily equal to the number of threads available (an heuristic is used to optimize performance, as a function of the workload per batch), but can be manually set, as described in the Number of batches section below. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The default reduction function just assumes the additivity of the results obtained by each batch:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"reduce(output::Number,output_threaded) = sum(output_threaded)\nfunction reduce(output::Vector,output_threaded) \n    @. output = output_threaded[1]\n    for i in 2:length(output_threaded)\n         @. output += output_threaded[i] \n    end\n    return output\nend","category":"page"},{"location":"LowLevel/#Custom-reduction-functions","page":"Low level interface","title":"Custom reduction functions","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In some cases, as in the Nearest neighbor example, the output is a tuple and reduction consists in keeping the output from each thread having the minimum value for the distance. Thus, the reduction operation is not a simple sum over the elements of each threaded output. We can, therefore, overwrite the default reduction method, by passing the reduction function as the reduce parameter of map_pairwise!:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"mind = map_pairwise!( \n    (x,y,i,j,d2,mind) -> f(i,j,d2,mind), mind,box,cl;\n    reduce=reduce_mind\n)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"where here the reduce function is set to be the custom function that keeps the tuple associated to the minimum distance obtained between threads:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"function reduce_mind(output,output_threaded)\n    mind = output_threaded[1]\n    for i in 2:length(output_threaded)\n        if output_threaded[i][3] < mind[3]\n            mind = output_threaded[i]\n        end\n    end\n    return mind\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"This function must return the updated output variable, being it mutable or not, to be compatible with the interface.  ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Using the length of the output_threaded vector as the measure of how many copies of the array is available is convenient because it will be insensitive in changes in the number of batches that may be set.","category":"page"},{"location":"LowLevel/#Number-of-batches","page":"Low level interface","title":"Number of batches","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Every calculation with cell lists has two steps: the construction of the lists, and the mapping of the computation among the pairs of particles that satisfy the cutoff criterion. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell list is harder to parallelize, because assigning each particle to a cell is fast, such that the cost of merging a set of lists generated in parallel can be as costly as building the lists themselves. Therefore, it is frequent that it is not worthwhile (actually it is detrimental for performance) to split the construction of the cell lists in too many threads. This is particularly relevant for smaller systems, for which the cost of constructing the lists can be comparable to the cost of actually computing the mapped function. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"At the same time, the homogeneity of the computation of the mapped function may be fast or not, homogeneous or not. These characteristics affect the optimal workload splitting strategy. For very large systems, or systems for which the function to be computed is not homogeneous in time, it may be interesting to split the workload in many tasks as possible, such that slow tasks do not dominate the final computational time.   ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Both the above considerations can be used to tunning the nbatches parameter of the cell list. This parameter is initialized from a tuple of integers, defining the number of batches that will be used for constructing the cell lists and for the mapping of the computations. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By default, the number of batches for the computation of the cell lists is smaller than nthreads() if the number of particles per cell is small. The default value by the internal function CellListMap._nbatches_build_cell_lists(cl::CellList). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The values assumed for each number of batches can bee seen by printing the nbatches parameter of the cell lists:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> Threads.nthreads()\n64\n\njulia> x, box = CellListMap.xatomic(10^4) # random set with atomic density of water\n\njulia> cl = CellList(x,box);\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 8 \n  Number of batches for function mapping: 32 ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The construction of the cell lists is performed by creating copies of the data, and currently does not scale very well. Thus, no more than 8 batches are used by default, to avoid delays associated to data copying and gargabe collection. The number of batches of the mapping function uses an heuristic which currently limits somewhat the number of batches for small systems, when the overhead of spawning tasks is greater than the computation.  Using more batches than threads for the function mapping is effective most times in avoiding uneven workload, but it may be a problem if the output to be reduced is too large, as the threaded version of the output contains nbatches copies of the output. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Using less batches than the number of threads also allows the efficient use of nested multi-threading, as the computations will only use the number of threads required, leaving the other threads available for other tasks.","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The number of batches is set on the construction of the cell list, using the nbatches keyword parameter. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(1,4))\nCellList{3, Float64}\n  1000000 real particles.\n  1000 cells with real particles.\n  1727449 particles in computing box, including images.\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 1\n  Number of batches for function mapping: 4","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"fine tunning of the performance for a specific problem can be obtained by adjusting this parameter. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"If the number of batches is set as zero for any of the two options, the default value is retained. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(0,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 8 \n  Number of batches for function mapping: 4\n\njulia> cl = CellList(x,box,nbatches=(4,0));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 4\n  Number of batches for function mapping: 64","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The number of batches can also be retrieved from the cell list using the nbatches function:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> cl = CellList(x,box,nbatches=(2,4));\n\njulia> cl.nbatches\nNumberOfBatches\n  Number of batches for cell list construction: 2\n  Number of batches for function mapping: 4\n\njulia> nbatches(cl) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:map) # returns cl.nbatches.map_computation\n4\n\njulia> nbatches(cl,:build) # returns cl.nbatches.build_cell_lists\n2","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The call nbatches(cl) is important for defining the number of copies of preallocated threaded output variables, as explained in the previous section.","category":"page"},{"location":"LowLevel/#Performance-tunning-and-additional-options","page":"Low level interface","title":"Performance tunning and additional options","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Preallocating the cell lists and cell list auxiliary arrays\nPreallocating threaded output auxiliary arrays\nOptimizing the cell grid","category":"page"},{"location":"LowLevel/#Preallocating-the-cell-lists-and-cell-list-auxiliary-arrays","page":"Low level interface","title":"Preallocating the cell lists and cell list auxiliary arrays","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The arrays containing the cell lists can be initialized only once, and then updated. This is useful for iterative runs. Note that, since the list size depends on the box size and cutoff, if the box properties changes some arrays might be increased (never shrink) on this update. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"# Initialize cell lists with initial coordinates\ncl = CellList(x,box)\n# Allocate auxiliary arrays for threaded cell list construction\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,box,cl,aux) \n    map_pairwise!(...)\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The procedure is identical if using two sets of coordinates, in which case, one would do:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"cl = CellList(x,y,box)\naux = CellListMap.AuxThreaded(cl)\nfor i in 1:nsteps\n    x = ... # new coordinates\n    box = Box(sides,cutoff) # perhaps the box has changed\n    cl = UpdateCellList!(x,y,box,cl,aux)\n    map_pairwise(...)\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"By passing the aux auxiliary structure, the UpdateCellList! functions will only allocate some minor variables associated to the launching of multiple threads and, possibly, to the expansion of the cell lists if the box or the number of particles became greater. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"warning: Warning\nIf the number of batches of threading is changed, the structure of auxiliary arrays must be reinitialized. Otherwise, incorrect results can be obtained.","category":"page"},{"location":"LowLevel/#Preallocating-threaded-output-auxiliary-arrays","page":"Low level interface","title":"Preallocating threaded output auxiliary arrays","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"On parallel runs, note that output_threaded is, by default, initialized on the call to map_pairwise!. Thus, if the calculation must be run multiple times (for example, for several steps of a trajectory), it is probably a good idea to preallocate the threaded output, particularly if it is a large array. For example, the arrays of forces should be created only once, and reset to zero after each use:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"forces = zeros(SVector{3,Float64},N)\nforces_threaded = [ deepcopy(forces) for i in 1:nbatches(cl) ]\nfor i in 1:nsteps\n    map_pairwise!(f, forces, box, cl, output_threaded=forces_threaded)\n    # work with the final forces vector\n    ...\n    # Reset forces_threaded\n    for i in 1:nbatches(cl)\n        @. forces_threaded[i] = zero(SVector{3,Float64}) \n    end\nend","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"In this case, the forces vector will be updated by the default reduction method. nbatches(cl) is the number of batches of the parallel calculation, which is defined on the construction of the cell list (see the Parallelization section).","category":"page"},{"location":"LowLevel/#Optimizing-the-cell-grid","page":"Low level interface","title":"Optimizing the cell grid","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The partition of the space into cells is dependent on a parameter lcell which can be passed to Box. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"box = Box(x,box,lcell=2)\ncl = CellList(x,box)\nmap_pairwise!(...)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"This parameter determines how fine is the mesh of cells. There is a trade-off between the number of cells and the number of particles per cell. For low-density systems, greater meshes are better, because each cell will have only a few particles and the computations loop over a smaller number of cells. For dense systems, it is better to run over more cells with less particles per cell. It is a good idea to test different values of lcell to check which is the optimal choice for your system. Usually the best value is lcell=1, because in CellListMap implements a method to avoid spurious computations of distances on top of the cell lists, but for very dense systems, or for very large cutoffs (meaning, for situations in which the number of particles per cell may be very large), a greater lcell may provide a better performance. It is unlikely that lcell > 3 is useful in any practical situation. For molecular systems with normal densities lcell=1 is likely the optimal choice. The performance can be tested using the progress meter, as explained below.  ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"As a rough guide, lcell > 1 is only worthwhile if the number of particles per cell is greater than  ~200-400.  ","category":"page"},{"location":"LowLevel/#Output-progress","page":"Low level interface","title":"Output progress","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For long-running computations, the user might want to see the progress. A progress meter can be turned on with the show_progress option. For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"map_pairwise!(f,output,box,cl,show_progress=true)","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"whill print something like:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Progress:  43%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                    | ETA: 0:18:25","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"Thus, besides being useful for following the progress of a long run, it is useful to test different values of lcell to tune the performance of the code, by looking at the estimated time to finish (ETA) and killing the execution after a sample run. The default and recommended option for production runs is to use show_progress=false, because tracking the progress introduces a small overhead into the computation. ","category":"page"},{"location":"LowLevel/#Some-benchmarks","page":"Low level interface","title":"Some benchmarks","text":"","category":"section"},{"location":"LowLevel/#Computing-a-histogram-of-pairwise-velocities","page":"Low level interface","title":"Computing a histogram of pairwise velocities","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The goal here is to provide a good implementation of cell lists. We compare it with the implementation of the nice cython/python halotools package, in the computation of an histogram of mean pairwise velocities. ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"<center>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cd_v0.5.3.png>\n<br>\n<img src=https://raw.githubusercontent.com/lmiq/PairVelocities/main/data/cv_v0.5.3.png>\n</center>","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"The full test is available at this repository. And we kindly thank Carolina Cuesta for providing the example. These benchmarks were run on an Intel i7 8th gen laptop, with 4 cores (8 threads). ","category":"page"},{"location":"LowLevel/#Additional-options","page":"Low level interface","title":"Additional options","text":"","category":"section"},{"location":"LowLevel/#Input-coordinates-as-matrices","page":"Low level interface","title":"Input coordinates as matrices","text":"","category":"section"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For compatibility with other software, the input coordinates can be provided as matrices. The matrices must have dimensions (2,N) or (3,N), where N is the number of particles (because Julia is column-major, thus this has the same memory layout of an array of length N of static vectors). ","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"For example:","category":"page"},{"location":"LowLevel/","page":"Low level interface","title":"Low level interface","text":"julia> x = rand(3,100);\n\njulia> box = Box([1,1,1],0.1);\n\njulia> cl = CellList(x,box)\nCellList{3, Float64}\n  100 real particles.\n  99 cells with real particles.\n  162 particles in computing box, including images.\n\njulia> map_pairwise!((x,y,i,j,d2,n) -> n += 1, 0, box, cl) # count neighbors\n23","category":"page"},{"location":"#CellListMap.jl","page":"Overview","title":"CellListMap.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package implements an efficient cell list scheme for the computation of interactions, or any other property dependent on the distances between pairs of two- or three-dimensional particles, within a cutoff. It maps a generic function to be computed pairwise, using periodic boundary conditions of any type. Parallel and serial implementations can be used. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It allows the fast computation of any quantity from the pairs that are within the desired cutoff, for example an average distance or an histogram of distances, forces, potentials, minimum distances, etc., as the examples illustrate. This is done by passing the function to be evaluated as a parameter of the map_pairwise! function. ","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> import Pkg\n\njulia> Pkg.add(\"CellListMap\")","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"#High-level-interface-for-periodic-system","page":"Overview","title":"High level interface for periodic system","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Since version 0.7.22, a new simpler, higher level interface was introduced, that will facilitate the use of CellListMap without any loss in performance. The new interface is flexible enough for the majority of applications. It may become the default interface in the future. See the PeriodicSystems interface menu for details. ","category":"page"},{"location":"#Lower-level-interface","page":"Overview","title":"Lower level interface","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The main function is map_parwise! (or map_pairwise): ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If the analysis is performed on the pairs of a single vector x (n*(n-1)/2 pairs), the function can be called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellList)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"while if two distinct sets of points are provided (n*m pairs), it is called with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise!(f::Function,output,box::Box,cl::CellListPair)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where the cl variable of type CellList or CellListPair contains the cell lists built from the coordinates of the system, and box contains the system box properties.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"These functions will run over every pair of particles which are closer than box.cutoff and compute the (squared) Euclidean distance between the particles, considering the periodic boundary conditions given in the Box structure. If the distance is smaller than the cutoff, a user defined function f of the coordinates of the two particles will be computed. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The function f receives six arguments as input: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"f(x,y,i,j,d2,output)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Which are the coordinates of one particle, the coordinates of the second particle, the index of the first particle, the index of the second particle, the squared distance between them, and the output variable. It has also to return the same output variable. Thus, f may or not mutate output, but in either case it must return it.  The squared distance d2 is computed   internally for comparison with the cutoff, and is passed to the f because many times it is used for the desired computation. Thus, the function f that is passed to map_pairwise! must be always of the form:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"function f(x,y,i,j,d2,output)\n    # update output\n    return output\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and the user can define more or less parameters or additional data required to compute the function using closures, as shown in the examples.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Parallel calculations are the default if more than one thread is available. Use parallel=false as an optional argument to map_pairwise! to run the serial version instead.","category":"page"},{"location":"#Mutable-and-immutable-outputs","page":"Overview","title":"Mutable and immutable outputs","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"map_pairwise! and map_pairwise (with the bang, or not) are aliases of the same function, which always returns the result value. It is a convention in Julia that functions ending with the ! mutate the arguments, while those without do not. Here, this behavior is dependent on the type of input. If the output variable is immutable, its value won't be mutated, and the assignment of the result to the output value depends on explicit assignment. In these cases, it is customary to use the map_pairwise (without !) function name:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"output = map_pairwise(function, output0, box, cl)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where output0 represents the initial value of the immutable output. When, on the contrary, the output is a mutable variable (an array, for example), the map_pairwise! version is preferred for code clarity, and the reassignment is not needed (nor recommendable): ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"output = zeros(10) # example of mutable output\nmap_pairwise!(function, output, box, cl)","category":"page"}]
}
