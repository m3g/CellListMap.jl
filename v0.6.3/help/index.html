<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Help entries · CellListMap.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CellListMap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CellListMap.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../pbc/">Periodic conditions</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../options/">Options</a></li><li class="is-active"><a class="tocitem" href>Help entries</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Help entries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Help entries</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/m3g/CellListMap.jl/blob/master/docs/src/help.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Help-entries"><a class="docs-heading-anchor" href="#Help-entries">Help entries</a><a id="Help-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Help-entries" title="Permalink"></a></h1><p>These entries can be viewed at the <code>Julia</code> REPL <code>Julia</code> using </p><pre><code class="language-julia-repl hljs">julia&gt; ? 
help?&gt; function_name</code></pre><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded" href="#CellListMap.AuxThreaded"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AuxThreaded{N, T}</code></pre><pre><code class="language-julia hljs">struct AuxThreaded{N, T}</code></pre><p>Auxiliary structure to carry threaded lists and ranges of particles to  be considered by each thread on parallel construction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded-Union{Tuple{CellListMap.CellListPair{V, N, T}}, Tuple{T}, Tuple{N}, Tuple{V}} where {V, N, T}" href="#CellListMap.AuxThreaded-Union{Tuple{CellListMap.CellListPair{V, N, T}}, Tuple{T}, Tuple{N}, Tuple{V}} where {V, N, T}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellListPair{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type for lists of disjoint particle sets,  to be passed to <code>UpdateCellList!</code> for in-place update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L195-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.AuxThreaded-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.AuxThreaded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AuxThreaded(cl::CellList{N,T}) where {N,T}</code></pre><p>Constructor for the <code>AuxThreaded</code> type, to be passed to <code>UpdateCellList!</code> for in-place  update of cell lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for _ in 1:100_000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; cl = UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  31190 cells with real particles.
  1134378 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L160-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box" href="#CellListMap.Box"><code>CellListMap.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Box{UnitCellType, N, T, M}</code></pre><ul><li><p><code>unit_cell::CellListMap.UnitCell</code></p></li><li><p><code>lcell::Int64</code></p></li><li><p><code>nc::StaticArrays.SVector{N, Int64} where N</code></p></li><li><p><code>cutoff::Any</code></p></li><li><p><code>cutoff_sq::Any</code></p></li><li><p><code>ranges::StaticArrays.SVector{N, UnitRange{Int64}} where N</code></p></li><li><p><code>cell_size::StaticArrays.SVector{N, T} where {N, T}</code></p></li><li><p><code>unit_cell_max::StaticArrays.SVector{N, T} where {N, T}</code></p></li></ul><p>Structure that contains some data required to compute the linked cells. To be initialized with the box size and cutoff. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CellListMap

julia&gt; sides = [250,250,250];

julia&gt; cutoff = 10;

julia&gt; box = Box(sides,cutoff)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [250.0 0.0 0.0; 0.0 250.0 0.0; 0.0 0.0 250.0]
  cutoff: 10.0
  number of computing cells on each dimension: [27, 27, 27]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 19683
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; box = Box([ 10  0  0 
                    0 10  5
                    0  0 10 ], 1)
Box{TriclinicCell, 3, Float64, 9}
unit cell matrix: [10.0 0.0 0.0; 0.0 10.0 5.0; 0.0 0.0 10.0]
cutoff: 1.0
number of computing cells on each dimension: [12, 17, 12]
computing cell sizes: [1.0, 1.0, 1.0] (lcell: 1)
Total number of cells: 2448
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/Box.jl#L28-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Tuple{CellListMap.Limits, Any}" href="#CellListMap.Box-Tuple{CellListMap.Limits, Any}"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
    limits::Limits,
    cutoff;
    T::DataType=Float64,
    lcell::Int=1
)</code></pre><p>This constructor receives the output of <code>limits(x)</code> or <code>limits(x,y)</code> where <code>x</code> and <code>y</code> are the coordinates of the particles involved, and constructs a <code>Box</code> with size larger than the maximum coordinates ranges of all particles plus the cutoff. This is used to  emulate pairwise interactions in non-periodic boxes. The output box is always an <code>Orthorhombic</code> cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ [100,100,100] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x),10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [109.99633932875878 0.0 0.0; 0.0 109.99780283179763 0.0; 0.0 0.0 109.99587254766517]
  cutoff: 10.0
  number of computing cells on each dimension: [12, 12, 12]
  computing cell sizes: [10.999633932875877, 10.999780283179764, 10.999587254766517] (lcell: 1)
  Total number of cells: 1728

julia&gt; y = [ [150,150,50] .* rand(3) for i in 1:100_000 ];

julia&gt; box = Box(limits(x,y),10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [159.99787690924168 0.0 0.0; 0.0 159.98878289444897 0.0; 0.0 0.0 109.99587254766517]
  cutoff: 10.0
  number of computing cells on each dimension: [18, 17, 12]
  computing cell sizes: [10.666525127282778, 10.665918859629931, 10.999587254766517] (lcell: 1)
  Total number of cells: 3672
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/Box.jl#L249-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{T}, Tuple{AbstractMatrix{T} where T, Any, Type{T}, Int64, Type{UnitCellType}}} where {T, UnitCellType}" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{T}, Tuple{AbstractMatrix{T} where T, Any, Type{T}, Int64, Type{UnitCellType}}} where {T, UnitCellType}"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
  unit_cell_matrix::AbstractMatrix, 
  cutoff, 
  T::DataType, 
  lcell::Int=1,
  UnitCellType=TriclinicCell
)</code></pre><p>Construct box structure given the cell matrix of lattice vectors. This  constructor will always return a <code>TriclinicCell</code> box type, unless the <code>UnitCellType</code> parameter is set manually to <code>OrthorhombicCell</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell = [ 100   50    0 
                       0  120    0
                       0    0  130 ];

julia&gt; box = Box(unit_cell,10)
Box{TriclinicCell, 3, Float64, 9}
  unit cell matrix: [100.0 50.0 0.0; 0.0 120.0 0.0; 0.0 0.0 130.0]
  cutoff: 10.0
  number of computing cells on each dimension: [17, 14, 15]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 3570
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/Box.jl#L81-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{T}, Tuple{AbstractVector{T} where T, Any, Type{T}, Int64, Type{UnitCellType}}} where {T, UnitCellType}" href="#CellListMap.Box-Union{Tuple{UnitCellType}, Tuple{T}, Tuple{AbstractVector{T} where T, Any, Type{T}, Int64, Type{UnitCellType}}} where {T, UnitCellType}"><code>CellListMap.Box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Box(
  sides::AbstractVector, 
  cutoff, 
  T::DataType, 
  lcell::Int=1,
  UnitCellType=OrthorhombicCell
)</code></pre><p>For orthorhombic unit cells, <code>Box</code> can be initialized with a vector of the  length of each side. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([120,150,100],10)
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [120.0 0.0 0.0; 0.0 150.0 0.0; 0.0 0.0 100.0]
  cutoff: 10.0
  number of computing cells on each dimension: [14, 17, 12]
  computing cell sizes: [10.0, 10.0, 10.0] (lcell: 1)
  Total number of cells: 2856
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/Box.jl#L184-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Cell" href="#CellListMap.Cell"><code>CellListMap.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Cell{N, T}</code></pre><ul><li><p><code>linear_index::Int64</code></p></li><li><p><code>cartesian_index::CartesianIndex</code></p></li><li><p><code>center::StaticArrays.SVector{N, T} where {N, T}</code></p></li><li><p><code>contains_real::Bool</code></p></li><li><p><code>n_particles::Int64</code></p></li><li><p><code>particles::Array{CellListMap.ParticleWithIndex{N, T}, 1} where {N, T}</code></p></li></ul><p>This structure contains the cell linear index and the information  about if this cell is in the border of the box (such that its  neighbouring cells need to be wrapped) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L38-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList" href="#CellListMap.CellList"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellList{N, T}</code></pre><ul><li><p><code>n_real_particles::Int64</code></p><p>Number of real particles.</p></li><li><p><code>number_of_cells::Int64</code></p><p>Number of cells.</p></li><li><p><code>n_particles::Int64</code></p><p><em>mutable</em> number of particles in the computing box.</p></li><li><p><code>n_cells_with_real_particles::Int64</code></p><p><em>mutable</em> number of cells with real particles.</p></li><li><p><code>n_cells_with_particles::Int64</code></p><p><em>mutable</em> number of cells with particles, real or images.</p></li><li><p><code>cell_indices::Vector{Int64}</code></p><p>Auxiliary array that contains the indexes in list of the cells with particles, real or images.</p></li><li><p><code>cell_indices_real::Vector{Int64}</code></p><p>Auxiliary array that contains the indexes in the cells with real particles.</p></li><li><p><code>cells::Array{CellListMap.Cell{N, T}, 1} where {N, T}</code></p><p>Vector containing cell lists of cells with particles.</p></li><li><p><code>projected_particles::Array{Array{CellListMap.ProjectedParticle{N, T}, 1}, 1} where {N, T}</code></p><p>Auxiliar array to store projected particles.</p></li></ul><p>Structure that contains the cell lists information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function CellList(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    autoswap=true
) where {UnitCellType,N,T} </code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L442-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function CellList(
    x::AbstractMatrix,
    box::Box{UnitCellType,N,T};
    parallel::Bool=true
) where {UnitCellType,N,T} </code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L319-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true,
    autoswap::Bool=true
) where {UnitCellType,N,T} </code></pre><p>Function that will initialize a <code>CellListPair</code> structure from scracth, given two vectors of particle coordinates and a <code>Box</code>, which contain the size of the system, cutoff, etc. By default, the cell list will be constructed for smallest vector, but this is not always the optimal choice. Using <code>autoswap=false</code> the cell list is constructed for the second (<code>y</code>)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   10000 particles in the reference vector.
   961 cells with real particles of target vector.

julia&gt; cl = CellList(x,y,box,autoswap=false)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   7389 cells with real particles of target vector.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L383-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.CellList-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.CellList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellList(
    x::AbstractVector{AbstractVector},
    box::Box{UnitCellType,N,T};
    parallel::Bool=true
) where {UnitCellType,N,T} </code></pre><p>Function that will initialize a <code>CellList</code> structure from scracth, given a vector or particle coordinates (a vector of vectors, typically of static vectors)  and a <code>Box</code>, which contain the size ofthe system, cutoff, etc.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box)
CellList{3, Float64}
  100000 real particles.
  15600 cells with real particles.
  126276 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L277-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.CellListPair" href="#CellListMap.CellListPair"><code>CellListMap.CellListPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CellListPair{V, N, T}</code></pre><ul><li><p><code>ref::Any</code></p></li><li><p><code>target::CellList</code></p></li><li><p><code>swap::Bool</code></p></li></ul><p>Structure that will cointain the cell lists of two independent sets of particles for cross-computation of interactions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.Limits" href="#CellListMap.Limits"><code>CellListMap.Limits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Limits{T&lt;:(AbstractVector{T} where T)}</code></pre><ul><li><code>limits::AbstractVector{T} where T</code></li></ul><p>Structure that contains the maximum lengths on each direction, to dispatch on the construction of boxes without periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/Box.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ParticleWithIndex" href="#CellListMap.ParticleWithIndex"><code>CellListMap.ParticleWithIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParticleWithIndex{N, T}</code></pre><ul><li><p><code>index::Int32</code></p></li><li><p><code>real::Bool</code></p></li><li><p><code>coordinates::StaticArrays.SVector{N, T} where {N, T}</code></p></li></ul><p>Copies particle coordinates and associated index, to build contiguous particle lists in memory when building the cell lists. This strategy duplicates the particle coordinates data, but is probably worth the effort. The index is a 32bit integer such  that the complete struct has 32bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ProjectedParticle" href="#CellListMap.ProjectedParticle"><code>CellListMap.ProjectedParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProjectedParticle{N, T}</code></pre><ul><li><p><code>index::Int32</code></p></li><li><p><code>xproj::Float32</code></p></li><li><p><code>coordinates::StaticArrays.SVector{N, T} where {N, T}</code></p></li></ul><p>Auxiliary structure to contain projected particles. Types of  scalars are chosen such that with a <code>SVector{3,Float64}</code> the complete struct has 32bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T},
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L669-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractMatrix{T} where T, Box, CellList{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    box::Box,
    cl::CellList{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Reinterprets the matrix <code>x</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrix must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L520-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(AbstractVector{T} where T), Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:(AbstractVector{T} where T), Box, CellList{N, T}, CellListMap.AuxThreaded{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl::CellList{N,T},
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {N,T}</code></pre><p>Function that updates the cell list <code>cl</code> new coordinates <code>x</code> and possibly a new box <code>box</code>, and receives a preallocated <code>aux</code> structure of auxiliary vectors for threaded cell list construction. Given a preallocated <code>aux</code> vector, allocations in this function should be minimal, only associated with the spawning threads, or to expansion of the cell lists if the number of cells or number of particles  increased. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; cl = CellList(x,box);

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:100000 ];

julia&gt; UpdateCellList!(x,box,cl,aux)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux)
  16.384 ms (41 allocations: 3.88 KiB)
CellList{3, Float64}
  100000 real particles.
  15599 cells with real particles.
  125699 particles in computing box, including images.

julia&gt; @btime UpdateCellList!($x,$box,$cl,$aux,parallel=false)
  20.882 ms (0 allocations: 0 bytes)
CellList{3, Float64}
  100000 real particles.
  15603 cells with real particles.
  125896 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L547-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(AbstractVector{T} where T), Box, CellList{N, T}}} where {N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:(AbstractVector{T} where T), Box, CellList{N, T}}} where {N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    box::Box,
    cl:CellList{N,T},
    parallel=true
) where {N,T}</code></pre><p>Function that will update a previously allocated <code>CellList</code> structure, given new  updated particle positions. This function will allocate new threaded auxiliary arrays in parallel calculations. To preallocate these auxiliary arrays, use the <code>UpdateCellList!(x,box,cl,aux)</code> method instead. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; box = Box([260,260,260],10);

julia&gt; x = [ 260*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; cl = UpdateCellList!(x,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L473-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N,T},
    cl_pair::CellListPair,
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L1123-L1140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractMatrix,
    y::AbstractMatrix,
    box::Box{UnitCellType,N,T},
    cl_pair::CellListPair;
    parallel::Bool=true
) where {UnitCellType,N,T}</code></pre><p>Reinterprets the matrices <code>x</code> and <code>y</code> as vectors of static vectors and calls the equivalent function with the reinterprted input. The first dimension of the  matrices must be the dimension of the points (<code>2</code> or <code>3</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L1007-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair, CellListMap.AuxThreaded{N, T}}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function UpdateCellList!(
    x::AbstractVector{&lt;:AbstractVector},
    y::AbstractVector{&lt;:AbstractVector},
    box::Box{UnitCellType,N,T},
    cl_pair::CellListPair,
    aux::AuxThreaded{N,T};
    parallel::Bool=true
) where {UnitCellType,N,T}</code></pre><p>This function will update the <code>cl_pair</code> structure that contains the cell lists for disjoint sets of particles. It receives the preallocated <code>aux</code> structure to avoid reallocating auxiliary arrays necessary for the threaded construct of the lists. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7381 cells with real particles of target vector.

julia&gt; aux = CellListMap.AuxThreaded(cl)
CellListMap.AuxThreaded{3, Float64}
 Auxiliary arrays for nthreads = 8

julia&gt; x = [ 250*rand(3) for i in 1:50_000 ];

julia&gt; y = [ 250*rand(3) for i in 1:10_000 ];

julia&gt; cl = UpdateCellList!(x,y,box,cl,aux)
CellList{3, Float64}
  10000 real particles.
  7358 cells with real particles.
  12591 particles in computing box, including images.
</code></pre><p>To illustrate the expected ammount of allocations, which are a consequence of thread spawning only:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux)
  715.661 μs (41 allocations: 3.88 KiB)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   50000 particles in the reference vector.
   7414 cells with real particles of target vector.
   
julia&gt; @btime UpdateCellList!($x,$y,$box,$cl,$aux,parallel=false)
   13.042 ms (0 allocations: 0 bytes)
 CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
    50000 particles in the reference vector.
    15031 cells with real particles of target vector.
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L1038-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair}} where {UnitCellType, N, T}" href="#CellListMap.UpdateCellList!-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{AbstractVector{var&quot;#s20&quot;} where var&quot;#s20&quot;&lt;:(AbstractVector{T} where T), AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:(AbstractVector{T} where T), Box{UnitCellType, N, T, M} where M, CellListMap.CellListPair}} where {UnitCellType, N, T}"><code>CellListMap.UpdateCellList!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UpdateCellList!(
  x::AbstractVector{&lt;:AbstractVector},
  y::AbstractVector{&lt;:AbstractVector},
  box::Box{UnitCellType,N,T},
  cl:CellListPair,
  parallel=true
) where {UnitCellType,N,T}</code></pre><p>Function that will update a previously allocated <code>CellListPair</code> structure, given  new updated particle positions, for example. This method will allocate new  <code>aux</code> threaded auxiliary arrays. For a non-allocating version, see the  <code>UpdateCellList!(x,y,box,cl,aux)</code> method.</p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ 250*rand(SVector{3,Float64}) for i in 1:1000 ];

julia&gt; y = [ 250*rand(SVector{3,Float64}) for i in 1:10000 ];

julia&gt; cl = CellList(x,y,box);

julia&gt; cl = UpdateCellList!(x,y,box,cl); # update lists
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L962-L992">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particle_to_celllist!-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T}, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particle_to_celllist!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particle_to_celllist!(
    ip,
    x::SVector{N,T},
    box,
    cl::CellList{N,T};
    real_particle::Bool=true
) where {N,T}</code></pre><p>Adds one particle to the cell lists, updating all necessary arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L869-L883">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}" href="#CellListMap.add_particles!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, CellList{N, T}}} where {N, T}"><code>CellListMap.add_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_particles!(x,box,ishift,cl::CellList{N,T}) where {N,T}</code></pre><p>Add all particles in vector <code>x</code> to the cell list <code>cl</code>. <code>ishift</code> is the shift in particle index, meaning that particle <code>i</code> of vector <code>x</code> corresponds to the particle with original index <code>i+ishift</code>. The shift is used to construct cell lists from fractions of the original set of particles in parallel list construction.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L735-L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.append_particles!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.append_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append_particles!(cell1::Cell,cell2::Cell)</code></pre><p>Add the particles of <code>cell2</code> to <code>cell1</code>, updating the cell data and, if necessary, resizing (increasing) the <code>particles</code> array of <code>cell1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L788-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_cartesian_indices-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_cartesian_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_cartesian_indices(nc::SVector{N,Int}, i1D) where {N}</code></pre><p>Given the linear index of the cell in the cell list, returns the cartesian indices  of the cell (for arbitrary dimension N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L267-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.cell_center-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{CartesianIndex{N}, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.cell_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_center(c::CartesianIndex{N},box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}</code></pre><p>Computes the geometric center of a computing cell, to be used in the projection of points. Returns a <code>SVector{N,T}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L254-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N" href="#CellListMap.cell_linear_index-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, Int64}, Any}} where N"><code>CellListMap.cell_linear_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_linear_index(nc::SVector{N,Int}, indices) where N</code></pre><p>Returns the index of the cell, in the 1D representation, from its cartesian coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L280-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.check_unit_cell-Tuple{Box}" href="#CellListMap.check_unit_cell-Tuple{Box}"><code>CellListMap.check_unit_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_unit_cell(box::Box)</code></pre><p>Checks if the unit cell satisfies the conditions for using the minimum-image convention. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L334-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}" href="#CellListMap.copydata!-Tuple{CellListMap.Cell, CellListMap.Cell}"><code>CellListMap.copydata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copydata!(cell1::Cell,cell2::Cell)</code></pre><p>Copies the data from <code>cell2</code> to <code>cell1</code>, meaning that particles are copied element-wise from <code>cell2</code> to <code>cell1</code>, with the <code>particles</code> array of <code>cell1</code> being resized (increased) if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L760-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}" href="#CellListMap.dot-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}}} where {T1, T2}"><code>CellListMap.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(x::AbstractVector{T1},y::AbstractVector{T2}) where {T1,T2}</code></pre><p><code>LinearAlgebra.dot</code> is slower than this for standard arrays (likely more accurate, but that is not relevant here).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/linearalgebra.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2, T, M} where {T, M}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 2, T, M} where {T, M}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,2}) where UnitCellType</code></pre><pre><code class="nohighlight hljs">draw_computing_cell(cl::CellList,box::Box{UnitCellType,2},x) where UnitCellType</code></pre><p>This function creates a plot of the computing cell, in two dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/testing.jl#L225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3, T, M} where {T, M}}} where UnitCellType" href="#CellListMap.draw_computing_cell-Union{Tuple{UnitCellType}, Tuple{Any, Box{UnitCellType, 3, T, M} where {T, M}}} where UnitCellType"><code>CellListMap.draw_computing_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_computing_cell(x,box::Box{UnitCellType,3}) where UnitCellType</code></pre><p>This function creates a plot of the computing cell, in three dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/testing.jl#L263-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T" href="#CellListMap.fix_upper_boundary-Union{Tuple{T}, Tuple{T, Any}} where T"><code>CellListMap.fix_upper_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_upper_boundary(x::T,side) where T</code></pre><p>Move <code>x</code> to <code>x -side</code> if <code>x == side</code>, because we use the convention that the boundary belongs to the next cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.init_aux_threaded!-Tuple{CellListMap.AuxThreaded, CellList}" href="#CellListMap.init_aux_threaded!-Tuple{CellListMap.AuxThreaded, CellList}"><code>CellListMap.init_aux_threaded!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_aux_threaded!(aux::AuxThreaded,cl::CellList)</code></pre><p>Given an <code>AuxThreaded</code> object initialized with zero-length arrays, push <code>ntrheads</code> copies of <code>cl</code> into <code>aux.lists</code> and resize <code>aux.idxs</code> to the number of threads.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.limits-Tuple{AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:(AbstractVector{T} where T)}" href="#CellListMap.limits-Tuple{AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:(AbstractVector{T} where T)}"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x::AbstractVector{&lt;:AbstractVector})</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code>,  to be used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L411-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector{var&quot;#s47&quot;} where var&quot;#s47&quot;&lt;:(AbstractVector{T} where T))" href="#CellListMap.limits-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractVector{var&quot;#s47&quot;} where var&quot;#s47&quot;&lt;:(AbstractVector{T} where T))"><code>CellListMap.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">limits(x::T,y::T) where T&lt;:AbstractVector{&lt;:AbstractVector})</code></pre><p>Returns the lengths of a orthorhombic box that encompasses all the particles defined in <code>x</code> and <code>y</code>, to used to set a box without effective periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L434-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_naive!-Tuple{Any, Any, Any, Box}" href="#CellListMap.map_naive!-Tuple{Any, Any, Any, Box}"><code>CellListMap.map_naive!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_naive!(f,output,x,box)</code></pre><p>Function that uses the naive pairwise mapping algorithm, for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/testing.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}" href="#CellListMap.map_pairwise!-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, Any, Box, CellListMap.CellListPair}} where {F1, F2}"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(f::Function,output,box::Box,cl::CellListPair)</code></pre><p>The same but to evaluate some function between pairs of the particles of the vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellListMap.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F" href="#CellListMap.map_pairwise!-Union{Tuple{F}, Tuple{F, Any, Box, Any}} where F"><code>CellListMap.map_pairwise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_pairwise!(
  f::Function,
  output,
  box::Box,
  cl::CellList
  ;parallel::Bool=true,
  show_progress::Bool=false
)</code></pre><p>This function will run over every pair of particles which are closer than  <code>box.cutoff</code> and compute the Euclidean distance between the particles,  considering the periodic boundary conditions given in the <code>Box</code> structure.  If the distance is smaller than the cutoff, a function <code>f</code> of the  coordinates of the two particles will be computed. </p><p>The function <code>f</code> receives six arguments as input: </p><pre><code class="nohighlight hljs">f(x,y,i,j,d2,output)</code></pre><p>Which are the coordinates of one particle, the coordinates of the  second particle, the index of the first particle, the index of the second  particle, the squared distance between them, and the <code>output</code> variable.  It has also to return the same <code>output</code> variable. Thus, <code>f</code> may or not  mutate <code>output</code>, but in either case it must return it. With that, it is  possible to compute an average property of the distance of the particles  or, for example, build a histogram. The squared distance <code>d2</code> is computed  internally for comparison with the  <code>cutoff</code>, and is passed to the <code>f</code> because many times it is used for the  desired computation. </p><p><strong>Example</strong></p><p>Computing the mean absolute difference in <code>x</code> position between random particles,  remembering the number of pairs of <code>n</code> particles is <code>n(n-1)/2</code>. The function does  not use the indices or the distance, such that we remove them from the parameters  by using a closure.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 100_000;

julia&gt; box = Box([250,250,250],10);

julia&gt; x = [ SVector{3,Float64}(sides .* rand(3)) for i in 1:n ];

julia&gt; cl = CellList(x,box);

julia&gt; f(x,y,sum_dx) = sum_dx + abs(x[1] - y[1])

julia&gt; normalization = N / (N*(N-1)/2) # (number of particles) / (number of pairs)

julia&gt; avg_dx = normalization * map_parwise!((x,y,i,j,d2,sum_dx) -&gt; f(x,y,sum_dx), 0.0, box, cl)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellListMap.jl#L24-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.merge_cell_lists!-Tuple{CellList, CellList}" href="#CellListMap.merge_cell_lists!-Tuple{CellList, CellList}"><code>CellListMap.merge_cell_lists!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_cell_lists!(cl::CellList,aux::CellList)</code></pre><p>Merges an auxiliary <code>aux</code> cell list to <code>cl</code>, and returns the modified <code>cl</code>. Used to merge cell lists computed in parallel threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L812-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbour_cells-Union{Tuple{Box{UnitCellType, 3, T, M} where {T, M}}, Tuple{UnitCellType}} where UnitCellType" href="#CellListMap.neighbour_cells-Union{Tuple{Box{UnitCellType, 3, T, M} where {T, M}}, Tuple{UnitCellType}} where UnitCellType"><code>CellListMap.neighbour_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbour_cells(box::Box{UnitCellType,N}) where N</code></pre><p>Function that returns the iterator of the cartesian indices of all neighbouring cells of a cell if the cells have sides of <code>box.cell_size</code>. <code>N</code> can be <code>2</code> or <code>3</code>, for two- or three-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L219-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbour_cells_forward-Union{Tuple{Box{UnitCellType, 3, T, M} where {T, M}}, Tuple{UnitCellType}} where UnitCellType" href="#CellListMap.neighbour_cells_forward-Union{Tuple{Box{UnitCellType, 3, T, M} where {T, M}}, Tuple{UnitCellType}} where UnitCellType"><code>CellListMap.neighbour_cells_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbour_cells_forward(box::Box{UnitCellType,N}) where UnitCellType </code></pre><p>Function that returns the iterator of the cartesian indices of the cells that must be  evaluated (forward, i. e. to avoid repeated interactions)  if the cells have sides of length <code>box.cell_size</code>. <code>N</code> can be <code>2</code> or <code>3</code>, for two- or three-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L188-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbourlist-Tuple{Any, Any, Any}" href="#CellListMap.neighbourlist-Tuple{Any, Any, Any}"><code>CellListMap.neighbourlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbourlist(x,y,r;parallel=true)</code></pre><p>Computes the list of pairs of particles of <code>x</code> which are closer than <code>r</code> to the particles of <code>y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; y = [ rand(3) for i in 1:1_000 ];

julia&gt; CellListMap.neighbourlist(x,y,0.05)
5006-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 269, 0.04770884036497686)
 (25, 892, 0.03850515231540869)
 ⋮
 (9952, 749, 0.048875643578313456)
 (9984, 620, 0.04101242499363183)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/utils.jl#L131-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbourlist-Tuple{Any, Any}" href="#CellListMap.neighbourlist-Tuple{Any, Any}"><code>CellListMap.neighbourlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbourlist(x,r;parallel=true)</code></pre><p>Computes the list of pairs of particles in <code>x</code> which are closer to each other than <code>r</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:10_000 ];

julia&gt; CellListMap.neighbourlist(x,0.05)
24848-element Vector{Tuple{Int64, Int64, Float64}}:
 (1, 1055, 0.022977369806392412)
 (1, 5086, 0.026650609138167428)
 ⋮
 (9989, 3379, 0.0467653507446483)
 (9989, 5935, 0.02432728985151653)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/utils.jl#L102-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.neighbourlist-Tuple{Box, Any}" href="#CellListMap.neighbourlist-Tuple{Box, Any}"><code>CellListMap.neighbourlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbourlist(box, cl; parallel=true)</code></pre><p>Compute the neighbour list of a single set or set pairs of particles. Returns a vector of tuples with all indices of the particles that are within <code>box.cutoff</code>, and the distances.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:1000 ];

julia&gt; box = Box([1,1,1],0.02) 
Box{OrthorhombicCell, 3, Float64, 9}
  unit cell matrix: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
  cutoff: 0.02
  number of computing cells on each dimension: [52, 52, 52]
  computing cell sizes: [0.02, 0.02, 0.02] (lcell: 1)
  Total number of cells: 140608

julia&gt; cl = CellList(x,box) # single set
CellList{3, Float64}
  999 cells with real particles.
  1126 particles in computing box, including images.


julia&gt; CellListMap.neighbourlist(box,cl,parallel=false)
15-element Vector{Tuple{Int64, Int64, Float64}}:
 (187, 511, 0.010346860078531755)
 (203, 708, 0.010777737363239403)
 (296, 579, 0.018124283912224655)
 ⋮
 (584, 4, 0.016935844769524398)
 (725, 749, 0.019971874892397875)
 (773, 119, 0.01835233336121765)
 (927, 8, 0.011234110402648743)
</code></pre><p>To obtain the neighbour list (within the cutoff) between two sets of  particles, initialize the cell lists with the two sets: </p><pre><code class="language-julia-repl hljs">julia&gt; x = [ rand(3) for i in 1:1000 ];

julia&gt; y = [ rand(3) for i in 1:1000 ];

julia&gt; box = Box([1,1,1],0.02);

julia&gt; cl = CellList(x,y,box)

julia&gt; cl = CellList(x,y,box)
CellListMap.CellListPair{Vector{SVector{3, Float64}}, 3, Float64}
   1000 particles in the reference vector.
   997 cells with real particles of target vector.

julia&gt; CellListMap.neighbourlist(box,cl)
35-element Vector{Tuple{Int64, Int64, Float64}}:
 (409, 982, 0.01634641594779082)
 (521, 422, 0.00919026348035512)
 (625, 731, 0.012986301890746663)
 ⋮
 (647, 730, 0.01565763971458105)
 (296, 668, 0.016556686306217868)
 (992, 589, 0.018392993428289553)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/utils.jl#L1-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.norm-Tuple{Any}" href="#CellListMap.norm-Tuple{Any}"><code>CellListMap.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::AbstractVector{T}) where T</code></pre><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. Thus we define our own <code>norm(x) = norm_sqr(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/linearalgebra.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#CellListMap.norm_sqr-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>CellListMap.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_sqr(v::AbstractVector{T}) where T</code></pre><p><code>norm_sqr</code> from LinearAlgebra is not documented and is slower than this for standard arrays. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/linearalgebra.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N" href="#CellListMap.out_of_bounding_box-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N"><code>CellListMap.out_of_bounding_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">out_of_bounding_box(x::SVector{N},box::Box) where N</code></pre><p>Function that evaluates if a particle is outside the computing bounding box, defined by the maximum and minimum unit cell coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L292-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N" href="#CellListMap.particle_cell-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, Box}} where N"><code>CellListMap.particle_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particle_cell(x::SVector{N,T}, box::Box) where {N,T}</code></pre><p>Returns the coordinates of the <em>computing cell</em> to which a particle belongs, given its coordinates and the <code>cell_size</code> vector. The computing box is always Orthorhombic, and the first computing box with positive coordinates has indexes <code>Box.lcell + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L240-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.particles_per_cell-Tuple{CellList, Box}" href="#CellListMap.particles_per_cell-Tuple{CellList, Box}"><code>CellListMap.particles_per_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particles_per_cell(cl::CellList,box::Box)</code></pre><p>Returns the average number of particles per computing cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L1156-L1164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.partition!-Tuple{Any, AbstractVector{T} where T}" href="#CellListMap.partition!-Tuple{Any, AbstractVector{T} where T}"><code>CellListMap.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition!(x::AbstractVector,by)</code></pre><p>Function that reorders <code>x</code> vector by putting in the first positions the elements with values satisfying <code>by(el)</code>. Returns the number of elements that satisfy the condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CoreComputing.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N, T, M} where {T, M}}} where {UnitCellType, N}" href="#CellListMap.project_particles!-Union{Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Any, Any, Any, Box{UnitCellType, N, T, M} where {T, M}}} where {UnitCellType, N}"><code>CellListMap.project_particles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project_particles!(projected_particles,cellⱼ,cellᵢ,Δc,Δc_norm,box)</code></pre><p>Projects all particles of the cell <code>cellⱼ</code> into unnitary vector <code>Δc</code> with direction  connecting the centers of <code>cellⱼ</code> and <code>cellᵢ</code>. Modifies <code>projected_particles</code>, and  returns a view of `projected particles, where only the particles for which the projection on the direction of the cell centers still allows the particle to be within the cutoff distance of any point of the other cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CoreComputing.jl#L285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T, L} where L}} where T" href="#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{2, 2, T, L} where L}} where T"><code>CellListMap.ranges_of_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T</code></pre><p>Function that sets which is the range of periodic images necessary to fill the computing box, in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L493-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T, L} where L}} where T" href="#CellListMap.ranges_of_replicas-Union{Tuple{T}, Tuple{Any, Any, Any, StaticArrays.SMatrix{3, 3, T, L} where L}} where T"><code>CellListMap.ranges_of_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ranges_of_replicas(cell_size, lcell, nc, unit_cell_matrix::SMatrix{3,3,T}) where T</code></pre><p>Function that sets which is the range of periodic images necessary to fill the computing box, in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L455-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.reduce-Tuple{Number, Vector{var&quot;#s47&quot;} where var&quot;#s47&quot;&lt;:Number}" href="#CellListMap.reduce-Tuple{Number, Vector{var&quot;#s47&quot;} where var&quot;#s47&quot;&lt;:Number}"><code>CellListMap.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(output::Number, output_threaded::Vector{&lt;:Number})</code></pre><p>Functions to reduce the output of common options (vectors of numbers  and vectors of vectors). This function can be overloaded by custom reduction methods. It always must both receive the <code>output</code> variable as a parameter, and return it at the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CoreComputing.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T} where T, Any, Any}} where N" href="#CellListMap.replicate_particle!-Union{Tuple{N}, Tuple{Any, StaticArrays.SVector{N, T} where T, Any, Any}} where N"><code>CellListMap.replicate_particle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replicate_particle!(ip,p::SVector{N},box,cl) where N</code></pre><p>Replicates the particle as many times as necessary to fill the computing box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L313-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}" href="#CellListMap.reset!-Union{Tuple{T}, Tuple{N}, Tuple{CellList{N, T}, Any, Any}} where {N, T}"><code>CellListMap.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset!(cl::CellList{N,T},box) where{N,T}</code></pre><p>Resets a cell list, by setting everything to zero, but retaining the allocated <code>particles</code> and <code>projected_particles</code> vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L349-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.set_nt-Tuple{Any}" href="#CellListMap.set_nt-Tuple{Any}"><code>CellListMap.set_nt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_nt(cl) = max(1,min(cl.n_real_particles÷500,nthreads()))</code></pre><p>Don&#39;t use all threads to build cell lists if the number of particles per thread is smaller than 500.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.strip_value-Tuple{Any}" href="#CellListMap.strip_value-Tuple{Any}"><code>CellListMap.strip_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip_value(x)</code></pre><p>This function by default does nothing, but it can be overloaded to remove decorations from types of variables that contain more information that the coordinate itself. For example, it can be used to deal with <code>Unitful</code> coordinates internaly, without having to copy the coordinates prior to passing it to <code>CellList</code>. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([100,100,100],10);

julia&gt; using Unitful

julia&gt; x = [ sides .* rand(SVector{3,Float64})u&quot;nm&quot; for i in 1:5 ]
5-element Vector{SVector{3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}}:
 [204.13761649857798 nm, 221.72338544218846 nm, 68.39256684613026 nm]
 [240.3490051044633 nm, 39.133140818690904 nm, 93.46671201972323 nm]
 [59.905431855598714 nm, 18.420162158120924 nm, 246.09423563049683 nm]
 [24.572857402685223 nm, 17.079711089908244 nm, 27.137908845124624 nm]
 [22.222703192699257 nm, 177.77658095653265 nm, 134.81396187256172 nm]

 julia&gt; CellListMap.strip_value(x::Unitful.Quantity) = Unitful.ustrip(x) 

 julia&gt; cl = CellList(x,box) # now x can be passed to CellList
CellList{3, Float64}
  5 real particles.
  5 cells with real particles.
  7 particles in computing box, including images.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellLists.jl#L698-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}" href="#CellListMap.translation_image-Union{Tuple{T}, Tuple{N}, Tuple{StaticArrays.SVector{N, T}, Any, Any}} where {N, T}"><code>CellListMap.translation_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translation_image(x::SVector{N,T},unit_cell_matrix,indices) where {N,T}</code></pre><p>Translate vector <code>x</code> according to the <code>unit_cell_matrix</code> lattice vectors and the <code>indices</code> provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L175-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#CellListMap.view_celllist_particles-Union{Tuple{CellList{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>CellListMap.view_celllist_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_celllist_particles(cl::CellList)</code></pre><p>Auxiliary function to view the particles of a computing box, including images created for computing purposes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; box = Box([ 100 50; 50 100 ],10);

julia&gt; x = [ box.unit_cell_max .* rand(SVector{2,Float64}) for i in 1:1000 ];

julia&gt; cl = CellList(x,box);

julia&gt; p = CellListMap.view_celllist_particles(cl);

julia&gt; using Plots

julia&gt; scatter(Tuple.(p),label=nothing,xlims=(-10,180),ylims=(-10,180))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/testing.jl#L40-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_cell_fraction-Tuple{Any, Any}" href="#CellListMap.wrap_cell_fraction-Tuple{Any, Any}"><code>CellListMap.wrap_cell_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_cell_fraction(x,unit_cell_matrix)</code></pre><p>Obtaint the coordinates of <code>x</code> as a fraction of unit cell vectors, first positive cell. <code>x</code> is a vector of dimension <code>N</code> and <code>cell</code> a matrix of  dimension <code>NxN</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unit_cell_matrix = [ 10 0
                            0 10 ];

julia&gt; x = [ 15, 13 ];

julia&gt; wrap_cell_fraction(x,unit_cell_matrix)
2-element Vector{Float64}:
 0.5
 0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector{T} where T}" href="#CellListMap.wrap_relative_to-Tuple{Any, Any, AbstractVector{T} where T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,sides::AbstractVector)</code></pre><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, for an Orthorhombic cell of which only the side lengths are provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L146-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T, M} where M}} where {N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Box{OrthorhombicCell, N, T, M} where M}} where {N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,box::Box{OrthorhombicCell,N,T}) where {N,T}</code></pre><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, given an Orthorhombic cell. This is slightly cheaper than for general cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L131-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T, L} where L}} where {N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, StaticArrays.SMatrix{N, N, T, L} where L}} where {N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x, xref, unit_cell_matrix::SMatrix{N,N,T}) where {N,T}</code></pre><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L102-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}" href="#CellListMap.wrap_relative_to-Union{Tuple{T}, Tuple{N}, Tuple{UnitCellType}, Tuple{Any, Any, Box{UnitCellType, N, T, M} where M}} where {UnitCellType, N, T}"><code>CellListMap.wrap_relative_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_relative_to(x,xref,box::Box{UnitCellType,N,T}) where {UnitCellType,N,T}</code></pre><p>Wraps the coordinates of point <code>x</code> such that it is the minimum image relative to <code>xref</code>, given a general <code>Box</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Tuple{Any, Any}" href="#CellListMap.wrap_to_first-Tuple{Any, Any}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,unit_cell_matrix)</code></pre><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates. </p><p><strong>Example</strong></p><p>```julia-repl julia&gt; unit<em>cell</em>matrix = [ 10 0                             0 10 ];</p><p>julia&gt; x = [ 15, 13 ];</p><p>julia&gt; wrap<em>to</em>first(x,unit<em>cell</em>matrix) 2-element Vector{Float64}:  5.0  3.0000000000000004  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L43-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Tuple{Any, Box}" href="#CellListMap.wrap_to_first-Tuple{Any, Box}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,box::Box)</code></pre><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates, given the <code>Box</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T, M} where M}} where {N, T}" href="#CellListMap.wrap_to_first-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{OrthorhombicCell, N, T, M} where M}} where {N, T}"><code>CellListMap.wrap_to_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_to_first(x,box::Box{OrthorhombicCell,N,T}) where {N,T}</code></pre><p>Wraps the coordinates of point <code>x</code> such that the returning coordinates are in the first unit cell with all-positive coordinates, given an Orthorhombic cell.  This is slightly cheaper than for general cells.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/CellListMap.jl/blob/3013f163fe07c6247bcb360a2fdfaf31a897d918/src/CellOperations.jl#L84-L94">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../options/">« Options</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 29 October 2021 00:50">Friday 29 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
